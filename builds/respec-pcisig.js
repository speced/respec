window.respecVersion = "35.6.1";

(function () {
  'use strict';

  // @ts-check
  const inAmd = !!window.require;
  if (!inAmd) {
    /**
     * @type {any}
     * @param {string[]} deps
     * @param {(...modules: any[]) => void} callback
     */
    const require = function (deps, callback) {
      const modules = deps.map(dep => {
        if (!(dep in window.require.modules)) {
          throw new Error(`Unsupported dependency name: ${dep}`);
        }
        return window.require.modules[dep];
      });
      Promise.all(modules).then(results => callback(...results));
    };
    require.modules = {};
    window.require = require;
  }

  /**
   * @param {string} name
   * @param {object | Promise<object>} object
   */
  function expose(name, object) {
    if (!inAmd) {
      window.require.modules[name] = object;
    }
  }

  // @ts-check
  /**
   * Module core/l10n
   *
   * Looks at the lang attribute on the root element and uses it
   * to manage the config.l10n object so that other parts of the system can
   * localize their text.
   */

  const name$F = "core/l10n";

  const html$2 = document.documentElement;
  // Explicitly default lang and dir on <html> if not set.
  // We assume English and ltr as default for international standards.
  if (!html$2?.hasAttribute("lang")) {
    html$2.lang = "en";
    if (!html$2.hasAttribute("dir")) {
      html$2.dir = "ltr";
    }
  }

  const l10n$c = {};

  const lang$1 = html$2?.lang ?? "en";

  function run$G(config) {
    config.l10n = l10n$c[lang$1] || l10n$c.en;
  }

  var l10n$d = /*#__PURE__*/Object.freeze({
    __proto__: null,
    l10n: l10n$c,
    lang: lang$1,
    name: name$F,
    run: run$G
  });

  const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);

  let idbProxyableTypes;
  let cursorAdvanceMethods;
  // This is a function to prevent it throwing up in node environments.
  function getIdbProxyableTypes() {
      return (idbProxyableTypes ||
          (idbProxyableTypes = [
              IDBDatabase,
              IDBObjectStore,
              IDBIndex,
              IDBCursor,
              IDBTransaction,
          ]));
  }
  // This is a function to prevent it throwing up in node environments.
  function getCursorAdvanceMethods() {
      return (cursorAdvanceMethods ||
          (cursorAdvanceMethods = [
              IDBCursor.prototype.advance,
              IDBCursor.prototype.continue,
              IDBCursor.prototype.continuePrimaryKey,
          ]));
  }
  const transactionDoneMap = new WeakMap();
  const transformCache = new WeakMap();
  const reverseTransformCache = new WeakMap();
  function promisifyRequest(request) {
      const promise = new Promise((resolve, reject) => {
          const unlisten = () => {
              request.removeEventListener('success', success);
              request.removeEventListener('error', error);
          };
          const success = () => {
              resolve(wrap(request.result));
              unlisten();
          };
          const error = () => {
              reject(request.error);
              unlisten();
          };
          request.addEventListener('success', success);
          request.addEventListener('error', error);
      });
      // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This
      // is because we create many promises from a single IDBRequest.
      reverseTransformCache.set(promise, request);
      return promise;
  }
  function cacheDonePromiseForTransaction(tx) {
      // Early bail if we've already created a done promise for this transaction.
      if (transactionDoneMap.has(tx))
          return;
      const done = new Promise((resolve, reject) => {
          const unlisten = () => {
              tx.removeEventListener('complete', complete);
              tx.removeEventListener('error', error);
              tx.removeEventListener('abort', error);
          };
          const complete = () => {
              resolve();
              unlisten();
          };
          const error = () => {
              reject(tx.error || new DOMException('AbortError', 'AbortError'));
              unlisten();
          };
          tx.addEventListener('complete', complete);
          tx.addEventListener('error', error);
          tx.addEventListener('abort', error);
      });
      // Cache it for later retrieval.
      transactionDoneMap.set(tx, done);
  }
  let idbProxyTraps = {
      get(target, prop, receiver) {
          if (target instanceof IDBTransaction) {
              // Special handling for transaction.done.
              if (prop === 'done')
                  return transactionDoneMap.get(target);
              // Make tx.store return the only store in the transaction, or undefined if there are many.
              if (prop === 'store') {
                  return receiver.objectStoreNames[1]
                      ? undefined
                      : receiver.objectStore(receiver.objectStoreNames[0]);
              }
          }
          // Else transform whatever we get back.
          return wrap(target[prop]);
      },
      set(target, prop, value) {
          target[prop] = value;
          return true;
      },
      has(target, prop) {
          if (target instanceof IDBTransaction &&
              (prop === 'done' || prop === 'store')) {
              return true;
          }
          return prop in target;
      },
  };
  function replaceTraps(callback) {
      idbProxyTraps = callback(idbProxyTraps);
  }
  function wrapFunction(func) {
      // Due to expected object equality (which is enforced by the caching in `wrap`), we
      // only create one new func per func.
      // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
      // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
      // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
      // with real promises, so each advance methods returns a new promise for the cursor object, or
      // undefined if the end of the cursor has been reached.
      if (getCursorAdvanceMethods().includes(func)) {
          return function (...args) {
              // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
              // the original object.
              func.apply(unwrap(this), args);
              return wrap(this.request);
          };
      }
      return function (...args) {
          // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
          // the original object.
          return wrap(func.apply(unwrap(this), args));
      };
  }
  function transformCachableValue(value) {
      if (typeof value === 'function')
          return wrapFunction(value);
      // This doesn't return, it just creates a 'done' promise for the transaction,
      // which is later returned for transaction.done (see idbObjectHandler).
      if (value instanceof IDBTransaction)
          cacheDonePromiseForTransaction(value);
      if (instanceOfAny(value, getIdbProxyableTypes()))
          return new Proxy(value, idbProxyTraps);
      // Return the same value back if we're not going to transform it.
      return value;
  }
  function wrap(value) {
      // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
      // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
      if (value instanceof IDBRequest)
          return promisifyRequest(value);
      // If we've already transformed this value before, reuse the transformed value.
      // This is faster, but it also provides object equality.
      if (transformCache.has(value))
          return transformCache.get(value);
      const newValue = transformCachableValue(value);
      // Not all types are transformed.
      // These may be primitive types, so they can't be WeakMap keys.
      if (newValue !== value) {
          transformCache.set(value, newValue);
          reverseTransformCache.set(newValue, value);
      }
      return newValue;
  }
  const unwrap = (value) => reverseTransformCache.get(value);

  /**
   * Open a database.
   *
   * @param name Name of the database.
   * @param version Schema version.
   * @param callbacks Additional callbacks.
   */
  function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
      const request = indexedDB.open(name, version);
      const openPromise = wrap(request);
      if (upgrade) {
          request.addEventListener('upgradeneeded', (event) => {
              upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
          });
      }
      if (blocked) {
          request.addEventListener('blocked', (event) => blocked(
          // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
          event.oldVersion, event.newVersion, event));
      }
      openPromise
          .then((db) => {
          if (terminated)
              db.addEventListener('close', () => terminated());
          if (blocking) {
              db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));
          }
      })
          .catch(() => { });
      return openPromise;
  }
  /**
   * Delete a database.
   *
   * @param name Name of the database.
   */
  function deleteDB(name, { blocked } = {}) {
      const request = indexedDB.deleteDatabase(name);
      if (blocked) {
          request.addEventListener('blocked', (event) => blocked(
          // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
          event.oldVersion, event));
      }
      return wrap(request).then(() => undefined);
  }

  const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
  const writeMethods = ['put', 'add', 'delete', 'clear'];
  const cachedMethods = new Map();
  function getMethod(target, prop) {
      if (!(target instanceof IDBDatabase &&
          !(prop in target) &&
          typeof prop === 'string')) {
          return;
      }
      if (cachedMethods.get(prop))
          return cachedMethods.get(prop);
      const targetFuncName = prop.replace(/FromIndex$/, '');
      const useIndex = prop !== targetFuncName;
      const isWrite = writeMethods.includes(targetFuncName);
      if (
      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||
          !(isWrite || readMethods.includes(targetFuncName))) {
          return;
      }
      const method = async function (storeName, ...args) {
          // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
          const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
          let target = tx.store;
          if (useIndex)
              target = target.index(args.shift());
          // Must reject if op rejects.
          // If it's a write operation, must reject if tx.done rejects.
          // Must reject with op rejection first.
          // Must resolve with op value.
          // Must handle both promises (no unhandled rejections)
          return (await Promise.all([
              target[targetFuncName](...args),
              isWrite && tx.done,
          ]))[0];
      };
      cachedMethods.set(prop, method);
      return method;
  }
  replaceTraps((oldTraps) => ({
      ...oldTraps,
      get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
      has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),
  }));

  const advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];
  const methodMap = {};
  const advanceResults = new WeakMap();
  const ittrProxiedCursorToOriginalProxy = new WeakMap();
  const cursorIteratorTraps = {
      get(target, prop) {
          if (!advanceMethodProps.includes(prop))
              return target[prop];
          let cachedFunc = methodMap[prop];
          if (!cachedFunc) {
              cachedFunc = methodMap[prop] = function (...args) {
                  advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
              };
          }
          return cachedFunc;
      },
  };
  async function* iterate(...args) {
      // tslint:disable-next-line:no-this-assignment
      let cursor = this;
      if (!(cursor instanceof IDBCursor)) {
          cursor = await cursor.openCursor(...args);
      }
      if (!cursor)
          return;
      cursor = cursor;
      const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
      ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
      // Map this double-proxy back to the original, so other cursor methods work.
      reverseTransformCache.set(proxiedCursor, unwrap(cursor));
      while (cursor) {
          yield proxiedCursor;
          // If one of the advancing methods was not called, call continue().
          cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
          advanceResults.delete(proxiedCursor);
      }
  }
  function isIteratorProp(target, prop) {
      return ((prop === Symbol.asyncIterator &&
          instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||
          (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));
  }
  replaceTraps((oldTraps) => ({
      ...oldTraps,
      get(target, prop, receiver) {
          if (isIteratorProp(target, prop))
              return iterate;
          return oldTraps.get(target, prop, receiver);
      },
      has(target, prop) {
          return isIteratorProp(target, prop) || oldTraps.has(target, prop);
      },
  }));

  var _idb = /*#__PURE__*/Object.freeze({
    __proto__: null,
    deleteDB: deleteDB,
    openDB: openDB,
    unwrap: unwrap,
    wrap: wrap
  });

  /**
   * Implementation of MIMEType and MIME Type parser from
   * https://mimesniff.spec.whatwg.org/
   */

  const HTTPTokenCodePoints = /^[!#$%&'*+-.^`|~\w]+$/;

  // "HTTP whitespace is U+000A LF, U+000D CR, U+0009 TAB or U+0020 SPACE."
  // eslint-disable-next-line no-control-regex
  const HTTPWhiteSpace = /[\u000A\u000D\u0009\u0020]/u;

  // An HTTP quoted-string token code point is
  // U+0009 TAB,
  // a code point in the range U+0020 SPACE to U+007E (~), inclusive,
  // or a code point in the range U+0080 through U+00FF (Ã¿), inclusive.
  // eslint-disable-next-line no-control-regex
  const HTTPQuotedString = /^[\u0009\u{0020}-\{u0073}\u{0080}-\u{00FF}]+$/u;

  let MIMEType$1 = class MIMEType {
    constructor(input) {
      const { type, subtype, params } = parseMimeType(input);
      this.type = type.trim().toLowerCase();
      this.subtype = subtype.trimEnd().toLowerCase();
      this.parameters = new Map(Object.entries(params));
    }

    /**
     * @see https://mimesniff.spec.whatwg.org/#mime-type-essence
     */
    get essence() {
      return `${this.type}/${this.subtype}`;
    }

    toString() {
      return serialize$1(this);
    }
  };
  /**
   * https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
   */
  function serialize$1(mimeType) {
    const { parameters, essence } = mimeType;
    if (!parameters.size) {
      return essence;
    }
    let paramStr = ";";
    for (const [key, value] of parameters.entries()) {
      paramStr += key;
      if (value !== null) {
        if (HTTPTokenCodePoints.test(value)) {
          paramStr += `=${value}`;
        } else {
          paramStr += `="${value}"`;
        }
      } else {
        // null or empty string
        paramStr += '=""';
      }
      paramStr += ";";
    }
    // remove final ";"
    return mimeType.essence + paramStr.slice(0, -1);
  }

  /**
   * Implementation of https://mimesniff.spec.whatwg.org/#parse-a-mime-type
   * parser state machines if as follows, params and param values are optional and can be null:
   *
   * "type"
   *    -> "subtype"
   *      -> "param-start" (ignores white space)
   *         -> "param-name"
   *            -> "param-value"
   *              -> "collect-quoted-string"
   *                -> "ignore-input-until-next-param"
   *
   *
   *
   * @param {String} input
   */
  function parseMimeType(input) {
    input = input.trim();
    if (!input) {
      throw new TypeError("Invalid input.");
    }

    let type = "";
    let subtype = "";
    let paramName = "";
    let paramValue = null;
    let params = new Map();
    let parserMode = "type";
    let inputArray = Array.from(input); // retain unicode chars
    for (let position = 0; position < inputArray.length; position++) {
      const char = inputArray[position];
      switch (parserMode) {
        case "type":
          if (char === "/") {
            parserMode = "subtype";
            continue;
          }
          type += char;
          break;
        case "subtype":
          if (char === ";") {
            parserMode = "param-start";
            continue;
          }
          subtype += char;
          break;
        case "param-start":
          // Skip HTTP white space
          if (HTTPWhiteSpace.test(char) || char === ";") {
            continue;
          }
          paramName += char;
          parserMode = "param-name";
          break;
        case "param-name":
          if (char === "=" || char === ";") {
            if (char === "=") {
              parserMode = "param-value";
              paramValue = null;
              continue;
            }
            params.set(paramName.toLowerCase(), null);
            paramName = "";
            continue;
          }
          paramName += char;
          break;
        case "param-value":
          if (char == '"') {
            parserMode = "collect-quoted-string";
            continue;
          }
          if (char === ";") {
            paramValue = paramValue.trimEnd();
            parserMode = "param-start";
            storeParam(params, paramName, paramValue);
            paramName = "";
            continue;
          }
          paramValue = typeof paramValue === "string" ? paramValue + char : char;
          break;
        case "collect-quoted-string":
          if (char === '"') {
            storeParam(params, paramName, paramValue);
            parserMode = "ignore-input-until-next-param";
            paramName = "";
            paramValue = null;
            continue;
          }
          if (char === "\\") {
            continue;
          }
          paramValue = typeof paramValue === "string" ? paramValue + char : char;
          break;
        case "ignore-input-until-next-param":
          if (char !== ";") {
            continue;
          }
          parserMode = "param-start";
          break;
        default:
          throw new Error(
            `State machine error - unknown parser mode: ${parserMode} `
          );
      }
    }
    if (paramName) {
      storeParam(params, paramName, paramValue);
    }
    if (type.trim() === "" || !HTTPTokenCodePoints.test(type)) {
      throw new TypeError("Invalid type");
    }
    if (subtype.trim() === "" || !HTTPTokenCodePoints.test(subtype)) {
      throw new TypeError("Invalid subtype");
    }
    return {
      type,
      subtype,
      params: Object.fromEntries(params.entries()),
    };
  }

  function storeParam(params, paramName, paramValue) {
    if (
      (paramName &&
        paramName !== "" &&
        !params.has(paramName) &&
        HTTPQuotedString.test(paramValue)) ||
      paramValue === null
    ) {
      params.set(paramName.toLowerCase(), paramValue);
    }
  }

  /**
   * marked v12.0.2 - a markdown parser
   * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)
   * https://github.com/markedjs/marked
   */

  /**
   * DO NOT EDIT THIS FILE
   * The code in this file is generated from files in ./src/
   */

  /**
   * Gets the original marked default options.
   */
  function _getDefaults() {
      return {
          async: false,
          breaks: false,
          extensions: null,
          gfm: true,
          hooks: null,
          pedantic: false,
          renderer: null,
          silent: false,
          tokenizer: null,
          walkTokens: null
      };
  }
  let _defaults = _getDefaults();
  function changeDefaults(newDefaults) {
      _defaults = newDefaults;
  }

  /**
   * Helpers
   */
  const escapeTest = /[&<>"']/;
  const escapeReplace = new RegExp(escapeTest.source, 'g');
  const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
  const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
  const escapeReplacements = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
  };
  const getEscapeReplacement = (ch) => escapeReplacements[ch];
  function escape$1(html, encode) {
      if (encode) {
          if (escapeTest.test(html)) {
              return html.replace(escapeReplace, getEscapeReplacement);
          }
      }
      else {
          if (escapeTestNoEncode.test(html)) {
              return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
          }
      }
      return html;
  }
  const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
  function unescape(html) {
      // explicitly match decimal, hex, and named HTML entities
      return html.replace(unescapeTest, (_, n) => {
          n = n.toLowerCase();
          if (n === 'colon')
              return ':';
          if (n.charAt(0) === '#') {
              return n.charAt(1) === 'x'
                  ? String.fromCharCode(parseInt(n.substring(2), 16))
                  : String.fromCharCode(+n.substring(1));
          }
          return '';
      });
  }
  const caret = /(^|[^\[])\^/g;
  function edit(regex, opt) {
      let source = typeof regex === 'string' ? regex : regex.source;
      opt = opt || '';
      const obj = {
          replace: (name, val) => {
              let valSource = typeof val === 'string' ? val : val.source;
              valSource = valSource.replace(caret, '$1');
              source = source.replace(name, valSource);
              return obj;
          },
          getRegex: () => {
              return new RegExp(source, opt);
          }
      };
      return obj;
  }
  function cleanUrl(href) {
      try {
          href = encodeURI(href).replace(/%25/g, '%');
      }
      catch (e) {
          return null;
      }
      return href;
  }
  const noopTest = { exec: () => null };
  function splitCells(tableRow, count) {
      // ensure that every cell-delimiting pipe has a space
      // before it to distinguish it from an escaped pipe
      const row = tableRow.replace(/\|/g, (match, offset, str) => {
          let escaped = false;
          let curr = offset;
          while (--curr >= 0 && str[curr] === '\\')
              escaped = !escaped;
          if (escaped) {
              // odd number of slashes means | is escaped
              // so we leave it alone
              return '|';
          }
          else {
              // add space before unescaped |
              return ' |';
          }
      }), cells = row.split(/ \|/);
      let i = 0;
      // First/last cell in a row cannot be empty if it has no leading/trailing pipe
      if (!cells[0].trim()) {
          cells.shift();
      }
      if (cells.length > 0 && !cells[cells.length - 1].trim()) {
          cells.pop();
      }
      if (count) {
          if (cells.length > count) {
              cells.splice(count);
          }
          else {
              while (cells.length < count)
                  cells.push('');
          }
      }
      for (; i < cells.length; i++) {
          // leading or trailing whitespace is ignored per the gfm spec
          cells[i] = cells[i].trim().replace(/\\\|/g, '|');
      }
      return cells;
  }
  /**
   * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
   * /c*$/ is vulnerable to REDOS.
   *
   * @param str
   * @param c
   * @param invert Remove suffix of non-c chars instead. Default falsey.
   */
  function rtrim(str, c, invert) {
      const l = str.length;
      if (l === 0) {
          return '';
      }
      // Length of suffix matching the invert condition.
      let suffLen = 0;
      // Step left until we fail to match the invert condition.
      while (suffLen < l) {
          const currChar = str.charAt(l - suffLen - 1);
          if (currChar === c && true) {
              suffLen++;
          }
          else {
              break;
          }
      }
      return str.slice(0, l - suffLen);
  }
  function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
          return -1;
      }
      let level = 0;
      for (let i = 0; i < str.length; i++) {
          if (str[i] === '\\') {
              i++;
          }
          else if (str[i] === b[0]) {
              level++;
          }
          else if (str[i] === b[1]) {
              level--;
              if (level < 0) {
                  return i;
              }
          }
      }
      return -1;
  }

  function outputLink(cap, link, raw, lexer) {
      const href = link.href;
      const title = link.title ? escape$1(link.title) : null;
      const text = cap[1].replace(/\\([\[\]])/g, '$1');
      if (cap[0].charAt(0) !== '!') {
          lexer.state.inLink = true;
          const token = {
              type: 'link',
              raw,
              href,
              title,
              text,
              tokens: lexer.inlineTokens(text)
          };
          lexer.state.inLink = false;
          return token;
      }
      return {
          type: 'image',
          raw,
          href,
          title,
          text: escape$1(text)
      };
  }
  function indentCodeCompensation(raw, text) {
      const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
          return text;
      }
      const indentToCode = matchIndentToCode[1];
      return text
          .split('\n')
          .map(node => {
          const matchIndentInNode = node.match(/^\s+/);
          if (matchIndentInNode === null) {
              return node;
          }
          const [indentInNode] = matchIndentInNode;
          if (indentInNode.length >= indentToCode.length) {
              return node.slice(indentToCode.length);
          }
          return node;
      })
          .join('\n');
  }
  /**
   * Tokenizer
   */
  class _Tokenizer {
      options;
      rules; // set by the lexer
      lexer; // set by the lexer
      constructor(options) {
          this.options = options || _defaults;
      }
      space(src) {
          const cap = this.rules.block.newline.exec(src);
          if (cap && cap[0].length > 0) {
              return {
                  type: 'space',
                  raw: cap[0]
              };
          }
      }
      code(src) {
          const cap = this.rules.block.code.exec(src);
          if (cap) {
              const text = cap[0].replace(/^ {1,4}/gm, '');
              return {
                  type: 'code',
                  raw: cap[0],
                  codeBlockStyle: 'indented',
                  text: !this.options.pedantic
                      ? rtrim(text, '\n')
                      : text
              };
          }
      }
      fences(src) {
          const cap = this.rules.block.fences.exec(src);
          if (cap) {
              const raw = cap[0];
              const text = indentCodeCompensation(raw, cap[3] || '');
              return {
                  type: 'code',
                  raw,
                  lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],
                  text
              };
          }
      }
      heading(src) {
          const cap = this.rules.block.heading.exec(src);
          if (cap) {
              let text = cap[2].trim();
              // remove trailing #s
              if (/#$/.test(text)) {
                  const trimmed = rtrim(text, '#');
                  if (this.options.pedantic) {
                      text = trimmed.trim();
                  }
                  else if (!trimmed || / $/.test(trimmed)) {
                      // CommonMark requires space before trailing #s
                      text = trimmed.trim();
                  }
              }
              return {
                  type: 'heading',
                  raw: cap[0],
                  depth: cap[1].length,
                  text,
                  tokens: this.lexer.inline(text)
              };
          }
      }
      hr(src) {
          const cap = this.rules.block.hr.exec(src);
          if (cap) {
              return {
                  type: 'hr',
                  raw: cap[0]
              };
          }
      }
      blockquote(src) {
          const cap = this.rules.block.blockquote.exec(src);
          if (cap) {
              // precede setext continuation with 4 spaces so it isn't a setext
              let text = cap[0].replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, '\n    $1');
              text = rtrim(text.replace(/^ *>[ \t]?/gm, ''), '\n');
              const top = this.lexer.state.top;
              this.lexer.state.top = true;
              const tokens = this.lexer.blockTokens(text);
              this.lexer.state.top = top;
              return {
                  type: 'blockquote',
                  raw: cap[0],
                  tokens,
                  text
              };
          }
      }
      list(src) {
          let cap = this.rules.block.list.exec(src);
          if (cap) {
              let bull = cap[1].trim();
              const isordered = bull.length > 1;
              const list = {
                  type: 'list',
                  raw: '',
                  ordered: isordered,
                  start: isordered ? +bull.slice(0, -1) : '',
                  loose: false,
                  items: []
              };
              bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
              if (this.options.pedantic) {
                  bull = isordered ? bull : '[*+-]';
              }
              // Get next list item
              const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|$))`);
              let raw = '';
              let itemContents = '';
              let endsWithBlankLine = false;
              // Check if current bullet point can start a new List Item
              while (src) {
                  let endEarly = false;
                  if (!(cap = itemRegex.exec(src))) {
                      break;
                  }
                  if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)
                      break;
                  }
                  raw = cap[0];
                  src = src.substring(raw.length);
                  let line = cap[2].split('\n', 1)[0].replace(/^\t+/, (t) => ' '.repeat(3 * t.length));
                  let nextLine = src.split('\n', 1)[0];
                  let indent = 0;
                  if (this.options.pedantic) {
                      indent = 2;
                      itemContents = line.trimStart();
                  }
                  else {
                      indent = cap[2].search(/[^ ]/); // Find first non-space char
                      indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
                      itemContents = line.slice(indent);
                      indent += cap[1].length;
                  }
                  let blankLine = false;
                  if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line
                      raw += nextLine + '\n';
                      src = src.substring(nextLine.length + 1);
                      endEarly = true;
                  }
                  if (!endEarly) {
                      const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`);
                      const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
                      const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
                      const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
                      // Check if following lines should be included in List Item
                      while (src) {
                          const rawLine = src.split('\n', 1)[0];
                          nextLine = rawLine;
                          // Re-align to follow commonmark nesting rules
                          if (this.options.pedantic) {
                              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');
                          }
                          // End list item if found code fences
                          if (fencesBeginRegex.test(nextLine)) {
                              break;
                          }
                          // End list item if found start of new heading
                          if (headingBeginRegex.test(nextLine)) {
                              break;
                          }
                          // End list item if found start of new bullet
                          if (nextBulletRegex.test(nextLine)) {
                              break;
                          }
                          // Horizontal rule found
                          if (hrRegex.test(src)) {
                              break;
                          }
                          if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible
                              itemContents += '\n' + nextLine.slice(indent);
                          }
                          else {
                              // not enough indentation
                              if (blankLine) {
                                  break;
                              }
                              // paragraph continuation unless last line was a different block level element
                              if (line.search(/[^ ]/) >= 4) { // indented code block
                                  break;
                              }
                              if (fencesBeginRegex.test(line)) {
                                  break;
                              }
                              if (headingBeginRegex.test(line)) {
                                  break;
                              }
                              if (hrRegex.test(line)) {
                                  break;
                              }
                              itemContents += '\n' + nextLine;
                          }
                          if (!blankLine && !nextLine.trim()) { // Check if current line is blank
                              blankLine = true;
                          }
                          raw += rawLine + '\n';
                          src = src.substring(rawLine.length + 1);
                          line = nextLine.slice(indent);
                      }
                  }
                  if (!list.loose) {
                      // If the previous item ended with a blank line, the list is loose
                      if (endsWithBlankLine) {
                          list.loose = true;
                      }
                      else if (/\n *\n *$/.test(raw)) {
                          endsWithBlankLine = true;
                      }
                  }
                  let istask = null;
                  let ischecked;
                  // Check for task list items
                  if (this.options.gfm) {
                      istask = /^\[[ xX]\] /.exec(itemContents);
                      if (istask) {
                          ischecked = istask[0] !== '[ ] ';
                          itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
                      }
                  }
                  list.items.push({
                      type: 'list_item',
                      raw,
                      task: !!istask,
                      checked: ischecked,
                      loose: false,
                      text: itemContents,
                      tokens: []
                  });
                  list.raw += raw;
              }
              // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
              list.items[list.items.length - 1].raw = raw.trimEnd();
              (list.items[list.items.length - 1]).text = itemContents.trimEnd();
              list.raw = list.raw.trimEnd();
              // Item child tokens handled here at end because we needed to have the final item to trim it first
              for (let i = 0; i < list.items.length; i++) {
                  this.lexer.state.top = false;
                  list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
                  if (!list.loose) {
                      // Check if list should be loose
                      const spacers = list.items[i].tokens.filter(t => t.type === 'space');
                      const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\n.*\n/.test(t.raw));
                      list.loose = hasMultipleLineBreaks;
                  }
              }
              // Set all items to loose if list is loose
              if (list.loose) {
                  for (let i = 0; i < list.items.length; i++) {
                      list.items[i].loose = true;
                  }
              }
              return list;
          }
      }
      html(src) {
          const cap = this.rules.block.html.exec(src);
          if (cap) {
              const token = {
                  type: 'html',
                  block: true,
                  raw: cap[0],
                  pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
                  text: cap[0]
              };
              return token;
          }
      }
      def(src) {
          const cap = this.rules.block.def.exec(src);
          if (cap) {
              const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
              const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';
              const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];
              return {
                  type: 'def',
                  tag,
                  raw: cap[0],
                  href,
                  title
              };
          }
      }
      table(src) {
          const cap = this.rules.block.table.exec(src);
          if (!cap) {
              return;
          }
          if (!/[:|]/.test(cap[2])) {
              // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading
              return;
          }
          const headers = splitCells(cap[1]);
          const aligns = cap[2].replace(/^\||\| *$/g, '').split('|');
          const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : [];
          const item = {
              type: 'table',
              raw: cap[0],
              header: [],
              align: [],
              rows: []
          };
          if (headers.length !== aligns.length) {
              // header and align columns must be equal, rows can be different.
              return;
          }
          for (const align of aligns) {
              if (/^ *-+: *$/.test(align)) {
                  item.align.push('right');
              }
              else if (/^ *:-+: *$/.test(align)) {
                  item.align.push('center');
              }
              else if (/^ *:-+ *$/.test(align)) {
                  item.align.push('left');
              }
              else {
                  item.align.push(null);
              }
          }
          for (const header of headers) {
              item.header.push({
                  text: header,
                  tokens: this.lexer.inline(header)
              });
          }
          for (const row of rows) {
              item.rows.push(splitCells(row, item.header.length).map(cell => {
                  return {
                      text: cell,
                      tokens: this.lexer.inline(cell)
                  };
              }));
          }
          return item;
      }
      lheading(src) {
          const cap = this.rules.block.lheading.exec(src);
          if (cap) {
              return {
                  type: 'heading',
                  raw: cap[0],
                  depth: cap[2].charAt(0) === '=' ? 1 : 2,
                  text: cap[1],
                  tokens: this.lexer.inline(cap[1])
              };
          }
      }
      paragraph(src) {
          const cap = this.rules.block.paragraph.exec(src);
          if (cap) {
              const text = cap[1].charAt(cap[1].length - 1) === '\n'
                  ? cap[1].slice(0, -1)
                  : cap[1];
              return {
                  type: 'paragraph',
                  raw: cap[0],
                  text,
                  tokens: this.lexer.inline(text)
              };
          }
      }
      text(src) {
          const cap = this.rules.block.text.exec(src);
          if (cap) {
              return {
                  type: 'text',
                  raw: cap[0],
                  text: cap[0],
                  tokens: this.lexer.inline(cap[0])
              };
          }
      }
      escape(src) {
          const cap = this.rules.inline.escape.exec(src);
          if (cap) {
              return {
                  type: 'escape',
                  raw: cap[0],
                  text: escape$1(cap[1])
              };
          }
      }
      tag(src) {
          const cap = this.rules.inline.tag.exec(src);
          if (cap) {
              if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
                  this.lexer.state.inLink = true;
              }
              else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
                  this.lexer.state.inLink = false;
              }
              if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                  this.lexer.state.inRawBlock = true;
              }
              else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                  this.lexer.state.inRawBlock = false;
              }
              return {
                  type: 'html',
                  raw: cap[0],
                  inLink: this.lexer.state.inLink,
                  inRawBlock: this.lexer.state.inRawBlock,
                  block: false,
                  text: cap[0]
              };
          }
      }
      link(src) {
          const cap = this.rules.inline.link.exec(src);
          if (cap) {
              const trimmedUrl = cap[2].trim();
              if (!this.options.pedantic && /^</.test(trimmedUrl)) {
                  // commonmark requires matching angle brackets
                  if (!(/>$/.test(trimmedUrl))) {
                      return;
                  }
                  // ending angle bracket cannot be escaped
                  const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
                  if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                      return;
                  }
              }
              else {
                  // find closing parenthesis
                  const lastParenIndex = findClosingBracket(cap[2], '()');
                  if (lastParenIndex > -1) {
                      const start = cap[0].indexOf('!') === 0 ? 5 : 4;
                      const linkLen = start + cap[1].length + lastParenIndex;
                      cap[2] = cap[2].substring(0, lastParenIndex);
                      cap[0] = cap[0].substring(0, linkLen).trim();
                      cap[3] = '';
                  }
              }
              let href = cap[2];
              let title = '';
              if (this.options.pedantic) {
                  // split pedantic href and title
                  const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
                  if (link) {
                      href = link[1];
                      title = link[3];
                  }
              }
              else {
                  title = cap[3] ? cap[3].slice(1, -1) : '';
              }
              href = href.trim();
              if (/^</.test(href)) {
                  if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {
                      // pedantic allows starting angle bracket without ending angle bracket
                      href = href.slice(1);
                  }
                  else {
                      href = href.slice(1, -1);
                  }
              }
              return outputLink(cap, {
                  href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,
                  title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title
              }, cap[0], this.lexer);
          }
      }
      reflink(src, links) {
          let cap;
          if ((cap = this.rules.inline.reflink.exec(src))
              || (cap = this.rules.inline.nolink.exec(src))) {
              const linkString = (cap[2] || cap[1]).replace(/\s+/g, ' ');
              const link = links[linkString.toLowerCase()];
              if (!link) {
                  const text = cap[0].charAt(0);
                  return {
                      type: 'text',
                      raw: text,
                      text
                  };
              }
              return outputLink(cap, link, cap[0], this.lexer);
          }
      }
      emStrong(src, maskedSrc, prevChar = '') {
          let match = this.rules.inline.emStrongLDelim.exec(src);
          if (!match)
              return;
          // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
          if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
              return;
          const nextChar = match[1] || match[2] || '';
          if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
              // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)
              const lLength = [...match[0]].length - 1;
              let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
              const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
              endReg.lastIndex = 0;
              // Clip maskedSrc to same section of string as src (move to lexer?)
              maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
              while ((match = endReg.exec(maskedSrc)) != null) {
                  rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
                  if (!rDelim)
                      continue; // skip single * in __abc*abc__
                  rLength = [...rDelim].length;
                  if (match[3] || match[4]) { // found another Left Delim
                      delimTotal += rLength;
                      continue;
                  }
                  else if (match[5] || match[6]) { // either Left or Right Delim
                      if (lLength % 3 && !((lLength + rLength) % 3)) {
                          midDelimTotal += rLength;
                          continue; // CommonMark Emphasis Rules 9-10
                      }
                  }
                  delimTotal -= rLength;
                  if (delimTotal > 0)
                      continue; // Haven't found enough closing delimiters
                  // Remove extra characters. *a*** -> *a*
                  rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
                  // char length can be >1 for unicode characters;
                  const lastCharLength = [...match[0]][0].length;
                  const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
                  // Create `em` if smallest delimiter has odd char count. *a***
                  if (Math.min(lLength, rLength) % 2) {
                      const text = raw.slice(1, -1);
                      return {
                          type: 'em',
                          raw,
                          text,
                          tokens: this.lexer.inlineTokens(text)
                      };
                  }
                  // Create 'strong' if smallest delimiter has even char count. **a***
                  const text = raw.slice(2, -2);
                  return {
                      type: 'strong',
                      raw,
                      text,
                      tokens: this.lexer.inlineTokens(text)
                  };
              }
          }
      }
      codespan(src) {
          const cap = this.rules.inline.code.exec(src);
          if (cap) {
              let text = cap[2].replace(/\n/g, ' ');
              const hasNonSpaceChars = /[^ ]/.test(text);
              const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
              if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
                  text = text.substring(1, text.length - 1);
              }
              text = escape$1(text, true);
              return {
                  type: 'codespan',
                  raw: cap[0],
                  text
              };
          }
      }
      br(src) {
          const cap = this.rules.inline.br.exec(src);
          if (cap) {
              return {
                  type: 'br',
                  raw: cap[0]
              };
          }
      }
      del(src) {
          const cap = this.rules.inline.del.exec(src);
          if (cap) {
              return {
                  type: 'del',
                  raw: cap[0],
                  text: cap[2],
                  tokens: this.lexer.inlineTokens(cap[2])
              };
          }
      }
      autolink(src) {
          const cap = this.rules.inline.autolink.exec(src);
          if (cap) {
              let text, href;
              if (cap[2] === '@') {
                  text = escape$1(cap[1]);
                  href = 'mailto:' + text;
              }
              else {
                  text = escape$1(cap[1]);
                  href = text;
              }
              return {
                  type: 'link',
                  raw: cap[0],
                  text,
                  href,
                  tokens: [
                      {
                          type: 'text',
                          raw: text,
                          text
                      }
                  ]
              };
          }
      }
      url(src) {
          let cap;
          if (cap = this.rules.inline.url.exec(src)) {
              let text, href;
              if (cap[2] === '@') {
                  text = escape$1(cap[0]);
                  href = 'mailto:' + text;
              }
              else {
                  // do extended autolink path validation
                  let prevCapZero;
                  do {
                      prevCapZero = cap[0];
                      cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';
                  } while (prevCapZero !== cap[0]);
                  text = escape$1(cap[0]);
                  if (cap[1] === 'www.') {
                      href = 'http://' + cap[0];
                  }
                  else {
                      href = cap[0];
                  }
              }
              return {
                  type: 'link',
                  raw: cap[0],
                  text,
                  href,
                  tokens: [
                      {
                          type: 'text',
                          raw: text,
                          text
                      }
                  ]
              };
          }
      }
      inlineText(src) {
          const cap = this.rules.inline.text.exec(src);
          if (cap) {
              let text;
              if (this.lexer.state.inRawBlock) {
                  text = cap[0];
              }
              else {
                  text = escape$1(cap[0]);
              }
              return {
                  type: 'text',
                  raw: cap[0],
                  text
              };
          }
      }
  }

  /**
   * Block-Level Grammar
   */
  const newline = /^(?: *(?:\n|$))+/;
  const blockCode = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/;
  const fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
  const hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
  const heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
  const bullet = /(?:[*+-]|\d{1,9}[.)])/;
  const lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/)
      .replace(/bull/g, bullet) // lists can interrupt
      .replace(/blockCode/g, / {4}/) // indented code blocks can interrupt
      .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt
      .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt
      .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt
      .replace(/html/g, / {0,3}<[^\n>]+>\n/) // block html can interrupt
      .getRegex();
  const _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
  const blockText = /^[^\n]+/;
  const _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  const def = edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/)
      .replace('label', _blockLabel)
      .replace('title', /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/)
      .getRegex();
  const list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
      .replace(/bull/g, bullet)
      .getRegex();
  const _tag = 'address|article|aside|base|basefont|blockquote|body|caption'
      + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
      + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
      + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
      + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'
      + '|tr|track|ul';
  const _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
  const html$1 = edit('^ {0,3}(?:' // optional indentation
      + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
      + '|comment[^\\n]*(\\n+|$)' // (2)
      + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
      + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
      + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
      + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
      + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
      + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
      + ')', 'i')
      .replace('comment', _comment)
      .replace('tag', _tag)
      .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
      .getRegex();
  const paragraph = edit(_paragraph)
      .replace('hr', hr)
      .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
      .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
      .replace('|table', '')
      .replace('blockquote', ' {0,3}>')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
      .replace('tag', _tag) // pars can be interrupted by type (6) html blocks
      .getRegex();
  const blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
      .replace('paragraph', paragraph)
      .getRegex();
  /**
   * Normal Block Grammar
   */
  const blockNormal = {
      blockquote,
      code: blockCode,
      def,
      fences,
      heading,
      hr,
      html: html$1,
      lheading,
      list,
      newline,
      paragraph,
      table: noopTest,
      text: blockText
  };
  /**
   * GFM Block Grammar
   */
  const gfmTable = edit('^ *([^\\n ].*)\\n' // Header
      + ' {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)' // Align
      + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)') // Cells
      .replace('hr', hr)
      .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
      .replace('blockquote', ' {0,3}>')
      .replace('code', ' {4}[^\\n]')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
      .replace('tag', _tag) // tables can be interrupted by type (6) html blocks
      .getRegex();
  const blockGfm = {
      ...blockNormal,
      table: gfmTable,
      paragraph: edit(_paragraph)
          .replace('hr', hr)
          .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
          .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
          .replace('table', gfmTable) // interrupt paragraphs with table
          .replace('blockquote', ' {0,3}>')
          .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
          .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
          .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
          .replace('tag', _tag) // pars can be interrupted by type (6) html blocks
          .getRegex()
  };
  /**
   * Pedantic grammar (original John Gruber's loose markdown specification)
   */
  const blockPedantic = {
      ...blockNormal,
      html: edit('^ *(?:comment *(?:\\n|\\s*$)'
          + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
          + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
          .replace('comment', _comment)
          .replace(/tag/g, '(?!(?:'
          + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
          + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
          + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
          .getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest, // fences not supported
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: edit(_paragraph)
          .replace('hr', hr)
          .replace('heading', ' *#{1,6} *[^\n]')
          .replace('lheading', lheading)
          .replace('|table', '')
          .replace('blockquote', ' {0,3}>')
          .replace('|fences', '')
          .replace('|list', '')
          .replace('|html', '')
          .replace('|tag', '')
          .getRegex()
  };
  /**
   * Inline-Level Grammar
   */
  const escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
  const inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
  const br = /^( {2,}|\\)\n(?!\s*$)/;
  const inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
  // list of unicode punctuation marks, plus any missing characters from CommonMark spec
  const _punctuation = '\\p{P}\\p{S}';
  const punctuation = edit(/^((?![*_])[\spunctuation])/, 'u')
      .replace(/punctuation/g, _punctuation).getRegex();
  // sequences em should skip over [title](link), `code`, <html>
  const blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
  const emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, 'u')
      .replace(/punct/g, _punctuation)
      .getRegex();
  const emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)' // Skip orphan inside strong
      + '|[^*]+(?=[^*])' // Consume to delim
      + '|(?!\\*)[punct](\\*+)(?=[\\s]|$)' // (1) #*** can only be a Right Delimiter
      + '|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter
      + '|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])' // (3) #***a, ***a can only be Left Delimiter
      + '|[\\s](\\*+)(?!\\*)(?=[punct])' // (4) ***# can only be Left Delimiter
      + '|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter
      + '|[^punct\\s](\\*+)(?=[^punct\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter
      .replace(/punct/g, _punctuation)
      .getRegex();
  // (6) Not allowed for _
  const emStrongRDelimUnd = edit('^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)' // Skip orphan inside strong
      + '|[^_]+(?=[^_])' // Consume to delim
      + '|(?!_)[punct](_+)(?=[\\s]|$)' // (1) #___ can only be a Right Delimiter
      + '|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter
      + '|(?!_)[punct\\s](_+)(?=[^punct\\s])' // (3) #___a, ___a can only be Left Delimiter
      + '|[\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter
      + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter
      .replace(/punct/g, _punctuation)
      .getRegex();
  const anyPunctuation = edit(/\\([punct])/, 'gu')
      .replace(/punct/g, _punctuation)
      .getRegex();
  const autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
      .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
      .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)
      .getRegex();
  const _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();
  const tag = edit('^comment'
      + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
      + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
      + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
      + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
      + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>') // CDATA section
      .replace('comment', _inlineComment)
      .replace('attribute', /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/)
      .getRegex();
  const _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  const link$1 = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/)
      .replace('label', _inlineLabel)
      .replace('href', /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/)
      .replace('title', /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/)
      .getRegex();
  const reflink = edit(/^!?\[(label)\]\[(ref)\]/)
      .replace('label', _inlineLabel)
      .replace('ref', _blockLabel)
      .getRegex();
  const nolink = edit(/^!?\[(ref)\](?:\[\])?/)
      .replace('ref', _blockLabel)
      .getRegex();
  const reflinkSearch = edit('reflink|nolink(?!\\()', 'g')
      .replace('reflink', reflink)
      .replace('nolink', nolink)
      .getRegex();
  /**
   * Normal Inline Grammar
   */
  const inlineNormal = {
      _backpedal: noopTest, // only used for GFM url
      anyPunctuation,
      autolink,
      blockSkip,
      br,
      code: inlineCode,
      del: noopTest,
      emStrongLDelim,
      emStrongRDelimAst,
      emStrongRDelimUnd,
      escape,
      link: link$1,
      nolink,
      punctuation,
      reflink,
      reflinkSearch,
      tag,
      text: inlineText,
      url: noopTest
  };
  /**
   * Pedantic Inline Grammar
   */
  const inlinePedantic = {
      ...inlineNormal,
      link: edit(/^!?\[(label)\]\((.*?)\)/)
          .replace('label', _inlineLabel)
          .getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
          .replace('label', _inlineLabel)
          .getRegex()
  };
  /**
   * GFM Inline Grammar
   */
  const inlineGfm = {
      ...inlineNormal,
      escape: edit(escape).replace('])', '~|])').getRegex(),
      url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, 'i')
          .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)
          .getRegex(),
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  };
  /**
   * GFM + Line Breaks Inline Grammar
   */
  const inlineBreaks = {
      ...inlineGfm,
      br: edit(br).replace('{2,}', '*').getRegex(),
      text: edit(inlineGfm.text)
          .replace('\\b_', '\\b_| {2,}\\n')
          .replace(/\{2,\}/g, '*')
          .getRegex()
  };
  /**
   * exports
   */
  const block = {
      normal: blockNormal,
      gfm: blockGfm,
      pedantic: blockPedantic
  };
  const inline = {
      normal: inlineNormal,
      gfm: inlineGfm,
      breaks: inlineBreaks,
      pedantic: inlinePedantic
  };

  /**
   * Block Lexer
   */
  class _Lexer {
      tokens;
      options;
      state;
      tokenizer;
      inlineQueue;
      constructor(options) {
          // TokenList cannot be created in one go
          this.tokens = [];
          this.tokens.links = Object.create(null);
          this.options = options || _defaults;
          this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
          this.tokenizer = this.options.tokenizer;
          this.tokenizer.options = this.options;
          this.tokenizer.lexer = this;
          this.inlineQueue = [];
          this.state = {
              inLink: false,
              inRawBlock: false,
              top: true
          };
          const rules = {
              block: block.normal,
              inline: inline.normal
          };
          if (this.options.pedantic) {
              rules.block = block.pedantic;
              rules.inline = inline.pedantic;
          }
          else if (this.options.gfm) {
              rules.block = block.gfm;
              if (this.options.breaks) {
                  rules.inline = inline.breaks;
              }
              else {
                  rules.inline = inline.gfm;
              }
          }
          this.tokenizer.rules = rules;
      }
      /**
       * Expose Rules
       */
      static get rules() {
          return {
              block,
              inline
          };
      }
      /**
       * Static Lex Method
       */
      static lex(src, options) {
          const lexer = new _Lexer(options);
          return lexer.lex(src);
      }
      /**
       * Static Lex Inline Method
       */
      static lexInline(src, options) {
          const lexer = new _Lexer(options);
          return lexer.inlineTokens(src);
      }
      /**
       * Preprocessing
       */
      lex(src) {
          src = src
              .replace(/\r\n|\r/g, '\n');
          this.blockTokens(src, this.tokens);
          for (let i = 0; i < this.inlineQueue.length; i++) {
              const next = this.inlineQueue[i];
              this.inlineTokens(next.src, next.tokens);
          }
          this.inlineQueue = [];
          return this.tokens;
      }
      blockTokens(src, tokens = []) {
          if (this.options.pedantic) {
              src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
          }
          else {
              src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
                  return leading + '    '.repeat(tabs.length);
              });
          }
          let token;
          let lastToken;
          let cutSrc;
          let lastParagraphClipped;
          while (src) {
              if (this.options.extensions
                  && this.options.extensions.block
                  && this.options.extensions.block.some((extTokenizer) => {
                      if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                          src = src.substring(token.raw.length);
                          tokens.push(token);
                          return true;
                      }
                      return false;
                  })) {
                  continue;
              }
              // newline
              if (token = this.tokenizer.space(src)) {
                  src = src.substring(token.raw.length);
                  if (token.raw.length === 1 && tokens.length > 0) {
                      // if there's a single \n as a spacer, it's terminating the last line,
                      // so move it there so that we don't get unnecessary paragraph tags
                      tokens[tokens.length - 1].raw += '\n';
                  }
                  else {
                      tokens.push(token);
                  }
                  continue;
              }
              // code
              if (token = this.tokenizer.code(src)) {
                  src = src.substring(token.raw.length);
                  lastToken = tokens[tokens.length - 1];
                  // An indented code block cannot interrupt a paragraph.
                  if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
                      lastToken.raw += '\n' + token.raw;
                      lastToken.text += '\n' + token.text;
                      this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                  }
                  else {
                      tokens.push(token);
                  }
                  continue;
              }
              // fences
              if (token = this.tokenizer.fences(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // heading
              if (token = this.tokenizer.heading(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // hr
              if (token = this.tokenizer.hr(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // blockquote
              if (token = this.tokenizer.blockquote(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // list
              if (token = this.tokenizer.list(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // html
              if (token = this.tokenizer.html(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // def
              if (token = this.tokenizer.def(src)) {
                  src = src.substring(token.raw.length);
                  lastToken = tokens[tokens.length - 1];
                  if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
                      lastToken.raw += '\n' + token.raw;
                      lastToken.text += '\n' + token.raw;
                      this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                  }
                  else if (!this.tokens.links[token.tag]) {
                      this.tokens.links[token.tag] = {
                          href: token.href,
                          title: token.title
                      };
                  }
                  continue;
              }
              // table (gfm)
              if (token = this.tokenizer.table(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // lheading
              if (token = this.tokenizer.lheading(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // top-level paragraph
              // prevent paragraph consuming extensions by clipping 'src' to extension start
              cutSrc = src;
              if (this.options.extensions && this.options.extensions.startBlock) {
                  let startIndex = Infinity;
                  const tempSrc = src.slice(1);
                  let tempStart;
                  this.options.extensions.startBlock.forEach((getStartIndex) => {
                      tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                      if (typeof tempStart === 'number' && tempStart >= 0) {
                          startIndex = Math.min(startIndex, tempStart);
                      }
                  });
                  if (startIndex < Infinity && startIndex >= 0) {
                      cutSrc = src.substring(0, startIndex + 1);
                  }
              }
              if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
                  lastToken = tokens[tokens.length - 1];
                  if (lastParagraphClipped && lastToken.type === 'paragraph') {
                      lastToken.raw += '\n' + token.raw;
                      lastToken.text += '\n' + token.text;
                      this.inlineQueue.pop();
                      this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                  }
                  else {
                      tokens.push(token);
                  }
                  lastParagraphClipped = (cutSrc.length !== src.length);
                  src = src.substring(token.raw.length);
                  continue;
              }
              // text
              if (token = this.tokenizer.text(src)) {
                  src = src.substring(token.raw.length);
                  lastToken = tokens[tokens.length - 1];
                  if (lastToken && lastToken.type === 'text') {
                      lastToken.raw += '\n' + token.raw;
                      lastToken.text += '\n' + token.text;
                      this.inlineQueue.pop();
                      this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                  }
                  else {
                      tokens.push(token);
                  }
                  continue;
              }
              if (src) {
                  const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                  if (this.options.silent) {
                      console.error(errMsg);
                      break;
                  }
                  else {
                      throw new Error(errMsg);
                  }
              }
          }
          this.state.top = true;
          return tokens;
      }
      inline(src, tokens = []) {
          this.inlineQueue.push({ src, tokens });
          return tokens;
      }
      /**
       * Lexing/Compiling
       */
      inlineTokens(src, tokens = []) {
          let token, lastToken, cutSrc;
          // String with links masked to avoid interference with em and strong
          let maskedSrc = src;
          let match;
          let keepPrevChar, prevChar;
          // Mask out reflinks
          if (this.tokens.links) {
              const links = Object.keys(this.tokens.links);
              if (links.length > 0) {
                  while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                      if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                          maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                      }
                  }
              }
          }
          // Mask out other blocks
          while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
              maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
          }
          // Mask out escaped characters
          while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
              maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
          }
          while (src) {
              if (!keepPrevChar) {
                  prevChar = '';
              }
              keepPrevChar = false;
              // extensions
              if (this.options.extensions
                  && this.options.extensions.inline
                  && this.options.extensions.inline.some((extTokenizer) => {
                      if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                          src = src.substring(token.raw.length);
                          tokens.push(token);
                          return true;
                      }
                      return false;
                  })) {
                  continue;
              }
              // escape
              if (token = this.tokenizer.escape(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // tag
              if (token = this.tokenizer.tag(src)) {
                  src = src.substring(token.raw.length);
                  lastToken = tokens[tokens.length - 1];
                  if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                      lastToken.raw += token.raw;
                      lastToken.text += token.text;
                  }
                  else {
                      tokens.push(token);
                  }
                  continue;
              }
              // link
              if (token = this.tokenizer.link(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // reflink, nolink
              if (token = this.tokenizer.reflink(src, this.tokens.links)) {
                  src = src.substring(token.raw.length);
                  lastToken = tokens[tokens.length - 1];
                  if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                      lastToken.raw += token.raw;
                      lastToken.text += token.text;
                  }
                  else {
                      tokens.push(token);
                  }
                  continue;
              }
              // em & strong
              if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // code
              if (token = this.tokenizer.codespan(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // br
              if (token = this.tokenizer.br(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // del (gfm)
              if (token = this.tokenizer.del(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // autolink
              if (token = this.tokenizer.autolink(src)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // url (gfm)
              if (!this.state.inLink && (token = this.tokenizer.url(src))) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  continue;
              }
              // text
              // prevent inlineText consuming extensions by clipping 'src' to extension start
              cutSrc = src;
              if (this.options.extensions && this.options.extensions.startInline) {
                  let startIndex = Infinity;
                  const tempSrc = src.slice(1);
                  let tempStart;
                  this.options.extensions.startInline.forEach((getStartIndex) => {
                      tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                      if (typeof tempStart === 'number' && tempStart >= 0) {
                          startIndex = Math.min(startIndex, tempStart);
                      }
                  });
                  if (startIndex < Infinity && startIndex >= 0) {
                      cutSrc = src.substring(0, startIndex + 1);
                  }
              }
              if (token = this.tokenizer.inlineText(cutSrc)) {
                  src = src.substring(token.raw.length);
                  if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started
                      prevChar = token.raw.slice(-1);
                  }
                  keepPrevChar = true;
                  lastToken = tokens[tokens.length - 1];
                  if (lastToken && lastToken.type === 'text') {
                      lastToken.raw += token.raw;
                      lastToken.text += token.text;
                  }
                  else {
                      tokens.push(token);
                  }
                  continue;
              }
              if (src) {
                  const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                  if (this.options.silent) {
                      console.error(errMsg);
                      break;
                  }
                  else {
                      throw new Error(errMsg);
                  }
              }
          }
          return tokens;
      }
  }

  /**
   * Renderer
   */
  class _Renderer {
      options;
      constructor(options) {
          this.options = options || _defaults;
      }
      code(code, infostring, escaped) {
          const lang = (infostring || '').match(/^\S*/)?.[0];
          code = code.replace(/\n$/, '') + '\n';
          if (!lang) {
              return '<pre><code>'
                  + (escaped ? code : escape$1(code, true))
                  + '</code></pre>\n';
          }
          return '<pre><code class="language-'
              + escape$1(lang)
              + '">'
              + (escaped ? code : escape$1(code, true))
              + '</code></pre>\n';
      }
      blockquote(quote) {
          return `<blockquote>\n${quote}</blockquote>\n`;
      }
      html(html, block) {
          return html;
      }
      heading(text, level, raw) {
          // ignore IDs
          return `<h${level}>${text}</h${level}>\n`;
      }
      hr() {
          return '<hr>\n';
      }
      list(body, ordered, start) {
          const type = ordered ? 'ol' : 'ul';
          const startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
          return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
      }
      listitem(text, task, checked) {
          return `<li>${text}</li>\n`;
      }
      checkbox(checked) {
          return '<input '
              + (checked ? 'checked="" ' : '')
              + 'disabled="" type="checkbox">';
      }
      paragraph(text) {
          return `<p>${text}</p>\n`;
      }
      table(header, body) {
          if (body)
              body = `<tbody>${body}</tbody>`;
          return '<table>\n'
              + '<thead>\n'
              + header
              + '</thead>\n'
              + body
              + '</table>\n';
      }
      tablerow(content) {
          return `<tr>\n${content}</tr>\n`;
      }
      tablecell(content, flags) {
          const type = flags.header ? 'th' : 'td';
          const tag = flags.align
              ? `<${type} align="${flags.align}">`
              : `<${type}>`;
          return tag + content + `</${type}>\n`;
      }
      /**
       * span level renderer
       */
      strong(text) {
          return `<strong>${text}</strong>`;
      }
      em(text) {
          return `<em>${text}</em>`;
      }
      codespan(text) {
          return `<code>${text}</code>`;
      }
      br() {
          return '<br>';
      }
      del(text) {
          return `<del>${text}</del>`;
      }
      link(href, title, text) {
          const cleanHref = cleanUrl(href);
          if (cleanHref === null) {
              return text;
          }
          href = cleanHref;
          let out = '<a href="' + href + '"';
          if (title) {
              out += ' title="' + title + '"';
          }
          out += '>' + text + '</a>';
          return out;
      }
      image(href, title, text) {
          const cleanHref = cleanUrl(href);
          if (cleanHref === null) {
              return text;
          }
          href = cleanHref;
          let out = `<img src="${href}" alt="${text}"`;
          if (title) {
              out += ` title="${title}"`;
          }
          out += '>';
          return out;
      }
      text(text) {
          return text;
      }
  }

  /**
   * TextRenderer
   * returns only the textual part of the token
   */
  class _TextRenderer {
      // no need for block level renderers
      strong(text) {
          return text;
      }
      em(text) {
          return text;
      }
      codespan(text) {
          return text;
      }
      del(text) {
          return text;
      }
      html(text) {
          return text;
      }
      text(text) {
          return text;
      }
      link(href, title, text) {
          return '' + text;
      }
      image(href, title, text) {
          return '' + text;
      }
      br() {
          return '';
      }
  }

  /**
   * Parsing & Compiling
   */
  class _Parser {
      options;
      renderer;
      textRenderer;
      constructor(options) {
          this.options = options || _defaults;
          this.options.renderer = this.options.renderer || new _Renderer();
          this.renderer = this.options.renderer;
          this.renderer.options = this.options;
          this.textRenderer = new _TextRenderer();
      }
      /**
       * Static Parse Method
       */
      static parse(tokens, options) {
          const parser = new _Parser(options);
          return parser.parse(tokens);
      }
      /**
       * Static Parse Inline Method
       */
      static parseInline(tokens, options) {
          const parser = new _Parser(options);
          return parser.parseInline(tokens);
      }
      /**
       * Parse Loop
       */
      parse(tokens, top = true) {
          let out = '';
          for (let i = 0; i < tokens.length; i++) {
              const token = tokens[i];
              // Run any renderer extensions
              if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
                  const genericToken = token;
                  const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
                  if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {
                      out += ret || '';
                      continue;
                  }
              }
              switch (token.type) {
                  case 'space': {
                      continue;
                  }
                  case 'hr': {
                      out += this.renderer.hr();
                      continue;
                  }
                  case 'heading': {
                      const headingToken = token;
                      out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));
                      continue;
                  }
                  case 'code': {
                      const codeToken = token;
                      out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
                      continue;
                  }
                  case 'table': {
                      const tableToken = token;
                      let header = '';
                      // header
                      let cell = '';
                      for (let j = 0; j < tableToken.header.length; j++) {
                          cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });
                      }
                      header += this.renderer.tablerow(cell);
                      let body = '';
                      for (let j = 0; j < tableToken.rows.length; j++) {
                          const row = tableToken.rows[j];
                          cell = '';
                          for (let k = 0; k < row.length; k++) {
                              cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });
                          }
                          body += this.renderer.tablerow(cell);
                      }
                      out += this.renderer.table(header, body);
                      continue;
                  }
                  case 'blockquote': {
                      const blockquoteToken = token;
                      const body = this.parse(blockquoteToken.tokens);
                      out += this.renderer.blockquote(body);
                      continue;
                  }
                  case 'list': {
                      const listToken = token;
                      const ordered = listToken.ordered;
                      const start = listToken.start;
                      const loose = listToken.loose;
                      let body = '';
                      for (let j = 0; j < listToken.items.length; j++) {
                          const item = listToken.items[j];
                          const checked = item.checked;
                          const task = item.task;
                          let itemBody = '';
                          if (item.task) {
                              const checkbox = this.renderer.checkbox(!!checked);
                              if (loose) {
                                  if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                                          item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                                      }
                                  }
                                  else {
                                      item.tokens.unshift({
                                          type: 'text',
                                          text: checkbox + ' '
                                      });
                                  }
                              }
                              else {
                                  itemBody += checkbox + ' ';
                              }
                          }
                          itemBody += this.parse(item.tokens, loose);
                          body += this.renderer.listitem(itemBody, task, !!checked);
                      }
                      out += this.renderer.list(body, ordered, start);
                      continue;
                  }
                  case 'html': {
                      const htmlToken = token;
                      out += this.renderer.html(htmlToken.text, htmlToken.block);
                      continue;
                  }
                  case 'paragraph': {
                      const paragraphToken = token;
                      out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
                      continue;
                  }
                  case 'text': {
                      let textToken = token;
                      let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
                      while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {
                          textToken = tokens[++i];
                          body += '\n' + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
                      }
                      out += top ? this.renderer.paragraph(body) : body;
                      continue;
                  }
                  default: {
                      const errMsg = 'Token with "' + token.type + '" type was not found.';
                      if (this.options.silent) {
                          console.error(errMsg);
                          return '';
                      }
                      else {
                          throw new Error(errMsg);
                      }
                  }
              }
          }
          return out;
      }
      /**
       * Parse Inline Tokens
       */
      parseInline(tokens, renderer) {
          renderer = renderer || this.renderer;
          let out = '';
          for (let i = 0; i < tokens.length; i++) {
              const token = tokens[i];
              // Run any renderer extensions
              if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
                  const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
                  if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
                      out += ret || '';
                      continue;
                  }
              }
              switch (token.type) {
                  case 'escape': {
                      const escapeToken = token;
                      out += renderer.text(escapeToken.text);
                      break;
                  }
                  case 'html': {
                      const tagToken = token;
                      out += renderer.html(tagToken.text);
                      break;
                  }
                  case 'link': {
                      const linkToken = token;
                      out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));
                      break;
                  }
                  case 'image': {
                      const imageToken = token;
                      out += renderer.image(imageToken.href, imageToken.title, imageToken.text);
                      break;
                  }
                  case 'strong': {
                      const strongToken = token;
                      out += renderer.strong(this.parseInline(strongToken.tokens, renderer));
                      break;
                  }
                  case 'em': {
                      const emToken = token;
                      out += renderer.em(this.parseInline(emToken.tokens, renderer));
                      break;
                  }
                  case 'codespan': {
                      const codespanToken = token;
                      out += renderer.codespan(codespanToken.text);
                      break;
                  }
                  case 'br': {
                      out += renderer.br();
                      break;
                  }
                  case 'del': {
                      const delToken = token;
                      out += renderer.del(this.parseInline(delToken.tokens, renderer));
                      break;
                  }
                  case 'text': {
                      const textToken = token;
                      out += renderer.text(textToken.text);
                      break;
                  }
                  default: {
                      const errMsg = 'Token with "' + token.type + '" type was not found.';
                      if (this.options.silent) {
                          console.error(errMsg);
                          return '';
                      }
                      else {
                          throw new Error(errMsg);
                      }
                  }
              }
          }
          return out;
      }
  }

  class _Hooks {
      options;
      constructor(options) {
          this.options = options || _defaults;
      }
      static passThroughHooks = new Set([
          'preprocess',
          'postprocess',
          'processAllTokens'
      ]);
      /**
       * Process markdown before marked
       */
      preprocess(markdown) {
          return markdown;
      }
      /**
       * Process HTML after marked is finished
       */
      postprocess(html) {
          return html;
      }
      /**
       * Process all tokens before walk tokens
       */
      processAllTokens(tokens) {
          return tokens;
      }
  }

  class Marked {
      defaults = _getDefaults();
      options = this.setOptions;
      parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);
      parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);
      Parser = _Parser;
      Renderer = _Renderer;
      TextRenderer = _TextRenderer;
      Lexer = _Lexer;
      Tokenizer = _Tokenizer;
      Hooks = _Hooks;
      constructor(...args) {
          this.use(...args);
      }
      /**
       * Run callback for every token
       */
      walkTokens(tokens, callback) {
          let values = [];
          for (const token of tokens) {
              values = values.concat(callback.call(this, token));
              switch (token.type) {
                  case 'table': {
                      const tableToken = token;
                      for (const cell of tableToken.header) {
                          values = values.concat(this.walkTokens(cell.tokens, callback));
                      }
                      for (const row of tableToken.rows) {
                          for (const cell of row) {
                              values = values.concat(this.walkTokens(cell.tokens, callback));
                          }
                      }
                      break;
                  }
                  case 'list': {
                      const listToken = token;
                      values = values.concat(this.walkTokens(listToken.items, callback));
                      break;
                  }
                  default: {
                      const genericToken = token;
                      if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
                          this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                              const tokens = genericToken[childTokens].flat(Infinity);
                              values = values.concat(this.walkTokens(tokens, callback));
                          });
                      }
                      else if (genericToken.tokens) {
                          values = values.concat(this.walkTokens(genericToken.tokens, callback));
                      }
                  }
              }
          }
          return values;
      }
      use(...args) {
          const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
          args.forEach((pack) => {
              // copy options to new object
              const opts = { ...pack };
              // set async to true if it was set to true before
              opts.async = this.defaults.async || opts.async || false;
              // ==-- Parse "addon" extensions --== //
              if (pack.extensions) {
                  pack.extensions.forEach((ext) => {
                      if (!ext.name) {
                          throw new Error('extension name required');
                      }
                      if ('renderer' in ext) { // Renderer extensions
                          const prevRenderer = extensions.renderers[ext.name];
                          if (prevRenderer) {
                              // Replace extension with func to run new extension but fall back if false
                              extensions.renderers[ext.name] = function (...args) {
                                  let ret = ext.renderer.apply(this, args);
                                  if (ret === false) {
                                      ret = prevRenderer.apply(this, args);
                                  }
                                  return ret;
                              };
                          }
                          else {
                              extensions.renderers[ext.name] = ext.renderer;
                          }
                      }
                      if ('tokenizer' in ext) { // Tokenizer Extensions
                          if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {
                              throw new Error("extension level must be 'block' or 'inline'");
                          }
                          const extLevel = extensions[ext.level];
                          if (extLevel) {
                              extLevel.unshift(ext.tokenizer);
                          }
                          else {
                              extensions[ext.level] = [ext.tokenizer];
                          }
                          if (ext.start) { // Function to check for start of token
                              if (ext.level === 'block') {
                                  if (extensions.startBlock) {
                                      extensions.startBlock.push(ext.start);
                                  }
                                  else {
                                      extensions.startBlock = [ext.start];
                                  }
                              }
                              else if (ext.level === 'inline') {
                                  if (extensions.startInline) {
                                      extensions.startInline.push(ext.start);
                                  }
                                  else {
                                      extensions.startInline = [ext.start];
                                  }
                              }
                          }
                      }
                      if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens
                          extensions.childTokens[ext.name] = ext.childTokens;
                      }
                  });
                  opts.extensions = extensions;
              }
              // ==-- Parse "overwrite" extensions --== //
              if (pack.renderer) {
                  const renderer = this.defaults.renderer || new _Renderer(this.defaults);
                  for (const prop in pack.renderer) {
                      if (!(prop in renderer)) {
                          throw new Error(`renderer '${prop}' does not exist`);
                      }
                      if (prop === 'options') {
                          // ignore options property
                          continue;
                      }
                      const rendererProp = prop;
                      const rendererFunc = pack.renderer[rendererProp];
                      const prevRenderer = renderer[rendererProp];
                      // Replace renderer with func to run extension, but fall back if false
                      renderer[rendererProp] = (...args) => {
                          let ret = rendererFunc.apply(renderer, args);
                          if (ret === false) {
                              ret = prevRenderer.apply(renderer, args);
                          }
                          return ret || '';
                      };
                  }
                  opts.renderer = renderer;
              }
              if (pack.tokenizer) {
                  const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
                  for (const prop in pack.tokenizer) {
                      if (!(prop in tokenizer)) {
                          throw new Error(`tokenizer '${prop}' does not exist`);
                      }
                      if (['options', 'rules', 'lexer'].includes(prop)) {
                          // ignore options, rules, and lexer properties
                          continue;
                      }
                      const tokenizerProp = prop;
                      const tokenizerFunc = pack.tokenizer[tokenizerProp];
                      const prevTokenizer = tokenizer[tokenizerProp];
                      // Replace tokenizer with func to run extension, but fall back if false
                      // @ts-expect-error cannot type tokenizer function dynamically
                      tokenizer[tokenizerProp] = (...args) => {
                          let ret = tokenizerFunc.apply(tokenizer, args);
                          if (ret === false) {
                              ret = prevTokenizer.apply(tokenizer, args);
                          }
                          return ret;
                      };
                  }
                  opts.tokenizer = tokenizer;
              }
              // ==-- Parse Hooks extensions --== //
              if (pack.hooks) {
                  const hooks = this.defaults.hooks || new _Hooks();
                  for (const prop in pack.hooks) {
                      if (!(prop in hooks)) {
                          throw new Error(`hook '${prop}' does not exist`);
                      }
                      if (prop === 'options') {
                          // ignore options property
                          continue;
                      }
                      const hooksProp = prop;
                      const hooksFunc = pack.hooks[hooksProp];
                      const prevHook = hooks[hooksProp];
                      if (_Hooks.passThroughHooks.has(prop)) {
                          // @ts-expect-error cannot type hook function dynamically
                          hooks[hooksProp] = (arg) => {
                              if (this.defaults.async) {
                                  return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {
                                      return prevHook.call(hooks, ret);
                                  });
                              }
                              const ret = hooksFunc.call(hooks, arg);
                              return prevHook.call(hooks, ret);
                          };
                      }
                      else {
                          // @ts-expect-error cannot type hook function dynamically
                          hooks[hooksProp] = (...args) => {
                              let ret = hooksFunc.apply(hooks, args);
                              if (ret === false) {
                                  ret = prevHook.apply(hooks, args);
                              }
                              return ret;
                          };
                      }
                  }
                  opts.hooks = hooks;
              }
              // ==-- Parse WalkTokens extensions --== //
              if (pack.walkTokens) {
                  const walkTokens = this.defaults.walkTokens;
                  const packWalktokens = pack.walkTokens;
                  opts.walkTokens = function (token) {
                      let values = [];
                      values.push(packWalktokens.call(this, token));
                      if (walkTokens) {
                          values = values.concat(walkTokens.call(this, token));
                      }
                      return values;
                  };
              }
              this.defaults = { ...this.defaults, ...opts };
          });
          return this;
      }
      setOptions(opt) {
          this.defaults = { ...this.defaults, ...opt };
          return this;
      }
      lexer(src, options) {
          return _Lexer.lex(src, options ?? this.defaults);
      }
      parser(tokens, options) {
          return _Parser.parse(tokens, options ?? this.defaults);
      }
      #parseMarkdown(lexer, parser) {
          return (src, options) => {
              const origOpt = { ...options };
              const opt = { ...this.defaults, ...origOpt };
              // Show warning if an extension set async to true but the parse was called with async: false
              if (this.defaults.async === true && origOpt.async === false) {
                  if (!opt.silent) {
                      console.warn('marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.');
                  }
                  opt.async = true;
              }
              const throwError = this.#onError(!!opt.silent, !!opt.async);
              // throw error in case of non string input
              if (typeof src === 'undefined' || src === null) {
                  return throwError(new Error('marked(): input parameter is undefined or null'));
              }
              if (typeof src !== 'string') {
                  return throwError(new Error('marked(): input parameter is of type '
                      + Object.prototype.toString.call(src) + ', string expected'));
              }
              if (opt.hooks) {
                  opt.hooks.options = opt;
              }
              if (opt.async) {
                  return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)
                      .then(src => lexer(src, opt))
                      .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)
                      .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)
                      .then(tokens => parser(tokens, opt))
                      .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)
                      .catch(throwError);
              }
              try {
                  if (opt.hooks) {
                      src = opt.hooks.preprocess(src);
                  }
                  let tokens = lexer(src, opt);
                  if (opt.hooks) {
                      tokens = opt.hooks.processAllTokens(tokens);
                  }
                  if (opt.walkTokens) {
                      this.walkTokens(tokens, opt.walkTokens);
                  }
                  let html = parser(tokens, opt);
                  if (opt.hooks) {
                      html = opt.hooks.postprocess(html);
                  }
                  return html;
              }
              catch (e) {
                  return throwError(e);
              }
          };
      }
      #onError(silent, async) {
          return (e) => {
              e.message += '\nPlease report this to https://github.com/markedjs/marked.';
              if (silent) {
                  const msg = '<p>An error occurred:</p><pre>'
                      + escape$1(e.message + '', true)
                      + '</pre>';
                  if (async) {
                      return Promise.resolve(msg);
                  }
                  return msg;
              }
              if (async) {
                  return Promise.reject(e);
              }
              throw e;
          };
      }
  }

  const markedInstance = new Marked();
  function marked$1(src, opt) {
      return markedInstance.parse(src, opt);
  }
  /**
   * Sets the default options.
   *
   * @param options Hash of options
   */
  marked$1.options =
      marked$1.setOptions = function (options) {
          markedInstance.setOptions(options);
          marked$1.defaults = markedInstance.defaults;
          changeDefaults(marked$1.defaults);
          return marked$1;
      };
  /**
   * Gets the original marked default options.
   */
  marked$1.getDefaults = _getDefaults;
  marked$1.defaults = _defaults;
  /**
   * Use Extension
   */
  marked$1.use = function (...args) {
      markedInstance.use(...args);
      marked$1.defaults = markedInstance.defaults;
      changeDefaults(marked$1.defaults);
      return marked$1;
  };
  /**
   * Run callback for every token
   */
  marked$1.walkTokens = function (tokens, callback) {
      return markedInstance.walkTokens(tokens, callback);
  };
  /**
   * Compiles markdown to HTML without enclosing `p` tag.
   *
   * @param src String of markdown source to be compiled
   * @param options Hash of options
   * @return String of compiled HTML
   */
  marked$1.parseInline = markedInstance.parseInline;
  /**
   * Expose
   */
  marked$1.Parser = _Parser;
  marked$1.parser = _Parser.parse;
  marked$1.Renderer = _Renderer;
  marked$1.TextRenderer = _TextRenderer;
  marked$1.Lexer = _Lexer;
  marked$1.lexer = _Lexer.lex;
  marked$1.Tokenizer = _Tokenizer;
  marked$1.Hooks = _Hooks;
  marked$1.parse = marked$1;
  marked$1.options;
  marked$1.setOptions;
  marked$1.use;
  marked$1.walkTokens;
  marked$1.parseInline;
  _Parser.parse;
  _Lexer.lex;

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function commonjsRequire(path) {
  	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }

  var pluralize$2 = {exports: {}};

  /* global define */
  var pluralize$1 = pluralize$2.exports;

  var hasRequiredPluralize;

  function requirePluralize () {
  	if (hasRequiredPluralize) return pluralize$2.exports;
  	hasRequiredPluralize = 1;
  	(function (module, exports$1) {
  		(function (root, pluralize) {
  		  /* istanbul ignore else */
  		  if (typeof commonjsRequire === 'function' && 'object' === 'object' && 'object' === 'object') {
  		    // Node.
  		    module.exports = pluralize();
  		  } else {
  		    // Browser global.
  		    root.pluralize = pluralize();
  		  }
  		})(pluralize$1, function () {
  		  // Rule storage - pluralize and singularize need to be run sequentially,
  		  // while other rules can be optimized using an object for instant lookups.
  		  var pluralRules = [];
  		  var singularRules = [];
  		  var uncountables = {};
  		  var irregularPlurals = {};
  		  var irregularSingles = {};

  		  /**
  		   * Sanitize a pluralization rule to a usable regular expression.
  		   *
  		   * @param  {(RegExp|string)} rule
  		   * @return {RegExp}
  		   */
  		  function sanitizeRule (rule) {
  		    if (typeof rule === 'string') {
  		      return new RegExp('^' + rule + '$', 'i');
  		    }

  		    return rule;
  		  }

  		  /**
  		   * Pass in a word token to produce a function that can replicate the case on
  		   * another word.
  		   *
  		   * @param  {string}   word
  		   * @param  {string}   token
  		   * @return {Function}
  		   */
  		  function restoreCase (word, token) {
  		    // Tokens are an exact match.
  		    if (word === token) return token;

  		    // Lower cased words. E.g. "hello".
  		    if (word === word.toLowerCase()) return token.toLowerCase();

  		    // Upper cased words. E.g. "WHISKY".
  		    if (word === word.toUpperCase()) return token.toUpperCase();

  		    // Title cased words. E.g. "Title".
  		    if (word[0] === word[0].toUpperCase()) {
  		      return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
  		    }

  		    // Lower cased words. E.g. "test".
  		    return token.toLowerCase();
  		  }

  		  /**
  		   * Interpolate a regexp string.
  		   *
  		   * @param  {string} str
  		   * @param  {Array}  args
  		   * @return {string}
  		   */
  		  function interpolate (str, args) {
  		    return str.replace(/\$(\d{1,2})/g, function (match, index) {
  		      return args[index] || '';
  		    });
  		  }

  		  /**
  		   * Replace a word using a rule.
  		   *
  		   * @param  {string} word
  		   * @param  {Array}  rule
  		   * @return {string}
  		   */
  		  function replace (word, rule) {
  		    return word.replace(rule[0], function (match, index) {
  		      var result = interpolate(rule[1], arguments);

  		      if (match === '') {
  		        return restoreCase(word[index - 1], result);
  		      }

  		      return restoreCase(match, result);
  		    });
  		  }

  		  /**
  		   * Sanitize a word by passing in the word and sanitization rules.
  		   *
  		   * @param  {string}   token
  		   * @param  {string}   word
  		   * @param  {Array}    rules
  		   * @return {string}
  		   */
  		  function sanitizeWord (token, word, rules) {
  		    // Empty string or doesn't need fixing.
  		    if (!token.length || uncountables.hasOwnProperty(token)) {
  		      return word;
  		    }

  		    var len = rules.length;

  		    // Iterate over the sanitization rules and use the first one to match.
  		    while (len--) {
  		      var rule = rules[len];

  		      if (rule[0].test(word)) return replace(word, rule);
  		    }

  		    return word;
  		  }

  		  /**
  		   * Replace a word with the updated word.
  		   *
  		   * @param  {Object}   replaceMap
  		   * @param  {Object}   keepMap
  		   * @param  {Array}    rules
  		   * @return {Function}
  		   */
  		  function replaceWord (replaceMap, keepMap, rules) {
  		    return function (word) {
  		      // Get the correct token and case restoration functions.
  		      var token = word.toLowerCase();

  		      // Check against the keep object map.
  		      if (keepMap.hasOwnProperty(token)) {
  		        return restoreCase(word, token);
  		      }

  		      // Check against the replacement map for a direct word replacement.
  		      if (replaceMap.hasOwnProperty(token)) {
  		        return restoreCase(word, replaceMap[token]);
  		      }

  		      // Run all the rules against the word.
  		      return sanitizeWord(token, word, rules);
  		    };
  		  }

  		  /**
  		   * Check if a word is part of the map.
  		   */
  		  function checkWord (replaceMap, keepMap, rules, bool) {
  		    return function (word) {
  		      var token = word.toLowerCase();

  		      if (keepMap.hasOwnProperty(token)) return true;
  		      if (replaceMap.hasOwnProperty(token)) return false;

  		      return sanitizeWord(token, token, rules) === token;
  		    };
  		  }

  		  /**
  		   * Pluralize or singularize a word based on the passed in count.
  		   *
  		   * @param  {string}  word      The word to pluralize
  		   * @param  {number}  count     How many of the word exist
  		   * @param  {boolean} inclusive Whether to prefix with the number (e.g. 3 ducks)
  		   * @return {string}
  		   */
  		  function pluralize (word, count, inclusive) {
  		    var pluralized = count === 1
  		      ? pluralize.singular(word) : pluralize.plural(word);

  		    return (inclusive ? count + ' ' : '') + pluralized;
  		  }

  		  /**
  		   * Pluralize a word.
  		   *
  		   * @type {Function}
  		   */
  		  pluralize.plural = replaceWord(
  		    irregularSingles, irregularPlurals, pluralRules
  		  );

  		  /**
  		   * Check if a word is plural.
  		   *
  		   * @type {Function}
  		   */
  		  pluralize.isPlural = checkWord(
  		    irregularSingles, irregularPlurals, pluralRules
  		  );

  		  /**
  		   * Singularize a word.
  		   *
  		   * @type {Function}
  		   */
  		  pluralize.singular = replaceWord(
  		    irregularPlurals, irregularSingles, singularRules
  		  );

  		  /**
  		   * Check if a word is singular.
  		   *
  		   * @type {Function}
  		   */
  		  pluralize.isSingular = checkWord(
  		    irregularPlurals, irregularSingles, singularRules
  		  );

  		  /**
  		   * Add a pluralization rule to the collection.
  		   *
  		   * @param {(string|RegExp)} rule
  		   * @param {string}          replacement
  		   */
  		  pluralize.addPluralRule = function (rule, replacement) {
  		    pluralRules.push([sanitizeRule(rule), replacement]);
  		  };

  		  /**
  		   * Add a singularization rule to the collection.
  		   *
  		   * @param {(string|RegExp)} rule
  		   * @param {string}          replacement
  		   */
  		  pluralize.addSingularRule = function (rule, replacement) {
  		    singularRules.push([sanitizeRule(rule), replacement]);
  		  };

  		  /**
  		   * Add an uncountable word rule.
  		   *
  		   * @param {(string|RegExp)} word
  		   */
  		  pluralize.addUncountableRule = function (word) {
  		    if (typeof word === 'string') {
  		      uncountables[word.toLowerCase()] = true;
  		      return;
  		    }

  		    // Set singular and plural references for the word.
  		    pluralize.addPluralRule(word, '$0');
  		    pluralize.addSingularRule(word, '$0');
  		  };

  		  /**
  		   * Add an irregular word definition.
  		   *
  		   * @param {string} single
  		   * @param {string} plural
  		   */
  		  pluralize.addIrregularRule = function (single, plural) {
  		    plural = plural.toLowerCase();
  		    single = single.toLowerCase();

  		    irregularSingles[single] = plural;
  		    irregularPlurals[plural] = single;
  		  };

  		  /**
  		   * Irregular rules.
  		   */
  		  [
  		    // Pronouns.
  		    ['I', 'we'],
  		    ['me', 'us'],
  		    ['he', 'they'],
  		    ['she', 'they'],
  		    ['them', 'them'],
  		    ['myself', 'ourselves'],
  		    ['yourself', 'yourselves'],
  		    ['itself', 'themselves'],
  		    ['herself', 'themselves'],
  		    ['himself', 'themselves'],
  		    ['themself', 'themselves'],
  		    ['is', 'are'],
  		    ['was', 'were'],
  		    ['has', 'have'],
  		    ['this', 'these'],
  		    ['that', 'those'],
  		    // Words ending in with a consonant and `o`.
  		    ['echo', 'echoes'],
  		    ['dingo', 'dingoes'],
  		    ['volcano', 'volcanoes'],
  		    ['tornado', 'tornadoes'],
  		    ['torpedo', 'torpedoes'],
  		    // Ends with `us`.
  		    ['genus', 'genera'],
  		    ['viscus', 'viscera'],
  		    // Ends with `ma`.
  		    ['stigma', 'stigmata'],
  		    ['stoma', 'stomata'],
  		    ['dogma', 'dogmata'],
  		    ['lemma', 'lemmata'],
  		    ['schema', 'schemata'],
  		    ['anathema', 'anathemata'],
  		    // Other irregular rules.
  		    ['ox', 'oxen'],
  		    ['axe', 'axes'],
  		    ['die', 'dice'],
  		    ['yes', 'yeses'],
  		    ['foot', 'feet'],
  		    ['eave', 'eaves'],
  		    ['goose', 'geese'],
  		    ['tooth', 'teeth'],
  		    ['quiz', 'quizzes'],
  		    ['human', 'humans'],
  		    ['proof', 'proofs'],
  		    ['carve', 'carves'],
  		    ['valve', 'valves'],
  		    ['looey', 'looies'],
  		    ['thief', 'thieves'],
  		    ['groove', 'grooves'],
  		    ['pickaxe', 'pickaxes'],
  		    ['passerby', 'passersby']
  		  ].forEach(function (rule) {
  		    return pluralize.addIrregularRule(rule[0], rule[1]);
  		  });

  		  /**
  		   * Pluralization rules.
  		   */
  		  [
  		    [/s?$/i, 's'],
  		    [/[^\u0000-\u007F]$/i, '$0'],
  		    [/([^aeiou]ese)$/i, '$1'],
  		    [/(ax|test)is$/i, '$1es'],
  		    [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, '$1es'],
  		    [/(e[mn]u)s?$/i, '$1s'],
  		    [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, '$1'],
  		    [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1i'],
  		    [/(alumn|alg|vertebr)(?:a|ae)$/i, '$1ae'],
  		    [/(seraph|cherub)(?:im)?$/i, '$1im'],
  		    [/(her|at|gr)o$/i, '$1oes'],
  		    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, '$1a'],
  		    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, '$1a'],
  		    [/sis$/i, 'ses'],
  		    [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, '$1$2ves'],
  		    [/([^aeiouy]|qu)y$/i, '$1ies'],
  		    [/([^ch][ieo][ln])ey$/i, '$1ies'],
  		    [/(x|ch|ss|sh|zz)$/i, '$1es'],
  		    [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, '$1ices'],
  		    [/\b((?:tit)?m|l)(?:ice|ouse)$/i, '$1ice'],
  		    [/(pe)(?:rson|ople)$/i, '$1ople'],
  		    [/(child)(?:ren)?$/i, '$1ren'],
  		    [/eaux$/i, '$0'],
  		    [/m[ae]n$/i, 'men'],
  		    ['thou', 'you']
  		  ].forEach(function (rule) {
  		    return pluralize.addPluralRule(rule[0], rule[1]);
  		  });

  		  /**
  		   * Singularization rules.
  		   */
  		  [
  		    [/s$/i, ''],
  		    [/(ss)$/i, '$1'],
  		    [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, '$1fe'],
  		    [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, '$1f'],
  		    [/ies$/i, 'y'],
  		    [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, '$1ie'],
  		    [/\b(mon|smil)ies$/i, '$1ey'],
  		    [/\b((?:tit)?m|l)ice$/i, '$1ouse'],
  		    [/(seraph|cherub)im$/i, '$1'],
  		    [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, '$1'],
  		    [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, '$1sis'],
  		    [/(movie|twelve|abuse|e[mn]u)s$/i, '$1'],
  		    [/(test)(?:is|es)$/i, '$1is'],
  		    [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1us'],
  		    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, '$1um'],
  		    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, '$1on'],
  		    [/(alumn|alg|vertebr)ae$/i, '$1a'],
  		    [/(cod|mur|sil|vert|ind)ices$/i, '$1ex'],
  		    [/(matr|append)ices$/i, '$1ix'],
  		    [/(pe)(rson|ople)$/i, '$1rson'],
  		    [/(child)ren$/i, '$1'],
  		    [/(eau)x?$/i, '$1'],
  		    [/men$/i, 'man']
  		  ].forEach(function (rule) {
  		    return pluralize.addSingularRule(rule[0], rule[1]);
  		  });

  		  /**
  		   * Uncountable rules.
  		   */
  		  [
  		    // Singular words with no plurals.
  		    'adulthood',
  		    'advice',
  		    'agenda',
  		    'aid',
  		    'aircraft',
  		    'alcohol',
  		    'ammo',
  		    'analytics',
  		    'anime',
  		    'athletics',
  		    'audio',
  		    'bison',
  		    'blood',
  		    'bream',
  		    'buffalo',
  		    'butter',
  		    'carp',
  		    'cash',
  		    'chassis',
  		    'chess',
  		    'clothing',
  		    'cod',
  		    'commerce',
  		    'cooperation',
  		    'corps',
  		    'debris',
  		    'diabetes',
  		    'digestion',
  		    'elk',
  		    'energy',
  		    'equipment',
  		    'excretion',
  		    'expertise',
  		    'firmware',
  		    'flounder',
  		    'fun',
  		    'gallows',
  		    'garbage',
  		    'graffiti',
  		    'hardware',
  		    'headquarters',
  		    'health',
  		    'herpes',
  		    'highjinks',
  		    'homework',
  		    'housework',
  		    'information',
  		    'jeans',
  		    'justice',
  		    'kudos',
  		    'labour',
  		    'literature',
  		    'machinery',
  		    'mackerel',
  		    'mail',
  		    'media',
  		    'mews',
  		    'moose',
  		    'music',
  		    'mud',
  		    'manga',
  		    'news',
  		    'only',
  		    'personnel',
  		    'pike',
  		    'plankton',
  		    'pliers',
  		    'police',
  		    'pollution',
  		    'premises',
  		    'rain',
  		    'research',
  		    'rice',
  		    'salmon',
  		    'scissors',
  		    'series',
  		    'sewage',
  		    'shambles',
  		    'shrimp',
  		    'software',
  		    'species',
  		    'staff',
  		    'swine',
  		    'tennis',
  		    'traffic',
  		    'transportation',
  		    'trout',
  		    'tuna',
  		    'wealth',
  		    'welfare',
  		    'whiting',
  		    'wildebeest',
  		    'wildlife',
  		    'you',
  		    /pok[eÃ©]mon$/i,
  		    // Regexes.
  		    /[^aeiou]ese$/i, // "chinese", "japanese"
  		    /deer$/i, // "deer", "reindeer"
  		    /fish$/i, // "fish", "blowfish", "angelfish"
  		    /measles$/i,
  		    /o[iu]s$/i, // "carnivorous"
  		    /pox$/i, // "chickpox", "smallpox"
  		    /sheep$/i
  		  ].forEach(pluralize.addUncountableRule);

  		  return pluralize;
  		}); 
  	} (pluralize$2));
  	return pluralize$2.exports;
  }

  var pluralizeExports = requirePluralize();
  var pluralize$3 = /*@__PURE__*/getDefaultExportFromCjs(pluralizeExports);

  /*! (c) Andrea Giammarchi (ISC) */var hyperHTML$1=function(N){var t={};try{t.WeakMap=WeakMap;}catch(e){t.WeakMap=function(t,e){var n=e.defineProperty,r=e.hasOwnProperty,i=a.prototype;return i.delete=function(e){return this.has(e)&&delete e[this._]},i.get=function(e){return this.has(e)?e[this._]:void 0},i.has=function(e){return r.call(e,this._)},i.set=function(e,t){return n(e,this._,{configurable:true,value:t}),this},a;function a(e){n(this,"_",{value:"_@ungap/weakmap"+t++}),e&&e.forEach(o,this);}function o(e){this.set(e[0],e[1]);}}(Math.random(),Object);}var s=t.WeakMap,i={};try{i.WeakSet=WeakSet;}catch(e){!function(e,t){var n=r.prototype;function r(){t(this,"_",{value:"_@ungap/weakmap"+e++});}n.add=function(e){return this.has(e)||t(e,this._,{value:true,configurable:true}),this},n.has=function(e){return this.hasOwnProperty.call(e,this._)},n.delete=function(e){return this.has(e)&&delete e[this._]},i.WeakSet=r;}(Math.random(),Object.defineProperty);}function m(e,t,n,r,i,a){for(var o=("selectedIndex"in t),u=o;r<i;){var c,l=e(n[r],1);t.insertBefore(l,a),o&&u&&l.selected&&(u=!u,c=t.selectedIndex,t.selectedIndex=c<0?r:f.call(t.querySelectorAll("option"),l)),r++;}}function y(e,t){return e==t}function b(e){return e}function w(e,t,n,r,i,a,o){var u=a-i;if(u<1)return  -1;for(;u<=n-t;){for(var c=t,l=i;c<n&&l<a&&o(e[c],r[l]);)c++,l++;if(l===a)return t;t=c+1;}return  -1}function x(e,t,n,r,i){return n<r?e(t[n],0):0<n?e(t[n-1],-0).nextSibling:i}function E(e,t,n,r){for(;n<r;)a(e(t[n++],-1));}function C(e,t,n,r,i,a,o,u,c,l,s,f,h){!function(e,t,n,r,i,a,o,u,c){for(var l=[],s=e.length,f=o,h=0;h<s;)switch(e[h++]){case 0:i++,f++;break;case 1:l.push(r[i]),m(t,n,r,i++,i,f<u?t(a[f],0):c);break;case  -1:f++;}for(h=0;h<s;)switch(e[h++]){case 0:o++;break;case  -1:-1<l.indexOf(a[o])?o++:E(t,a,o++,o);}}(function(e,t,n,r,i,a,o){var u,c,l,s,f,h,d=n+a,v=[];e:for(m=0;m<=d;m++){if(50<m)return null;for(h=m-1,s=m?v[m-1]:[0,0],f=v[m]=[],u=-m;u<=m;u+=2){for(c=(l=u===-m||u!==m&&s[h+u-1]<s[h+u+1]?s[h+u+1]:s[h+u-1]+1)-u;l<a&&c<n&&o(r[i+l],e[t+c]);)l++,c++;if(l===a&&c===n)break e;f[m+u]=l;}}for(var p=Array(m/2+d/2),g=p.length-1,m=v.length-1;0<=m;m--){for(;0<l&&0<c&&o(r[i+l-1],e[t+c-1]);)p[g--]=0,l--,c--;if(!m)break;h=m-1,s=m?v[m-1]:[0,0],(u=l-c)===-m||u!==m&&s[h+u-1]<s[h+u+1]?(c--,p[g--]=1):(l--,p[g--]=-1);}return p}(n,r,a,o,u,l,f)||function(e,t,n,r,i,a,o,u){var c=0,l=r<u?r:u,s=Array(l++),f=Array(l);f[0]=-1;for(var h=1;h<l;h++)f[h]=o;for(var d=i.slice(a,o),v=t;v<n;v++){var p,g=d.indexOf(e[v]);-1<g&&(-1<(c=k(f,l,p=g+a))&&(f[c]=p,s[c]={newi:v,oldi:p,prev:s[c-1]}));}for(c=--l,--o;f[c]>o;)--c;l=u+r-c;var m=Array(l),y=s[c];for(--n;y;){for(var b=y.newi,w=y.oldi;b<n;)m[--l]=1,--n;for(;w<o;)m[--l]=-1,--o;m[--l]=0,--n,--o,y=y.prev;}for(;t<=n;)m[--l]=1,--n;for(;a<=o;)m[--l]=-1,--o;return m}(n,r,i,a,o,u,c,l),e,t,n,r,o,u,s,h);}var e=i.WeakSet,f=[].indexOf,k=function(e,t,n){for(var r=1,i=t;r<i;){var a=(r+i)/2>>>0;n<e[a]?i=a:r=1+a;}return r},a=function(e){return (e.remove||function(){var e=this.parentNode;e&&e.removeChild(this);}).call(e)};function l(e,t,n,r){for(var i=(r=r||{}).compare||y,a=r.node||b,o=null==r.before?null:a(r.before,0),u=t.length,c=u,l=0,s=n.length,f=0;l<c&&f<s&&i(t[l],n[f]);)l++,f++;for(;l<c&&f<s&&i(t[c-1],n[s-1]);)c--,s--;var h=l===c,d=f===s;if(h&&d)return n;if(h&&f<s)return m(a,e,n,f,s,x(a,t,l,u,o)),n;if(d&&l<c)return E(a,t,l,c),n;var v=c-l,p=s-f,g=-1;if(v<p){if(-1<(g=w(n,f,s,t,l,c,i)))return m(a,e,n,f,g,a(t[l],0)),m(a,e,n,g+v,s,x(a,t,c,u,o)),n}else if(p<v&&-1<(g=w(t,l,c,n,f,s,i)))return E(a,t,l,g),E(a,t,g+p,c),n;return v<2||p<2?(m(a,e,n,f,s,a(t[l],0)),E(a,t,l,c)):v==p&&function(e,t,n,r,i,a){for(;r<i&&a(n[r],e[t-1]);)r++,t--;return 0===t}(n,s,t,l,c,i)?m(a,e,n,f,s,x(a,t,c,u,o)):C(a,e,n,f,s,p,t,l,c,v,u,i,o),n}var n,r={};function o(e,t){t=t||{};var n=N.createEvent("CustomEvent");return n.initCustomEvent(e,!!t.bubbles,!!t.cancelable,t.detail),n}r.CustomEvent="function"==typeof CustomEvent?CustomEvent:(o[n="prototype"]=new o("").constructor[n],o);var u=r.CustomEvent,c={};try{c.Map=Map;}catch(e){c.Map=function(){var n=0,i=[],a=[];return {delete:function(e){var t=r(e);return t&&(i.splice(n,1),a.splice(n,1)),t},forEach:function(n,r){i.forEach(function(e,t){n.call(r,a[t],e,this);},this);},get:function(e){return r(e)?a[n]:void 0},has:r,set:function(e,t){return a[r(e)?n:i.push(e)-1]=t,this}};function r(e){return  -1<(n=i.indexOf(e))}};}var h=c.Map;function d(){return this}function v(e,t){var n="_"+e+"$";return {get:function(){return this[n]||p(this,n,t.call(this,e))},set:function(e){p(this,n,e);}}}var p=function(e,t,n){return Object.defineProperty(e,t,{configurable:true,value:"function"==typeof n?function(){return e._wire$=n.apply(this,arguments)}:n})[t]};Object.defineProperties(d.prototype,{ELEMENT_NODE:{value:1},nodeType:{value:-1}});var g,A,S,O,T,M,_={},j={},L=[],P=j.hasOwnProperty,D=0,W={attributes:_,define:function(e,t){e.indexOf("-")<0?(e in j||(D=L.push(e)),j[e]=t):_[e]=t;},invoke:function(e,t){for(var n=0;n<D;n++){var r=L[n];if(P.call(e,r))return j[r](e[r],t)}}},$=Array.isArray||(A=(g={}.toString).call([]),function(e){return g.call(e)===A}),R=(S=N,O="fragment",M="content"in H(T="template")?function(e){var t=H(T);return t.innerHTML=e,t.content}:function(e){var t,n=H(O),r=H(T);return F(n,/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(e)?(t=RegExp.$1,r.innerHTML="<table>"+e+"</table>",r.querySelectorAll(t)):(r.innerHTML=e,r.childNodes)),n},function(e,t){return ("svg"===t?function(e){var t=H(O),n=H("div");return n.innerHTML='<svg xmlns="http://www.w3.org/2000/svg">'+e+"</svg>",F(t,n.firstChild.childNodes),t}:M)(e)});function F(e,t){for(var n=t.length;n--;)e.appendChild(t[0]);}function H(e){return e===O?S.createDocumentFragment():S.createElementNS("http://www.w3.org/1999/xhtml",e)}var I,z,V,Z,G,q,B,J,K,Q,U=(z="appendChild",V="cloneNode",Z="createTextNode",q=(G="importNode")in(I=N),(B=I.createDocumentFragment())[z](I[Z]("g")),B[z](I[Z]("")),(q?I[G](B,true):B[V](true)).childNodes.length<2?function e(t,n){for(var r=t[V](),i=t.childNodes||[],a=i.length,o=0;n&&o<a;o++)r[z](e(i[o],n));return r}:q?I[G]:function(e,t){return e[V](!!t)}),X="".trim||function(){return String(this).replace(/^\s+|\s+/g,"")},Y="-"+Math.random().toFixed(6)+"%",ee=false;try{J=N.createElement("template"),Q="tabindex",(K="content")in J&&(J.innerHTML="<p "+Q+'="'+Y+'"></p>',J[K].childNodes[0].getAttribute(Q)==Y)||(Y="_dt: "+Y.slice(1,-1)+";",ee=!0);}catch(e){}var te="\x3c!--"+Y+"--\x3e",ne=8,re=1,ie=3,ae=/^(?:style|textarea)$/i,oe=/^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;var ue=" \\f\\n\\r\\t",ce="[^"+ue+"\\/>\"'=]+",le="["+ue+"]+"+ce,se="<([A-Za-z]+[A-Za-z0-9:._-]*)((?:",fe="(?:\\s*=\\s*(?:'[^']*?'|\"[^\"]*?\"|<[^>]*?>|"+ce.replace("\\/","")+"))?)",he=new RegExp(se+le+fe+"+)(["+ue+"]*/?>)","g"),de=new RegExp(se+le+fe+"*)(["+ue+"]*/>)","g"),ve=new RegExp("("+le+"\\s*=\\s*)(['\"]?)"+te+"\\2","gi");function pe(e,t,n,r){return "<"+t+n.replace(ve,ge)+r}function ge(e,t,n){return t+(n||'"')+Y+(n||'"')}function me(e,t,n){return oe.test(t)?e:"<"+t+n+"></"+t+">"}var ye=ee?function(e,t){var n=t.join(" ");return t.slice.call(e,0).sort(function(e,t){return n.indexOf(e.name)<=n.indexOf(t.name)?-1:1})}:function(e,t){return t.slice.call(e,0)};function be(e,t,n,r){for(var i=e.childNodes,a=i.length,o=0;o<a;){var u=i[o];switch(u.nodeType){case re:var c=r.concat(o);!function(e,t,n,r){var i,a=e.attributes,o=[],u=[],c=ye(a,n),l=c.length,s=0;for(;s<l;){var f=c[s++],h=f.value===Y;if(h||1<(i=f.value.split(te)).length){var d=f.name;if(o.indexOf(d)<0){o.push(d);var v=n.shift().replace(h?/^(?:|[\S\s]*?\s)(\S+?)\s*=\s*('|")?$/:new RegExp("^(?:|[\\S\\s]*?\\s)("+d+")\\s*=\\s*('|\")[\\S\\s]*","i"),"$1"),p=a[v]||a[v.toLowerCase()];if(h)t.push(we(p,r,v,null));else {for(var g=i.length-2;g--;)n.shift();t.push(we(p,r,v,i));}}u.push(f);}}l=u.length;var m=(s=0)<l&&ee&&!("ownerSVGElement"in e);for(;s<l;){var y=u[s++];m&&(y.value=""),e.removeAttribute(y.name);}var b=e.nodeName;if(/^script$/i.test(b)){var w=N.createElement(b);for(l=a.length,s=0;s<l;)w.setAttributeNode(a[s++].cloneNode(true));w.textContent=e.textContent,e.parentNode.replaceChild(w,e);}}(u,t,n,c),be(u,t,n,c);break;case ne:var l=u.textContent;if(l===Y)n.shift(),t.push(ae.test(e.nodeName)?Ne(e,r):{type:"any",node:u,path:r.concat(o)});else switch(l.slice(0,2)){case "/*":if("*/"!==l.slice(-2))break;case "ð»":e.removeChild(u),o--,a--;}break;case ie:ae.test(e.nodeName)&&X.call(u.textContent)===te&&(n.shift(),t.push(Ne(e,r)));}o++;}}function we(e,t,n,r){return {type:"attr",node:e,path:t,name:n,sparse:r}}function Ne(e,t){return {type:"text",node:e,path:t}}var xe,Ee=(xe=new s,{get:function(e){return xe.get(e)},set:function(e,t){return xe.set(e,t),t}});function Ce(o,f){var e=(o.convert||function(e){return e.join(te).replace(de,me).replace(he,pe)})(f),t=o.transform;t&&(e=t(e));var n=R(e,o.type);Se(n);var u=[];return be(n,u,f.slice(0),[]),{content:n,updates:function(c){for(var l=[],s=u.length,e=0,t=0;e<s;){var n=u[e++],r=function(e,t){for(var n=t.length,r=0;r<n;)e=e.childNodes[t[r++]];return e}(c,n.path);switch(n.type){case "any":l.push({fn:o.any(r,[]),sparse:false});break;case "attr":var i=n.sparse,a=o.attribute(r,n.name,n.node);null===i?l.push({fn:a,sparse:false}):(t+=i.length-2,l.push({fn:a,sparse:true,values:i}));break;case "text":l.push({fn:o.text(r),sparse:false}),r.textContent="";}}return s+=t,function(){var e=arguments.length;if(s!==e-1)throw new Error(e-1+" values instead of "+s+"\n"+f.join("${value}"));for(var t=1,n=1;t<e;){var r=l[t-n];if(r.sparse){var i=r.values,a=i[0],o=1,u=i.length;for(n+=u-2;o<u;)a+=arguments[t++]+i[o++];r.fn(a);}else r.fn(arguments[t++]);}return c}}}}var ke=[];function Ae(i){var a=ke,o=Se;return function(e){var t,n,r;return a!==e&&(t=i,n=a=e,r=Ee.get(n)||Ee.set(n,Ce(t,n)),o=r.updates(U.call(N,r.content,true))),o.apply(null,arguments)}}function Se(e){for(var t=e.childNodes,n=t.length;n--;){var r=t[n];1!==r.nodeType&&0===X.call(r.textContent).length&&e.removeChild(r);}}var Oe,Te,Me=(Oe=/acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i,Te=/([^A-Z])([A-Z]+)/g,function(e,t){return "ownerSVGElement"in e?function(e,t){var n;return (n=t?t.cloneNode(true):(e.setAttribute("style","--hyper:style;"),e.getAttributeNode("style"))).value="",e.setAttributeNode(n),je(n,true)}(e,t):je(e.style,false)});function _e(e,t,n){return t+"-"+n.toLowerCase()}function je(a,o){var u,c;return function(e){var t,n,r,i;switch(typeof e){case "object":if(e){if("object"===u){if(!o&&c!==e)for(n in c)n in e||(a[n]="");}else o?a.value="":a.cssText="";for(n in t=o?{}:a,e)r="number"!=typeof(i=e[n])||Oe.test(n)?i:i+"px",!o&&/^--/.test(n)?t.setProperty(n,r):t[n]=r;u="object",o?a.value=function(e){var t,n=[];for(t in e)n.push(t.replace(Te,_e),":",e[t],";");return n.join("")}(c=t):c=e;break}default:c!=e&&(u="string",c=e,o?a.value=e||"":a.cssText=e||"");}}}var Le,Pe,De=(Le=[].slice,(Pe=We.prototype).ELEMENT_NODE=1,Pe.nodeType=111,Pe.remove=function(e){var t,n=this.childNodes,r=this.firstChild,i=this.lastChild;return this._=null,e&&2===n.length?i.parentNode.removeChild(i):((t=this.ownerDocument.createRange()).setStartBefore(e?n[1]:r),t.setEndAfter(i),t.deleteContents()),r},Pe.valueOf=function(e){var t=this._,n=null==t;if(n&&(t=this._=this.ownerDocument.createDocumentFragment()),n||e)for(var r=this.childNodes,i=0,a=r.length;i<a;i++)t.appendChild(r[i]);return t},We);function We(e){var t=this.childNodes=Le.call(e,0);this.firstChild=t[0],this.lastChild=t[t.length-1],this.ownerDocument=t[0].ownerDocument,this._=null;}function $e(e){return {html:e}}function Re(e,t){switch(e.nodeType){case Ke:return 1/t<0?t?e.remove(true):e.lastChild:t?e.valueOf(true):e.firstChild;case Je:return Re(e.render(),t);default:return e}}function Fe(e,t){t(e.placeholder),"text"in e?Promise.resolve(e.text).then(String).then(t):"any"in e?Promise.resolve(e.any).then(t):"html"in e?Promise.resolve(e.html).then($e).then(t):Promise.resolve(W.invoke(e,t)).then(t);}function He(e){return null!=e&&"then"in e}var Ie,ze,Ve,Ze,Ge,qe="ownerSVGElement",Be="connected",Je=d.prototype.nodeType,Ke=De.prototype.nodeType,Qe=(ze=(Ie={Event:u,WeakSet:e}).Event,Ve=Ie.WeakSet,Ze=true,Ge=null,function(e){return Ze&&(Ze=!Ze,Ge=new Ve,function(t){var i=new Ve,a=new Ve;try{new MutationObserver(u).observe(t,{subtree:!0,childList:!0});}catch(e){var n=0,r=[],o=function(e){r.push(e),clearTimeout(n),n=setTimeout(function(){u(r.splice(n=0,r.length));},0);};t.addEventListener("DOMNodeRemoved",function(e){o({addedNodes:[],removedNodes:[e.target]});},true),t.addEventListener("DOMNodeInserted",function(e){o({addedNodes:[e.target],removedNodes:[]});},true);}function u(e){for(var t,n=e.length,r=0;r<n;r++)c((t=e[r]).removedNodes,"disconnected",a,i),c(t.addedNodes,"connected",i,a);}function c(e,t,n,r){for(var i,a=new ze(t),o=e.length,u=0;u<o;1===(i=e[u++]).nodeType&&function e(t,n,r,i,a){Ge.has(t)&&!i.has(t)&&(a.delete(t),i.add(t),t.dispatchEvent(n));for(var o=t.children||[],u=o.length,c=0;c<u;e(o[c++],n,r,i,a));}(i,a,t,n,r));}}(e.ownerDocument)),Ge.add(e),e}),Ue=/^(?:form|list)$/i,Xe=[].slice;function Ye(e){return this.type=e,Ae(this)}var et=!(Ye.prototype={attribute:function(n,r,e){var i,t=qe in n;if("style"===r)return Me(n,e,t);if("."===r.slice(0,1))return l=n,s=r.slice(1),t?function(t){try{l[s]=t;}catch(e){l.setAttribute(s,t);}}:function(e){l[s]=e;};if("?"===r.slice(0,1))return o=n,u=r.slice(1),function(e){c!==!!e&&((c=!!e)?o.setAttribute(u,""):o.removeAttribute(u));};if(/^on/.test(r)){var a=r.slice(2);return a===Be||"disconnected"===a?Qe(n):r.toLowerCase()in n&&(a=a.toLowerCase()),function(e){i!==e&&(i&&n.removeEventListener(a,i,false),(i=e)&&n.addEventListener(a,e,false));}}if("data"===r||!t&&r in n&&!Ue.test(r))return function(e){i!==e&&(i=e,n[r]!==e&&null==e?(n[r]="",n.removeAttribute(r)):n[r]=e);};if(r in W.attributes)return function(e){var t=W.attributes[r](n,e);i!==t&&(null==(i=t)?n.removeAttribute(r):n.setAttribute(r,t));};var o,u,c,l,s,f=false,h=e.cloneNode(true);return function(e){i!==e&&(i=e,h.value!==e&&(null==e?(f&&(f=false,n.removeAttributeNode(h)),h.value=e):(h.value=e,f||(f=true,n.setAttributeNode(h)))));}},any:function(r,i){var a,o={node:Re,before:r},u=qe in r?"svg":"html",c=false;return function e(t){switch(typeof t){case "string":case "number":case "boolean":c?a!==t&&(a=t,i[0].textContent=t):(c=true,a=t,i=l(r.parentNode,i,[(n=t,r.ownerDocument.createTextNode(n))],o));break;case "function":e(t(r));break;case "object":case "undefined":if(null==t){c=false,i=l(r.parentNode,i,[],o);break}default:if(c=false,$(a=t))if(0===t.length)i.length&&(i=l(r.parentNode,i,[],o));else switch(typeof t[0]){case "string":case "number":case "boolean":e({html:t});break;case "object":if($(t[0])&&(t=t.concat.apply([],t)),He(t[0])){Promise.all(t).then(e);break}default:i=l(r.parentNode,i,t,o);}else "ELEMENT_NODE"in t?i=l(r.parentNode,i,11===t.nodeType?Xe.call(t.childNodes):[t],o):He(t)?t.then(e):"placeholder"in t?Fe(t,e):"text"in t?e(String(t.text)):"any"in t?e(t.any):"html"in t?i=l(r.parentNode,i,Xe.call(R([].concat(t.html).join(""),u).childNodes),o):"length"in t?e(Xe.call(t)):e(W.invoke(t,e));}var n;}},text:function(r){var i;return function e(t){var n;i!==t&&("object"==(n=typeof(i=t))&&t?He(t)?t.then(e):"placeholder"in t?Fe(t,e):"text"in t?e(String(t.text)):"any"in t?e(t.any):"html"in t?e([].concat(t.html).join("")):"length"in t?e(Xe.call(t).join("")):e(W.invoke(t,e)):"function"==n?e(t(r)):r.textContent=null==t?"":t);}}}),tt=function(e){var t,r,i,a,n=(t=(N.defaultView.navigator||{}).userAgent,/(Firefox|Safari)\/(\d+)/.test(t)&&!/(Chrom[eium]+|Android)\/(\d+)/.test(t)),o=!("raw"in e)||e.propertyIsEnumerable("raw")||!Object.isFrozen(e.raw);return n||o?(r={},i=function(e){for(var t=".",n=0;n<e.length;n++)t+=e[n].length+"."+e[n];return r[t]||(r[t]=e)},tt=o?i:(a=new s,function(e){return a.get(e)||(n=i(t=e),a.set(t,n),n);var t,n;})):et=true,nt(e)};function nt(e){return et?e:tt(e)}function rt(e){for(var t=arguments.length,n=[nt(e)],r=1;r<t;)n.push(arguments[r++]);return n}var it=new s,at=function(t){var n,r,i;return function(){var e=rt.apply(null,arguments);return i!==e[0]?(i=e[0],r=new Ye(t),n=ut(r.apply(r,e))):r.apply(r,e),n}},ot=function(e,t){var n=t.indexOf(":"),r=it.get(e),i=t;return  -1<n&&(i=t.slice(n+1),t=t.slice(0,n)||"html"),r||it.set(e,r={}),r[i]||(r[i]=at(t))},ut=function(e){var t=e.childNodes,n=t.length;return 1===n?t[0]:n?new De(t):e},ct=new s;function lt(){var e=ct.get(this),t=rt.apply(null,arguments);return e&&e.template===t[0]?e.tagger.apply(null,t):function(e){var t=new Ye(qe in this?"svg":"html");ct.set(this,{tagger:t,template:e}),this.textContent="",this.appendChild(t.apply(null,arguments));}.apply(this,t),this}var st,ft,ht,dt,vt=W.define,pt=Ye.prototype;function gt(e){return arguments.length<2?null==e?at("html"):"string"==typeof e?gt.wire(null,e):"raw"in e?at("html")(e):"nodeType"in e?gt.bind(e):ot(e,"html"):("raw"in e?at("html"):gt.wire).apply(null,arguments)}return gt.Component=d,gt.bind=function(e){return lt.bind(e)},gt.define=vt,gt.diff=l,(gt.hyper=gt).observe=Qe,gt.tagger=pt,gt.wire=function(e,t){return null==e?at(t||"html"):ot(e,t||"html")},gt._={WeakMap:s,WeakSet:e},st=at,ft=new s,ht=Object.create,dt=function(e,t){var n={w:null,p:null};return t.set(e,n),n},Object.defineProperties(d,{for:{configurable:true,value:function(e,t){return function(e,t,n,r){var i,a,o,u=t.get(e)||dt(e,t);switch(typeof r){case "object":case "function":var c=u.w||(u.w=new s);return c.get(r)||(i=c,a=r,o=new e(n),i.set(a,o),o);default:var l=u.p||(u.p=ht(null));return l[r]||(l[r]=new e(n))}}(this,ft.get(e)||(n=e,r=new h,ft.set(n,r),r),e,null==t?"default":t);var n,r;}}}),Object.defineProperties(d.prototype,{handleEvent:{value:function(e){var t=e.currentTarget;this["getAttribute"in t&&t.getAttribute("data-call")||"on"+e.type](e);}},html:v("html",st),svg:v("svg",st),state:v("state",function(){return this.defaultState}),defaultState:{get:function(){return {}}},dispatch:{value:function(e,t){var n=this._wire$;if(n){var r=new u(e,{bubbles:true,cancelable:true,detail:t});return r.component=this,(n.dispatchEvent?n:n.firstChild).dispatchEvent(r)}return  false}},setState:{value:function(e,t){var n=this.state,r="function"==typeof e?e.call(this,n):e;for(var i in r)n[i]=r[i];return  false!==t&&this.render(),this}}}),gt}(document);
  const {Component, bind, define: define$1, diff, hyper, wire} = hyperHTML$1;

  // @ts-check
  // Temporary workaround until browsers get real import-maps


  const html = hyperHTML$1;
  const idb = _idb;
  const marked = marked$1;
  const MIMEType = MIMEType$1;
  const pluralize = pluralize$3;

  // @ts-check
  // Module core/utils
  // As the name implies, this contains a ragtag gang of methods that just don't fit
  // anywhere else.

  const dashes = /-/g;

  // https://stackoverflow.com/a/58633686
  const ISODate = new Intl.DateTimeFormat(["sv-SE"], {
    timeZone: "UTC",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  });

  // We use an "Australian Date" because it omits the ","
  // after the day of the month, which is required by the W3C.
  lang$1 === "en" || lang$1.startsWith("en-") ? "en-AU" : lang$1;

  /** CSS selector for matching elements that are non-normative */
  const nonNormativeSelector =
    ".informative, .note, .issue, .example, .ednote, .practice, .introductory";

  /**
   * Creates a link element that represents a resource hint.
   *
   * @param {ResourceHintOption} opts Configure the resource hint.
   * @return {HTMLLinkElement} A link element ready to use.
   */
  function createResourceHint(opts) {
    const url = new URL(opts.href, document.baseURI);
    const linkElem = document.createElement("link");
    let { href } = url;
    linkElem.rel = opts.hint;
    switch (linkElem.rel) {
      case "dns-prefetch":
      case "preconnect":
        href = url.origin;
        if (opts.corsMode || url.origin !== document.location.origin) {
          linkElem.crossOrigin = opts.corsMode || "anonymous";
        }
        break;
      case "preload":
        if ("as" in opts) {
          linkElem.setAttribute("as", opts.as);
        }
        if (opts.corsMode) {
          linkElem.crossOrigin = opts.corsMode;
        }
        break;
    }
    linkElem.href = href;
    if (!opts.dontRemove) {
      linkElem.classList.add("removeOnSave");
    }
    return linkElem;
  }

  // RESPEC STUFF
  /**
   * @param {Document} doc
   */
  function removeReSpec(doc) {
    doc.querySelectorAll(".remove, script[data-requiremodule]").forEach(elem => {
      elem.remove();
    });
  }

  /**
   * Adds error class to each element while emitting a warning
   * @param {HTMLElement} elem
   * @param {String} msg message to show in warning
   * @param {String=} title error message to add on each element
   */
  function markAsOffending(elem, msg, title) {
    elem.classList.add("respec-offending-element");
    if (!elem.hasAttribute("title")) {
      elem.setAttribute("title", title || msg);
    }
    if (!elem.id) {
      addId(elem, "respec-offender");
    }
  }

  // STRING HELPERS
  /**
   * @param {"conjunction"|"disjunction"} type
   * @param {"long"|"narrow"} style
   */
  function joinFactory(type, style = "long") {
    const formatter = new Intl.ListFormat(lang$1, { style, type });
    /**
     * @template T
     * @param {string[]} items
     * @param {(value: string, index: number, array: string[]) => any} [mapper]
     */
    return (items, mapper) => {
      let elemCount = 0;
      return formatter.formatToParts(items).map(({ type, value }) => {
        if (type === "element" && mapper) {
          return mapper(value, elemCount++, items);
        }
        return value;
      });
    };
  }

  /**
   * Takes an array and returns a string that separates each of its items with the
   * proper commas and "and". The second argument is a mapping function that can
   * convert the items before they are joined.
   */
  const conjunction = joinFactory("conjunction");
  const disjunction = joinFactory("disjunction");

  /**
   *
   * @param {string[]} items
   * @param {(value: undefined, index: number, array: undefined[]) => string} [mapper]
   */
  function joinAnd(items, mapper) {
    return conjunction(items, mapper).join("");
  }

  /**
   *
   * @param {string[]} items
   * @param {(value: undefined, index: number, array: undefined[]) => string} [mapper]
   */
  function joinOr(items, mapper) {
    return disjunction(items, mapper).join("");
  }

  /**
   * Takes a string, applies some XML escapes, and returns the escaped string.
   * @param {string} str
   */
  function xmlEscape(str) {
    return str
      .replace(/&/g, "&amp;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/</g, "&lt;");
  }

  /**
   * Trims string at both ends and replaces all other white space with a single
   * space.
   * @param {string} str
   */
  function norm(str) {
    return str.trim().replace(/\s+/g, " ");
  }

  /**
   * @template {Record<string, Record<string, string|Function>>} T
   * @param {T} localizationStrings
   * @returns {T[keyof T]}
   */
  function getIntlData(localizationStrings, lang = lang$1) {
    lang = lang.toLowerCase();
    // Proxy return type is a known bug:
    // https://github.com/Microsoft/TypeScript/issues/20846
    // @ts-expect-error
    return new Proxy(localizationStrings, {
      /** @param {string} key */
      get(data, key) {
        const result = getIntlDataForKey(data, key, lang) || data.en[key];
        if (!result) {
          throw new Error(`No l10n data for key: "${key}"`);
        }
        return result;
      },
    });
  }

  /**
   * @template {Record<string, Record<string, string|Function>>} T
   * @param {T} localizationStrings
   * @param {string} key
   */
  function getIntlDataForKey(localizationStrings, key, lang = lang$1) {
    lang = lang.toLowerCase();
    return (
      localizationStrings[lang]?.[key] ||
      localizationStrings[lang.match(/^(\w{2,3})-.+$/)?.[1]]?.[key]
    );
  }

  // --- DATE HELPERS -------------------------------------------------------------------------------
  /**
   * Takes a Date object and an optional separator and returns the year,month,day
   * representation with the custom separator (defaulting to none) and proper
   * 0-padding.
   * @param {Date} date
   */
  function concatDate(date, sep = "") {
    return ISODate.format(date).replace(dashes, sep);
  }

  /**
   * Given an object, it converts it to a key value pair separated by ("=", configurable) and a delimiter (" ," configurable).
   * @example {"foo": "bar", "baz": 1} becomes "foo=bar, baz=1"
   * @param {Record<string, any>} obj
   */
  function toKeyValuePairs(obj, delimiter = ", ", separator = "=") {
    return Array.from(Object.entries(obj))
      .map(([key, value]) => `${key}${separator}${JSON.stringify(value)}`)
      .join(delimiter);
  }

  // STYLE HELPERS
  /**
   * Take a document and either a link or an array of links to CSS and appends a
   * `<link rel="stylesheet">` element to the head pointing to each.
   * @param {Document} doc
   * @param {string | string[]} urls
   */
  function linkCSS(doc, urls) {
    const stylesArray = [].concat(urls);
    const frag = stylesArray
      .map(url => {
        const link = doc.createElement("link");
        link.rel = "stylesheet";
        link.href = url;
        return link;
      })
      .reduce((elem, nextLink) => {
        elem.appendChild(nextLink);
        return elem;
      }, doc.createDocumentFragment());
    doc.head.appendChild(frag);
  }

  // TRANSFORMATIONS

  /**
   * Run list of transforms over content and return result.
   *
   * Please note that this is a legacy method that is only kept in order to
   * maintain compatibility with RSv1. It is therefore not tested and not actively
   * supported.
   * @this {any}
   * @param {string} content
   * @param {string} [flist] List of global function names.
   * @param {unknown[]} [funcArgs] Arguments to pass to each function.
   */
  function runTransforms(content, flist, ...funcArgs) {
    const args = [this, content, ...funcArgs];
    if (flist) {
      const methods = flist.split(/\s+/);
      for (const meth of methods) {
        /** @type {any} */
        const method = window[meth];
        if (method) {
          // the initial call passed |this| directly, so we keep it that way
          try {
            content = method.apply(this, args);
          } catch (e) {
            const msg = `call to \`${meth}()\` failed with: ${e}.`;
            const hint = "See developer console for stack trace.";
            showWarning(msg, "utils/runTransforms", { hint, cause: e });
          }
        }
      }
    }
    return content;
  }

  /**
   * Cached request handler
   * @param {RequestInfo} input
   * @param {number} maxAge cache expiration duration in ms. defaults to 24 hours
   * @return {Promise<Response>}
   *  if a cached response is available and it's not stale, return it
   *  else: request from network, cache and return fresh response.
   *    If network fails, return a stale cached version if exists (else throw)
   */
  async function fetchAndCache(input, maxAge = 24 * 60 * 60 * 1000) {
    const request = new Request(input);
    const url = new URL(request.url);

    // use data from cache data if valid and render
    let cache;
    let cachedResponse;
    if ("caches" in window) {
      try {
        cache = await caches.open(url.origin);
        cachedResponse = await cache.match(request);
        if (
          cachedResponse &&
          new Date(cachedResponse.headers.get("Expires")) > new Date()
        ) {
          return cachedResponse;
        }
      } catch (err) {
        console.error("Failed to use Cache API.", err);
      }
    }

    // otherwise fetch new data and cache
    const response = await fetch(request);
    if (!response.ok) {
      if (cachedResponse) {
        // return stale version
        console.warn(`Returning a stale cached response for ${url}`);
        return cachedResponse;
      }
    }

    // cache response
    if (cache && response.ok) {
      const clonedResponse = response.clone();
      const customHeaders = new Headers(response.headers);
      const expiryDate = new Date(Date.now() + maxAge);
      customHeaders.set("Expires", expiryDate.toISOString());
      const cacheResponse = new Response(await clonedResponse.blob(), {
        headers: customHeaders,
      });
      // put in cache, and forget it (there is no recovery if it throws, but that's ok).
      await cache.put(request, cacheResponse).catch(console.error);
    }
    return response;
  }

  // --- DOM HELPERS -------------------------------

  /**
   * Separates each item with proper commas.
   * @template T
   * @param {T[]} array
   * @param {(item: T) => any} [mapper]
   */
  function htmlJoinComma(array, mapper = item => item) {
    const items = array.map(mapper);
    const joined = items.slice(0, -1).map(item => html`${item}, `);
    return html`${joined}${items[items.length - 1]}`;
  }

  /**
   * Creates and sets an ID to an element (elem) using a specific prefix if
   * provided, and a specific text if given.
   * @param {HTMLElement} elem element
   * @param {String} pfx prefix
   * @param {String} txt text
   * @param {Boolean} noLC do not convert to lowercase
   * @returns {String} generated (or existing) id for element
   */
  function addId(elem, pfx = "", txt = "", noLC = false) {
    if (elem.id) {
      return elem.id;
    }
    if (!txt) {
      txt = (elem.title ? elem.title : elem.textContent).trim();
    }
    let id = noLC ? txt : txt.toLowerCase();
    id = id
      .trim()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/\W+/gim, "-")
      .replace(/^-+/, "")
      .replace(/-+$/, "");

    if (!id) {
      id = "generatedID";
    } else if (/\.$/.test(id) || !/^[a-z]/i.test(pfx || id)) {
      id = `x${id}`; // trailing . doesn't play well with jQuery
    }
    if (pfx) {
      id = `${pfx}-${id}`;
    }
    if (elem.ownerDocument.getElementById(id)) {
      let i = 0;
      let nextId = `${id}-${i}`;
      while (elem.ownerDocument.getElementById(nextId)) {
        i += 1;
        nextId = `${id}-${i}`;
      }
      id = nextId;
    }
    elem.id = id;
    return id;
  }

  /**
   * Returns all the descendant text nodes of an element.
   * @param {Node} el
   * @param {string[]} exclusions node localName to exclude
   * @param {object} options
   * @param {boolean} options.wsNodes return only whitespace-only nodes.
   * @returns {Text[]}
   */
  function getTextNodes(el, exclusions = [], options = { wsNodes: true }) {
    const exclusionQuery = exclusions.join(", ");
    const acceptNode = (/** @type {Text} */ node) => {
      if (!options.wsNodes && !node.data.trim()) {
        return NodeFilter.FILTER_REJECT;
      }
      if (exclusionQuery && node.parentElement.closest(exclusionQuery)) {
        return NodeFilter.FILTER_REJECT;
      }
      return NodeFilter.FILTER_ACCEPT;
    };
    const nodeIterator = document.createNodeIterator(
      el,
      NodeFilter.SHOW_TEXT,
      acceptNode
    );
    /** @type {Text[]} */
    const textNodes = [];
    let node;
    while ((node = nodeIterator.nextNode())) {
      textNodes.push(/** @type {Text} */ (node));
    }
    return textNodes;
  }

  /**
   * For any element, returns an array of title strings that applies the algorithm
   * used for determining the actual title of a `<dfn>` element (but can apply to
   * other as well).
   *
   * This method now *prefers* the `data-lt` attribute for the list of titles.
   * That attribute is added by this method to `<dfn>` elements, so subsequent
   * calls to this method will return the `data-lt` based list.
   * @param {HTMLElement} elem
   * @returns {String[]} array of title strings
   */
  function getDfnTitles(elem) {
    const titleSet = new Set();
    // data-lt-noDefault avoid using the text content of a definition
    // in the definition list.
    // ltNodefault is === "data-lt-noDefault"... someone screwed up ð
    const normText = "ltNodefault" in elem.dataset ? "" : norm(elem.textContent);
    const child = /** @type {HTMLElement | undefined} */ (elem.children[0]);
    if (elem.dataset.lt) {
      // prefer @data-lt for the list of title aliases
      elem.dataset.lt
        .split("|")
        .map(item => norm(item))
        .forEach(item => titleSet.add(item));
    } else if (
      elem.childNodes.length === 1 &&
      elem.getElementsByTagName("abbr").length === 1 &&
      child.title
    ) {
      titleSet.add(child.title);
    } else if (elem.textContent === '""') {
      titleSet.add("the-empty-string");
    }

    titleSet.add(normText);
    titleSet.delete("");

    // We could have done this with @data-lt (as the logic is same), but if
    // @data-lt was not present, we would end up using @data-local-lt as element's
    // id (in other words, we prefer textContent over @data-local-lt for dfn id)
    if (elem.dataset.localLt) {
      const localLt = elem.dataset.localLt.split("|");
      localLt.forEach(item => titleSet.add(norm(item)));
    }

    const titles = [...titleSet];
    return titles;
  }

  /**
   * Changes name of a DOM Element
   * @param {Element} elem element to rename
   * @param {String} newName new element name
   * @param {Object} options
   * @param {boolean} options.copyAttributes
   *
   * @returns {Element} new renamed element
   */
  function renameElement(
    elem,
    newName,
    options = { copyAttributes: true }
  ) {
    if (elem.localName === newName) return elem;
    const newElement = elem.ownerDocument.createElement(newName);
    // copy attributes
    if (options.copyAttributes) {
      for (const { name, value } of elem.attributes) {
        newElement.setAttribute(name, value);
      }
    }
    // copy child nodes
    newElement.append(...elem.childNodes);
    elem.replaceWith(newElement);
    return newElement;
  }

  /**
   * @param {string} ref
   * @param {HTMLElement} element
   */
  function refTypeFromContext(ref, element) {
    const closestInformative = element.closest(nonNormativeSelector);
    let isInformative = false;
    if (closestInformative) {
      // check if parent is not normative
      isInformative =
        !element.closest(".normative") ||
        !closestInformative.querySelector(".normative");
    }
    // prefixes `!` and `?` override section behavior
    if (ref.startsWith("!")) {
      if (isInformative) {
        // A (forced) normative reference in informative section is illegal
        return { type: "informative", illegal: true };
      }
      isInformative = false;
    } else if (ref.startsWith("?")) {
      isInformative = true;
    }
    const type = isInformative ? "informative" : "normative";
    return { type, illegal: false };
  }

  /**
   * Wraps inner contents with the wrapper node
   * @param {Node} outer outer node to be modified
   * @param {Element} wrapper wrapper node to be appended
   */
  function wrapInner(outer, wrapper) {
    wrapper.append(...outer.childNodes);
    outer.appendChild(wrapper);
    return outer;
  }

  /**
   * @param {Element} element
   */
  function getPreviousSections(element) {
    /** @type {Element[]} */
    const sections = [];
    for (const previous of iteratePreviousElements(element)) {
      if (previous.localName === "section") {
        sections.push(previous);
      }
    }
    return sections;
  }

  /**
   * @param {Element} element
   */
  function* iteratePreviousElements(element) {
    let previous = element;
    while (previous.previousElementSibling) {
      previous = previous.previousElementSibling;
      yield previous;
    }
  }
  /**
   * Applies the selector for all its ancestors.
   * @param {Element} element
   * @param {string} selector
   */
  function parents(element, selector) {
    /** @type {Element[]} */
    const list = [];
    let parent = element.parentElement;
    while (parent) {
      const closest = parent.closest(selector);
      if (!closest) {
        break;
      }
      list.push(closest);
      parent = closest.parentElement;
    }
    return list;
  }

  /**
   * Calculates indentation when the element starts after a newline. The value
   * will be empty if no newline or any non-whitespace exists after one.
   * @param {Element} element
   *
   * @example `    <div></div>` returns "    " (4 spaces).
   */
  function getElementIndentation(element) {
    const { previousSibling } = element;
    if (!previousSibling || previousSibling.nodeType !== Node.TEXT_NODE) {
      return "";
    }
    const index = previousSibling.textContent.lastIndexOf("\n");
    if (index === -1) {
      return "";
    }
    const slice = previousSibling.textContent.slice(index + 1);
    if (/\S/.test(slice)) {
      return "";
    }
    return slice;
  }

  /** @extends {Set<string>} */
  class InsensitiveStringSet extends Set {
    /**
     * @param {Array<String>} [keys] Optional, initial keys
     */
    constructor(keys = []) {
      super();
      for (const key of keys) {
        this.add(key);
      }
    }
    /**
     * @param {string} key
     */
    add(key) {
      if (!this.has(key) && !this.getCanonicalKey(key)) {
        return super.add(key);
      }
      return this;
    }
    /**
     * @param {string} key
     */
    has(key) {
      return (
        super.has(key) ||
        [...this.keys()].some(
          existingKey => existingKey.toLowerCase() === key.toLowerCase()
        )
      );
    }
    /**
     * @param {string} key
     */
    delete(key) {
      return super.has(key)
        ? super.delete(key)
        : super.delete(this.getCanonicalKey(key));
    }
    /**
     * @param {string} key
     */
    getCanonicalKey(key) {
      return super.has(key)
        ? key
        : [...this.keys()].find(
            existingKey => existingKey.toLowerCase() === key.toLowerCase()
          );
    }
  }

  /**
   * @param {HTMLElement} node
   */
  function makeSafeCopy(node) {
    const clone = node.cloneNode(true);
    clone.querySelectorAll("[id]").forEach(elem => elem.removeAttribute("id"));
    clone.querySelectorAll("dfn").forEach(dfn => {
      renameElement(dfn, "span", { copyAttributes: false });
    });
    if (clone.hasAttribute("id")) clone.removeAttribute("id");
    removeCommentNodes(clone);
    return clone;
  }

  /**
   * @param {Node} node
   */
  function removeCommentNodes(node) {
    const walker = document.createTreeWalker(node, NodeFilter.SHOW_COMMENT);
    for (const comment of [...walkTree(walker)]) {
      comment.remove();
    }
  }

  /**
   * @template {Node} T
   * @param {TreeWalker<T>} walker
   * @return {IterableIterator<T>}
   */
  function* walkTree(walker) {
    while (walker.nextNode()) {
      yield /** @type {T} */ (walker.currentNode);
    }
  }

  /**
   * @template ValueType
   * @extends {Map<string, ValueType>}
   */
  class CaseInsensitiveMap extends Map {
    /**
     * @param {Array<[string, ValueType]>} [entries]
     */
    constructor(entries = []) {
      super();
      entries.forEach(([key, elem]) => {
        this.set(key, elem);
      });
      return this;
    }
    /**
     * @param {String} key
     * @param {ValueType} value
     */
    set(key, value) {
      super.set(key.toLowerCase(), value);
      return this;
    }
    /**
     * @param {String} key
     */
    get(key) {
      return super.get(key.toLowerCase());
    }
    /**
     * @param {String} key
     */
    has(key) {
      return super.has(key.toLowerCase());
    }
    /**
     * @param {String} key
     */
    delete(key) {
      return super.delete(key.toLowerCase());
    }
  }

  class RespecError extends Error {
    /**
     * @param {Parameters<typeof showError>[0]} message
     * @param {Parameters<typeof showError>[1]} plugin
     * @param {Parameters<typeof showError>[2] & { isWarning: boolean }} options
     */
    constructor(message, plugin, options) {
      super(message, { ...(options.cause && { cause: options.cause }) });
      const name = options.isWarning ? "ReSpecWarning" : "ReSpecError";
      Object.assign(this, { message, plugin, name, ...options });
      if (options.elements) {
        options.elements.forEach(elem =>
          markAsOffending(elem, message, options.title)
        );
      }
    }

    toJSON() {
      const { message, name, stack } = this;
      // @ts-expect-error https://github.com/microsoft/TypeScript/issues/26792
      const { plugin, hint, elements, title, details } = this;
      return {
        message,
        name,
        plugin,
        hint,
        elements,
        title,
        details,
        stack,
        ...(this.cause instanceof Error && {
          cause: {
            name: this.cause.name,
            message: this.cause.message,
            stack: this.cause.stack,
          },
        }),
      };
    }
  }

  /**
   * @param {string} message
   * @param {string} pluginName Name of plugin that caused the error.
   * @param {object} [options]
   * @param {string} [options.hint] How to solve the error?
   * @param {HTMLElement[]} [options.elements] Offending elements.
   * @param {string} [options.title] Title attribute for offending elements. Can be a shorter form of the message.
   * @param {string} [options.details] Any further details/context.
   * @param {Error} [options.cause] The error that caused this one.
   */
  function showError(message, pluginName, options = {}) {
    const opts = { ...options, isWarning: false };
    pub("error", new RespecError(message, pluginName, opts));
  }

  /**
   * @param {string} message
   * @param {string} pluginName Name of plugin that caused the error.
   * @param {object} [options]
   * @param {string} [options.hint] How to solve the error?
   * @param {HTMLElement[]} [options.elements] Offending elements.
   * @param {string} [options.title] Title attribute for offending elements. Can be a shorter form of the message.
   * @param {string} [options.details] Any further details/context.
   * @param {Error} [options.cause] The error that caused this one.
   */
  function showWarning(message, pluginName, options = {}) {
    const opts = { ...options, isWarning: true };
    pub("warn", new RespecError(message, pluginName, opts));
  }

  /**
   * Creates showError, showWarning utilities for use in custom pre-process and
   * post-process plugins.
   * @param {string} pluginName
   */
  function makePluginUtils(pluginName) {
    /** @typedef {Parameters<typeof showError>[2]} Options */
    return {
      /** @type {(message: string, options?: Options) => void} */
      showError: (msg, options) => showError(msg, pluginName, options),
      /** @type {(message: string, options?: Options) => void} */
      showWarning: (msg, options) => showWarning(msg, pluginName, options),
    };
  }

  /**
   * Makes a string `coded`.
   *
   * @param {string} item
   * @returns {string}
   */
  function toMDCode(item) {
    return item ? `\`${item}\`` : "";
  }

  /**
   * Joins an array of strings, wrapping each string in back-ticks (`) for inline markdown code.
   *
   * @param {string[]} array
   * @param {object} options
   * @param {boolean} options.quotes Surround each item in quotes
   */
  function codedJoinOr(array, { quotes } = { quotes: false }) {
    return joinOr(array, quotes ? s => toMDCode(addQuotes(s)) : toMDCode);
  }

  /**
   * Wraps in back-ticks ` for code.
   *
   * @param {string[]} array
   * @param {object} options
   * @param {boolean} options.quotes Surround each item in quotes
   */
  function codedJoinAnd(array, { quotes } = { quotes: false }) {
    return joinAnd(array, quotes ? s => toMDCode(addQuotes(s)) : toMDCode);
  }

  function addQuotes(item) {
    return String(item) ? `"${item}"` : "";
  }

  /**
   * Tagged template string, helps with linking to documentation.
   * Things inside [squareBrackets] are considered direct links to the documentation.
   * To alias something, one can use a "|", like [respecConfig|#respec-configuration].
   * @param {TemplateStringsArray} strings
   * @param {string[]} keys
   */
  function docLink(strings, ...keys) {
    const linkifiedStr = strings
      .map((s, i) => {
        const key = keys[i];
        if (!key) {
          return s;
        }
        // Linkables are wrapped in square brackets
        if (!key.startsWith("[") && !key.endsWith("]")) {
          return s + key;
        }

        const [linkingText, href] = key.slice(1, -1).split("|");
        if (href) {
          const url = new URL(href, "https://respec.org/docs/");
          return `${s}[${linkingText}](${url})`;
        }
        return `${s}[\`${linkingText}\`](https://respec.org/docs/#${linkingText})`;
      })
      .join("");
    return reindent(linkifiedStr);
  }

  /**
   * Takes a text string, trims it, splits it into lines,
   * finds the common indentation level, and then de-indents every line
   * by that common indentation level.
   *
   * @param {string} text - The text to be re-indented.
   * @returns {string} The re-indented text.
   */
  function reindent(text) {
    if (!text) {
      return text;
    }
    const lines = text.trimEnd().split("\n");
    while (lines.length && !lines[0].trim()) {
      lines.shift();
    }
    const indents = lines.filter(s => s.trim()).map(s => s.search(/[^\s]/));
    const leastIndent = Math.min(...indents);
    return lines.map(s => s.slice(leastIndent)).join("\n");
  }

  // @ts-check
  /**
   * Module core/pubsubhub
   *
   * Returns a singleton that can be used for message broadcasting
   * and message receiving. Replaces legacy "msg" code in ReSpec.
   */
  const name$E = "core/pubsubhub";

  const subscriptions = new EventTarget();

  /**
   *
   * @param {EventTopic} topic
   * @param  {any} detail
   */
  function pub(topic, detail) {
    subscriptions.dispatchEvent(new CustomEvent(topic, { detail }));
    if (window.parent === window.self) {
      return;
    }
    // If this is an iframe, postMessage parent (used in testing).
    const args = String(JSON.stringify(detail?.stack || detail));
    window.parent.postMessage({ topic, args }, window.parent.location.origin);
  }

  /**
   * Subscribes to a message type.
   * @param  {EventTopic} topic The topic to subscribe to
   * @param  {Function} cb         Callback function
   * @param  {Object} [options]
   * @param  {Boolean} [options.once] Add prop "once" for single notification.
   * @return {Object}              An object that should be considered opaque,
   *                               used for unsubscribing from messages.
   */
  function sub(topic, cb, options = { once: false }) {
    /** @param {CustomEvent} ev */
    const listener = async ev => {
      try {
        await cb(ev.detail);
      } catch (error) {
        const msg = `Error in handler for topic "${topic}": ${error.message}`;
        showError(msg, `sub:${topic}`, { cause: error });
      }
    };
    subscriptions.addEventListener(topic, listener, options);
  }

  expose(name$E, { sub });

  // @ts-check
  // Module core/include-config
  // Inject's the document's configuration into the head as JSON.

  const removeList = ["githubToken", "githubUser"];

  function run$F(config) {
    const userConfig = {};
    const amendConfig = newValues => Object.assign(userConfig, newValues);

    amendConfig(config);
    sub("amend-user-config", amendConfig);

    sub("end-all", () => {
      const script = document.createElement("script");
      script.id = "initialUserConfig";
      script.type = "application/json";
      for (const prop of removeList) {
        if (prop in userConfig) delete userConfig[prop];
      }
      script.innerHTML = JSON.stringify(userConfig, null, 2);
      document.head.appendChild(script);
    });
  }

  // @ts-check
  /**
   * module: core/exporter
   * Exports a ReSpec document, based on mime type, so it can be saved, etc.
   * Also performs cleanup, removing things that shouldn't be in published documents.
   * That is, elements that have a "removeOnSave" css class.
   */


  const mimeTypes = new Map([
    ["text/html", "html"],
    ["application/xml", "xml"],
  ]);

  /**
   * Creates a dataURI from a ReSpec document. It also cleans up the document
   * removing various things.
   *
   * @param {String} mimeType mimetype. one of `mimeTypes` above
   * @param {Document} doc document to export. useful for testing purposes
   * @returns a stringified data-uri of document that can be saved.
   */
  function rsDocToDataURL(mimeType, doc = document) {
    const format = mimeTypes.get(mimeType);
    if (!format) {
      const validTypes = [...mimeTypes.values()].join(", ");
      const msg = `Invalid format: ${mimeType}. Expected one of: ${validTypes}.`;
      throw new TypeError(msg);
    }
    const data = serialize(format, doc);
    const encodedString = encodeURIComponent(data);
    return `data:${mimeType};charset=utf-8,${encodedString}`;
  }

  function serialize(format, doc) {
    const cloneDoc = doc.cloneNode(true);
    cleanup$1(cloneDoc);
    let result = "";
    switch (format) {
      case "xml":
        result = new XMLSerializer().serializeToString(cloneDoc);
        break;
      default: {
        prettify(cloneDoc);
        if (cloneDoc.doctype) {
          result += new XMLSerializer().serializeToString(cloneDoc.doctype);
        }
        result += cloneDoc.documentElement.outerHTML;
      }
    }
    return result;
  }

  function cleanup$1(cloneDoc) {
    const { head, body, documentElement } = cloneDoc;
    removeCommentNodes(cloneDoc);

    cloneDoc
      .querySelectorAll(".removeOnSave, #toc-nav")
      .forEach(elem => elem.remove());
    body.classList.remove("toc-sidebar");
    removeReSpec(documentElement);

    const insertions = cloneDoc.createDocumentFragment();

    // Move meta viewport, as it controls the rendering on mobile.
    const metaViewport = cloneDoc.querySelector("meta[name='viewport']");
    if (metaViewport && head.firstChild !== metaViewport) {
      insertions.appendChild(metaViewport);
    }

    // Move charset to near top, as it needs to be in the first 512 bytes.
    let metaCharset = cloneDoc.querySelector(
      "meta[charset], meta[content*='charset=']"
    );
    if (!metaCharset) {
      metaCharset = html`<meta charset="utf-8" />`;
    }
    insertions.appendChild(metaCharset);

    // Add meta generator
    const respecVersion = `ReSpec ${window.respecVersion || "Developer Channel"}`;
    const metaGenerator = html`
    <meta name="generator" content="${respecVersion}" />
  `;

    insertions.appendChild(metaGenerator);
    head.prepend(insertions);
    pub("beforesave", documentElement);
  }

  /** @param {Document} cloneDoc */
  function prettify(cloneDoc) {
    cloneDoc.querySelectorAll("style").forEach(el => {
      el.innerHTML = `\n${el.innerHTML}\n`;
    });
    cloneDoc.querySelectorAll("head > *").forEach(el => {
      el.outerHTML = `\n${el.outerHTML}`;
    });
  }

  expose("core/exporter", { rsDocToDataURL });

  // @ts-check
  /**
   * This module adds a `respec` object to the `document` with the following
   * readonly properties:
   *  - version: returns version of ReSpec Script.
   *  - ready: returns a promise that settles when ReSpec finishes processing.
   *
   */

  class ReSpec {
    constructor() {
      /** @type {Promise<void>} */
      this._respecDonePromise = new Promise(resolve => {
        sub("end-all", () => resolve(), { once: true });
      });

      this.errors = [];
      this.warnings = [];

      sub("error", rsError => {
        console.error(rsError, rsError.toJSON());
        this.errors.push(rsError);
      });
      sub("warn", rsError => {
        console.warn(rsError, rsError.toJSON());
        this.warnings.push(rsError);
      });
    }

    get version() {
      return window.respecVersion;
    }

    get ready() {
      return this._respecDonePromise;
    }

    async toHTML() {
      return serialize("html", document);
    }
  }

  function init() {
    const respec = new ReSpec();
    Object.defineProperty(document, "respec", { value: respec });
  }

  // @ts-check
  // Module core/override-configuration
  // A helper module that makes it possible to override settings specified in respecConfig
  // by passing them as a query string. This is useful when you just want to make a few
  // tweaks to a document before generating the snapshot, without mucking with the source.
  // For example, you can change the status and date by appending:
  //      ?specStatus=LC&publishDate=2012-03-15

  function run$E(config) {
    const params = new URLSearchParams(document.location.search);
    const overrideEntries = Array.from(params)
      .filter(([key, value]) => !!key && !!value)
      .map(([codedKey, codedValue]) => {
        const key = decodeURIComponent(codedKey);
        const decodedValue = decodeURIComponent(codedValue.replace(/%3D/g, "="));
        let value;
        try {
          value = JSON.parse(decodedValue);
        } catch {
          value = decodedValue;
        }
        return [key, value];
      });
    const overrideProps = Object.fromEntries(overrideEntries);
    Object.assign(config, overrideProps);
    pub("amend-user-config", overrideProps);
  }

  // @ts-check
  /**
   * Module core/post-process
   *
   * Corresponds to respecConfig.postProcess and config.afterEnd.
   *  - postProcess: an array of functions that get called
   *      after processing finishes. This is not recommended and the feature is not
   *      tested. Use with care, if you know what you're doing. Chances are you really
   *      want to be using a new module with your own profile.
   *  - afterEnd: final thing that is called.
   */

  const name$D = "core/post-process";

  async function run$D(config) {
    if (Array.isArray(config.postProcess)) {
      const functions = config.postProcess.filter(f => {
        const isFunction = typeof f === "function";
        if (!isFunction) {
          const msg = "Every item in `postProcess` must be a JS function.";
          showError(msg, name$D);
        }
        return isFunction;
      });
      for (const [i, f] of functions.entries()) {
        const fnName = `${name$D}/${f.name || `[${i}]`}`;
        const utils = makePluginUtils(fnName);
        try {
          await f(config, document, utils);
        } catch (err) {
          const msg = `Function ${fnName} threw an error during \`postProcess\`.`;
          const hint = "See developer console.";
          showError(msg, name$D, { hint, cause: err });
        }
      }
    }
    if (typeof config.afterEnd === "function") {
      await config.afterEnd(config, document);
    }
  }

  // @ts-check
  /**
   * Module core/pre-process
   *
   * Corresponds to respecConfig.preProcess.
   *  - preProcess: an array of functions that get called
   *      before anything else happens. This is not recommended and the feature is not
   *      tested. Use with care, if you know what you're doing. Chances are you really
   *      want to be using a new module with your own profile
   */

  const name$C = "core/pre-process";

  async function run$C(config) {
    if (Array.isArray(config.preProcess)) {
      const functions = config.preProcess.filter(f => {
        const isFunction = typeof f === "function";
        if (!isFunction) {
          const msg = "Every item in `preProcess` must be a JS function.";
          showError(msg, name$C);
        }
        return isFunction;
      });
      for (const [i, f] of functions.entries()) {
        const fnName = `${name$C}/${f.name || `[${i}]`}`;
        const utils = makePluginUtils(fnName);
        try {
          await f(config, document, utils);
        } catch (err) {
          const msg = `Function ${fnName} threw an error during \`preProcess\`.`;
          const hint = "See developer console.";
          showError(msg, name$C, { hint, cause: err });
        }
      }
    }
  }

  // @ts-check
  // Module core/base-runner
  // The module in charge of running the whole processing pipeline.

  const name$B = "core/base-runner";

  async function runAll(plugs) {
    init();

    pub("start-all", respecConfig);
    run$F(respecConfig);
    run$E(respecConfig);
    performance.mark(`${name$B}-start`);
    await run$C(respecConfig);

    const runnables = plugs.filter(p => isRunnableModule(p));
    runnables.forEach(
      plug => !plug.name && console.warn("Plugin lacks name:", plug)
    );
    await executePreparePass(runnables, respecConfig);
    await executeRunPass(runnables, respecConfig);
    pub("plugins-done", respecConfig);

    await run$D(respecConfig);
    pub("end-all");
    removeReSpec(document);
    performance.mark(`${name$B}-end`);
    performance.measure(name$B, `${name$B}-start`, `${name$B}-end`);
  }

  function isRunnableModule(plug) {
    return plug && (plug.run || plug.Plugin);
  }

  async function executePreparePass(runnables, config) {
    for (const plug of runnables.filter(p => p.prepare)) {
      try {
        await plug.prepare(config);
      } catch (err) {
        console.error(err);
      }
    }
  }

  async function executeRunPass(runnables, config) {
    for (const plug of runnables) {
      const name = plug.name || "";

      try {
        // eslint-disable-next-line no-async-promise-executor
        await new Promise(async (resolve, reject) => {
          const timerId = setTimeout(() => {
            const msg = `Plugin ${name} took too long.`;
            console.error(msg, plug);
            reject(new Error(msg));
          }, 15000);

          performance.mark(`${name}-start`);
          try {
            if (plug.Plugin) {
              await new plug.Plugin(config).run();
              resolve();
            } else if (plug.run) {
              await plug.run(config);
              resolve();
            }
          } catch (err) {
            reject(err);
          } finally {
            clearTimeout(timerId);
            performance.mark(`${name}-end`);
            performance.measure(name, `${name}-start`, `${name}-end`);
          }
        });
      } catch (error) {
        console.error(error);
      }
    }
  }

  const css$8 = String.raw;

  // Prettier ignore only to keep code indented from level 0.
  // prettier-ignore
  var css$9 = css$8`
.respec-modal .close-button {
  position: absolute;
  z-index: inherit;
  padding: 0.2em;
  font-weight: bold;
  cursor: pointer;
  margin-left: 5px;
  border: none;
  background: transparent;
}

#respec-ui {
  position: fixed;
  display: flex;
  flex-direction: row-reverse;
  top: 20px;
  right: 20px;
  width: 202px;
  text-align: right;
  z-index: 9000;
}


#respec-pill,
.respec-info-button {
  height: 2.4em;
  background: #fff;
  background: var(--bg, #fff);
  color: rgb(120, 120, 120);
  color: var(--tocnav-normal-text, rgb(120, 120, 120));
  border: 1px solid #ccc;
  box-shadow: 1px 1px 8px 0 rgba(100, 100, 100, 0.5);
  box-shadow: 1px 1px 8px 0 var(--tocsidebar-shadow, rgba(100, 100, 100, 0.5));
  padding: 0.2em 0em;
}

.respec-info-button {
  border: none;
  opacity: 0.75;
  border-radius: 2em;
  margin-right: 1em;
  min-width: 3.5em;
  will-change: opacity;
}

.respec-info-button:focus,
.respec-info-button:hover {
  opacity: 1;
  transition: opacity 0.2s;
}

#respec-pill {
  width: 4.8em;
}

#respec-pill:not(:disabled) {
  animation: respec-fadein 0.6s ease-in-out;
}

@keyframes respec-fadein {
  from {
    margin-top: -1.2em;
    border-radius: 50%;
    border: 0.2em solid rgba(100, 100, 100, 0.5);
    box-shadow: none;
    height: 4.8em;
  }
  to {
    margin-top: 0;
    border: 1px solid #ccc;
    border-radius: 0;
    box-shadow: 1px 1px 8px 0 rgba(100, 100, 100, 0.5);
    height: 2.4em;
  }
}

#respec-pill:disabled {
  margin-top: -1.2em;
  position: relative;
  border: none;
  box-shadow: none;
  border-radius: 50%;
  width: 4.8em;
  height: 4.8em;
  padding: 0;
}

#respec-pill:disabled::after {
  position: absolute;
  content: '';
  inset: -0.2em;
  border-radius: 50%;
  border: 0.2em solid rgba(100, 100, 100, 0.5);
  border-left: 0.2em solid transparent;
  animation: respec-spin 0.5s infinite linear;
}

@media (prefers-reduced-motion) {
  #respec-pill:not(:disabled) {
    animation: none;
  }

  #respec-pill:disabled::after {
    animation: none;
    border-left: 0.2em solid rgba(100, 100, 100, 0.5);
  }
}

@keyframes respec-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.respec-hidden {
  visibility: hidden;
  opacity: 0;
  transition: visibility 0s 0.2s, opacity 0.2s linear;
}

.respec-visible {
  visibility: visible;
  opacity: 1;
  transition: opacity 0.2s linear;
}

#respec-pill:hover,
#respec-pill:focus {
  color: rgb(0, 0, 0);
  background-color: rgb(245, 245, 245);
  transition: color 0.2s;
}

#respec-menu {
  position: absolute;
  margin: 0;
  padding: 0;
  font-family: sans-serif;
  background: var(--bg, #fff);
  color: var(--text, black);
  box-shadow: 1px 1px 8px 0 rgba(100, 100, 100, 0.5);
  width: 200px;
  display: none;
  text-align: left;
  margin-top: 32px;
  font-size: 0.8em;
}

#respec-menu:not([hidden]) {
  display: block;
}

#respec-menu li {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

.respec-save-buttons {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(47%, 2fr));
  grid-gap: 0.5cm;
  padding: 0.5cm;
}

.respec-save-button:link {
  padding-top: 16px;
  color: var(--def-text, white);
  background: var(--def-bg, rgb(42, 90, 168));
  justify-self: stretch;
  height: 1cm;
  text-decoration: none;
  text-align: center;
  font-size: inherit;
  border: none;
  border-radius: 0.2cm;
}

.respec-save-button:link:hover {
  color: var(--def-text, white);
  background: var(--defrow-border, rgb(42, 90, 168));
  padding: 0;
  margin: 0;
  border: 0;
  padding-top: 16px;
}

.respec-save-button:link:focus {
  background: var(--tocnav-active-bg, #193766);
  color: var(--tocnav-active-text, black);
}

#respec-ui button:focus,
#respec-pill:focus,
.respec-option:focus {
  outline: 0;
  outline-style: none;
}

#respec-pill-error {
  background-color: red;
  color: white;
}

#respec-pill-warning {
  background-color: orange;
  color: white;
}

.respec-warning-list,
.respec-error-list {
  margin: 0;
  padding: 0;
  font-family: sans-serif;
  font-size: 0.85em;
}

.respec-warning-list {
  background-color: rgb(255, 251, 230);
}

:is(.respec-warning-list,.respec-error-list) > li {
  list-style-type: none;
  margin: 0;
  padding: .5em 0;
  padding-left: 2em;
  padding-right: .5em;
}

:is(.respec-warning-list,.respec-error-list) > li + li {
  margin-top: 0.5rem;
}

:is(.respec-warning-list,.respec-error-list) > li:before {
  position: absolute;
  left: .4em;
}

:is(.respec-warning-list,.respec-error-list) p {
  padding: 0;
  margin: 0;
}

.respec-warning-list > li {
  color: rgb(92, 59, 0);
  border-bottom: thin solid rgb(255, 245, 194);
}

.respec-error-list,
.respec-error-list li {
  background-color: rgb(255, 240, 240);
}

.respec-warning-list > li::before {
  content: "â ï¸";
}

.respec-error-list > li::before {
  content: "ð¥";
}

.respec-error-list > li {
  color: rgb(92, 59, 0);
  border-bottom: thin solid rgb(255, 215, 215);
}

:is(.respec-warning-list,.respec-error-list) > li li {
  list-style: disc;
}

#respec-overlay {
  display: block;
  position: fixed;
  z-index: 10000;
  top: 0px;
  left: 0px;
  height: 100%;
  width: 100%;
  background: #000;
}

.respec-show-overlay {
  transition: opacity 0.2s linear;
  opacity: 0.5;
}

.respec-hide-overlay {
  transition: opacity 0.2s linear;
  opacity: 0;
}

.respec-modal {
  display: block;
  position: fixed;
  z-index: 11000;
  top: 10%;
  background: var(--bg, #fff);
  color: var(--text, black);
  border: 5px solid #666;
  border-color: var(--tocsidebar-shadow, #666);
  min-width: 20%;
  padding: 0;
  max-height: 80%;
  overflow-y: auto;
  margin: 0 -0.5cm;
  left: 20%;
  max-width: 75%;
  min-width: 60%;
}


.respec-modal h3 {
  margin: 0;
  padding: 0.2em;
  left: 0 !important;
  text-align: center;
  background: var(--tocsidebar-shadow, #ddd);
  color: var(--text, black);
  font-size: 1em;
}

#respec-menu button.respec-option {
  background: var(--bg, white);
  color: var(--text, black);
  border: none;
  width: 100%;
  text-align: left;
  font-size: inherit;
  padding: 1.2em 1.2em;
}

#respec-menu button.respec-option:hover {
  background-color: var(--tocnav-hover-bg, #eee);
  color: var(--tocnav-hover-text, black);
}

.respec-cmd-icon {
  padding-right: 0.5em;
}

#respec-ui button.respec-option:first-child {
  margin-top: 0;
}
#respec-ui button.respec-option:last-child {
  border: none;
  border-radius: inherit;
  margin-bottom: 0;
}

.respec-button-copy-paste {
  position: absolute;
  height: 28px;
  width: 40px;
  cursor: pointer;
  background-image: linear-gradient(#fcfcfc, #eee);
  border: 1px solid rgb(144, 184, 222);
  border-left: 0;
  border-radius: 0px 0px 3px 0;
  -webkit-user-select: none;
  user-select: none;
  -webkit-appearance: none;
  top: 0;
  left: 127px;
}

@media print {
  #respec-ui {
    display: none;
  }
}

.respec-iframe {
  width: 100%;
  min-height: 550px;
  height: 100%;
  overflow: hidden;
  padding: 0;
  margin: 0;
  border: 0;
}

.respec-iframe:not(.ready) {
  background: url("https://respec.org/xref/loader.gif") no-repeat center;
}

.respec-iframe + a[href] {
  font-size: 0.9rem;
  float: right;
  margin: 0 0.5em 0.5em;
  border-bottom-width: 1px;
}

p:is(.respec-hint,.respec-occurrences) {
  display: block;
  margin-top: 0.5em;
}

.respec-plugin {
  text-align: right;
  color: rgb(120, 120, 120, .5);
  font-size: 0.6em;
}
`;

  // @ts-check
  /**
   * Module core/markdown
   * Handles the optional markdown processing.
   *
   * Markdown support is optional. It is enabled by setting the `format`
   * property of the configuration object to "markdown."
   *
   * We use marked for parsing Markdown:
   * https://github.com/markedjs/marked
   *
   */


  const name$A = "core/markdown";

  const gtEntity = /&gt;/gm;
  const ampEntity = /&amp;/gm;

  class Renderer extends marked.Renderer {
    code(code, infoString, isEscaped) {
      const { language, ...metaData } = Renderer.parseInfoString(infoString);

      // regex to check whether the language is webidl
      if (/(^webidl$)/i.test(language)) {
        return `<pre class="idl">${code}</pre>`;
      }

      const html = super
        .code(code, language, isEscaped)
        .replace(`class="language-`, `class="`);

      const { example, illegalExample } = metaData;
      if (!example && !illegalExample) return html;

      const title = example || illegalExample;
      const className = `${language} ${example ? "example" : "illegal-example"}`;
      return html.replace("<pre>", `<pre title="${title}" class="${className}">`);
    }

    image(href, title, text) {
      if (!title) {
        return super.image(href, title, text);
      }
      const html = String.raw;
      return html`
      <figure>
        <img src="${href}" alt="${text}" />
        <figcaption>${title}</figcaption>
      </figure>
    `;
    }

    /**
     * @param {string} infoString
     */
    static parseInfoString(infoString) {
      const firstSpace = infoString.search(/\s/);
      if (firstSpace === -1) {
        return { language: infoString };
      }

      const language = infoString.slice(0, firstSpace);
      const metaDataStr = infoString.slice(firstSpace + 1);
      let metaData;
      if (metaDataStr) {
        try {
          metaData = JSON.parse(`{ ${metaDataStr} }`);
        } catch (error) {
          console.error(error);
        }
      }

      return { language, ...metaData };
    }

    heading(text, level, raw) {
      const headingWithIdRegex = /(.+)\s+{#([\w-]+)}$/;
      if (headingWithIdRegex.test(text)) {
        const [, textContent, id] = text.match(headingWithIdRegex);
        return `<h${level} id="${id}">${textContent}</h${level}>`;
      }
      return super.heading(text, level, raw);
    }
  }

  /** @type {import('marked').MarkedOptions} */
  const config = {
    gfm: true,
    renderer: new Renderer(),
  };

  /**
   * @param {string} text
   * @param {object} options
   * @param {boolean} options.inline
   */
  function markdownToHtml(text, options = { inline: false }) {
    const normalizedLeftPad = reindent(text);
    // As markdown is pulled from HTML, > and & are already escaped and
    // so blockquotes aren't picked up by the parser. This fixes it.
    const potentialMarkdown = normalizedLeftPad
      .replace(gtEntity, ">")
      .replace(ampEntity, "&");

    const result = options.inline
      ? marked.parseInline(potentialMarkdown, config)
      : marked.parse(potentialMarkdown, config);
    return result;
  }

  /**
   * @param {string} selector
   * @return {(el: Element) => Element[]}
   */
  function convertElements(selector) {
    return element => {
      const elements = element.querySelectorAll(selector);
      elements.forEach(convertElement);
      return Array.from(elements);
    };
  }

  /**
   * @param {Element} element
   */
  function convertElement(element) {
    for (const pre of element.getElementsByTagName("pre")) {
      // HTML parser implicitly removes a newline after <pre>
      // which breaks reindentation algorithm
      pre.prepend("\n");
    }
    element.innerHTML = markdownToHtml(element.innerHTML);
  }

  /**
   * CommonMark requires additional empty newlines between markdown and HTML lines.
   * This function adds them as a backward compatibility workaround.
   * @param {HTMLElement} element
   * @param {string} selector
   */
  function workaroundBlockLevelMarkdown(element, selector) {
    /** @type {NodeListOf<HTMLElement>} */
    const elements = element.querySelectorAll(selector);
    for (const element of elements) {
      const { innerHTML } = element;
      if (/^<\w/.test(innerHTML.trimStart())) {
        // if the block content starts with HTML-like format
        // then assume it doesn't need a workaround
        continue;
      }
      // Double newlines are needed to be parsed as Markdown
      const lines = innerHTML.split("\n");
      const firstTwo = lines.slice(0, 2).join("\n");
      const lastTwo = lines.slice(-2).join("\n");
      if (firstTwo.trim()) {
        element.prepend("\n\n");
      }
      if (lastTwo.trim()) {
        // keep the indentation of the end tag
        const indentation = getElementIndentation(element);
        element.append(`\n\n${indentation}`);
      }
    }
  }

  /**
   * @param {Iterable<Element>} elements
   */
  function substituteWithTextNodes(elements) {
    Array.from(elements).forEach(element => {
      element.replaceWith(element.textContent);
    });
  }

  const processMDSections = convertElements("[data-format='markdown']:not(body)");
  const blockLevelElements =
    "[data-format=markdown], section, div, address, article, aside, figure, header, main";

  function run$B(conf) {
    const hasMDSections = !!document.querySelector(
      "[data-format=markdown]:not(body)"
    );
    const isMDFormat = conf.format === "markdown";
    if (!isMDFormat && !hasMDSections) {
      return; // Nothing to be done
    }
    // Only has markdown-format sections
    if (!isMDFormat) {
      processMDSections(document.body);
      return;
    }
    // We transplant the UI to do the markdown processing
    const rsUI = document.getElementById("respec-ui");
    rsUI.remove();
    // The new body will replace the old body
    const newBody = document.body.cloneNode(true);
    // Marked expects markdown be flush against the left margin
    // so we need to normalize the inner text of some block
    // elements.
    workaroundBlockLevelMarkdown(newBody, blockLevelElements);
    convertElement(newBody);
    // Remove links where class .nolinks
    substituteWithTextNodes(newBody.querySelectorAll(".nolinks a[href]"));
    // Frankenstein the whole thing back together
    newBody.append(rsUI);
    document.body.replaceWith(newBody);
  }

  var markdown = /*#__PURE__*/Object.freeze({
    __proto__: null,
    markdownToHtml: markdownToHtml,
    name: name$A,
    run: run$B
  });

  // @ts-check
  // Module core/ui
  // Handles the ReSpec UI
  // XXX TODO
  //  - look at other UI things to add
  //      - list issues
  //      - lint: validator, link checker, check WebIDL, ID references
  //      - save to GitHub
  //  - make a release candidate that people can test
  //  - once we have something decent, merge, ship as 3.2.0

  // Opportunistically inserts the style, with the chance to reduce some FOUC
  insertStyle$1();

  function insertStyle$1() {
    const styleElement = document.createElement("style");
    styleElement.id = "respec-ui-styles";
    styleElement.textContent = css$9;
    styleElement.classList.add("removeOnSave");
    document.head.appendChild(styleElement);
    return styleElement;
  }

  function ariaDecorate(elem, ariaMap) {
    if (!elem) {
      return;
    }
    Array.from(ariaMap).forEach(([name, value]) => {
      elem.setAttribute(`aria-${name}`, value);
    });
  }

  const respecUI = html`<div id="respec-ui" class="removeOnSave" hidden></div>`;
  const menu = html`<ul
  id="respec-menu"
  role="menu"
  aria-labelledby="respec-pill"
  hidden
></ul>`;
  const closeButton = html`<button
  class="close-button"
  onclick=${() => ui.closeModal()}
  title="Close"
>
  â
</button>`;
  window.addEventListener("load", () => trapFocus(menu));
  let modal;
  let overlay;
  const errors = [];
  const warnings = [];
  const buttons = {};

  sub("start-all", () => document.body.prepend(respecUI), { once: true });
  sub("end-all", () => document.body.prepend(respecUI), { once: true });

  const respecPill = html`<button id="respec-pill" disabled>ReSpec</button>`;
  respecUI.appendChild(respecPill);
  respecPill.addEventListener("click", e => {
    e.stopPropagation();
    respecPill.setAttribute("aria-expanded", String(menu.hidden));
    toggleMenu();
    menu.querySelector("li:first-child button").focus();
  });

  document.documentElement.addEventListener("click", () => {
    if (!menu.hidden) {
      toggleMenu();
    }
  });
  respecUI.appendChild(menu);

  menu.addEventListener("keydown", e => {
    if (e.key === "Escape" && !menu.hidden) {
      respecPill.setAttribute("aria-expanded", String(menu.hidden));
      toggleMenu();
      respecPill.focus();
    }
  });

  function toggleMenu() {
    menu.classList.toggle("respec-hidden");
    menu.classList.toggle("respec-visible");
    menu.hidden = !menu.hidden;
  }

  // Code adapted from https://hiddedevries.nl/en/blog/2017-01-29-using-javascript-to-trap-focus-in-an-element
  function trapFocus(element) {
    const focusableEls = element.querySelectorAll(
      "a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input:not([disabled]), select:not([disabled])"
    );
    const firstFocusableEl = focusableEls[0];
    const lastFocusableEl = focusableEls[focusableEls.length - 1];
    if (firstFocusableEl) {
      firstFocusableEl.focus();
    }
    element.addEventListener("keydown", e => {
      if (e.key !== "Tab") {
        return;
      }
      // shift + tab
      if (e.shiftKey) {
        if (document.activeElement === firstFocusableEl) {
          lastFocusableEl.focus();
          e.preventDefault();
        }
      }
      // tab
      else if (document.activeElement === lastFocusableEl) {
        firstFocusableEl.focus();
        e.preventDefault();
      }
    });
  }

  const ariaMap = new Map([
    ["controls", "respec-menu"],
    ["expanded", "false"],
    ["haspopup", "true"],
    ["label", "ReSpec Menu"],
  ]);
  ariaDecorate(respecPill, ariaMap);

  function errWarn(err, arr, butName, title) {
    arr.push(err);
    if (!buttons.hasOwnProperty(butName)) {
      buttons[butName] = createWarnButton(butName, arr, title);
      respecUI.appendChild(buttons[butName]);
    }
    const button = buttons[butName];
    button.textContent = arr.length;
    const label = arr.length === 1 ? pluralize.singular(title) : title;
    const ariaMap = new Map([["label", `${arr.length} ${label}`]]);
    ariaDecorate(button, ariaMap);
  }

  function createWarnButton(butName, arr, title) {
    const buttonId = `respec-pill-${butName}`;
    const button = html`<button
    id="${buttonId}"
    class="respec-info-button"
  ></button>`;
    button.addEventListener("click", () => {
      button.setAttribute("aria-expanded", "true");
      const ol = html`<ol class="${`respec-${butName}-list`}"></ol>`;
      for (const err of arr) {
        const fragment = document
          .createRange()
          .createContextualFragment(rsErrorToHTML(err));
        const li = document.createElement("li");
        // if it's only a single element, just copy the contents into li
        if (fragment.firstElementChild === fragment.lastElementChild) {
          li.append(...fragment.firstElementChild.childNodes);
          // Otherwise, take everything.
        } else {
          li.appendChild(fragment);
        }
        ol.appendChild(li);
      }
      ui.freshModal(title, ol, button);
    });
    const ariaMap = new Map([
      ["expanded", "false"],
      ["haspopup", "true"],
      ["controls", `respec-pill-${butName}-modal`],
    ]);
    ariaDecorate(button, ariaMap);
    return button;
  }

  const ui = {
    show() {
      try {
        respecUI.hidden = false;
      } catch (err) {
        console.error(err);
      }
    },
    hide() {
      respecUI.hidden = true;
    },
    enable() {
      respecPill.removeAttribute("disabled");
    },
    /**
     * @param {string} _keyShort shortcut key. unused - kept for backward compatibility.
     */
    addCommand(label, handler, _keyShort, icon) {
      icon = icon || "";
      const id = `respec-button-${label.toLowerCase().replace(/\s+/, "-")}`;
      const button = html`<button id="${id}" class="respec-option">
      <span class="respec-cmd-icon" aria-hidden="true">${icon}</span> ${label}â¦
    </button>`;
      const menuItem = html`<li role="menuitem">${button}</li>`;
      menuItem.addEventListener("click", handler);
      menu.appendChild(menuItem);
      return button;
    },
    error(rsError) {
      errWarn(rsError, errors, "error", "ReSpec Errors");
    },
    warning(rsError) {
      errWarn(rsError, warnings, "warning", "ReSpec Warnings");
    },
    closeModal(owner) {
      if (overlay) {
        overlay.classList.remove("respec-show-overlay");
        overlay.classList.add("respec-hide-overlay");
        overlay.addEventListener("transitionend", () => {
          overlay.remove();
          overlay = null;
        });
      }
      if (owner) {
        owner.setAttribute("aria-expanded", "false");
      }
      if (!modal) return;
      modal.remove();
      modal = null;
      respecPill.focus();
    },
    freshModal(title, content, currentOwner) {
      if (modal) modal.remove();
      if (overlay) overlay.remove();
      overlay = html`<div id="respec-overlay" class="removeOnSave"></div>`;
      const id = `${currentOwner.id}-modal`;
      const headingId = `${id}-heading`;
      modal = html`<div
      id="${id}"
      class="respec-modal removeOnSave"
      role="dialog"
      aria-labelledby="${headingId}"
    >
      ${closeButton}
      <h3 id="${headingId}">${title}</h3>
      <div class="inside">${content}</div>
    </div>`;
      const ariaMap = new Map([["labelledby", headingId]]);
      ariaDecorate(modal, ariaMap);
      document.body.append(overlay, modal);
      overlay.addEventListener("click", () => this.closeModal(currentOwner));
      overlay.classList.toggle("respec-show-overlay");
      modal.hidden = false;
      trapFocus(modal);
    },
  };
  document.addEventListener("keydown", ev => {
    if (ev.key === "Escape") {
      ui.closeModal();
    }
  });
  window.respecUI = ui;
  sub("error", details => ui.error(details));
  sub("warn", details => ui.warning(details));

  function rsErrorToHTML(err) {
    if (typeof err === "string") {
      return err;
    }

    const plugin = err.plugin
      ? `<p class="respec-plugin">(plugin: "${err.plugin}")</p>`
      : "";

    const hint = err.hint
      ? `\n${markdownToHtml(
        `<p class="respec-hint"><strong>How to fix:</strong> ${reindent(
          err.hint
        )}`,
        {
          inline: !err.hint.includes("\n"),
        }
      )}\n`
      : "";
    const elements = Array.isArray(err.elements)
      ? `<p class="respec-occurrences">Occurred <strong>${
        err.elements.length
      }</strong> times at:</p>
    ${markdownToHtml(err.elements.map(generateMarkdownLink).join("\n"))}`
      : "";
    const details = err.details
      ? `\n\n<details>\n${err.details}\n</details>\n`
      : "";
    const msg = markdownToHtml(`**${xmlEscape(err.message)}**`, { inline: true });
    const result = `${msg}${hint}${elements}${details}${plugin}`;
    return result;
  }

  /**
   * @param {Element} element
   */
  function generateMarkdownLink(element) {
    return `* [\`<${element.localName}>\`](#${element.id}) element`;
  }

  // In case everything else fails, we want the error
  window.addEventListener("error", ev => {
    console.error(ev.error, ev.message, ev);
  });

  async function run$A(plugins) {
    try {
      ui.show();
      await domReady();
      await runAll(plugins);
    } finally {
      ui.enable();
    }
  }

  async function domReady() {
    if (document.readyState === "loading") {
      await new Promise(resolve =>
        document.addEventListener("DOMContentLoaded", resolve)
      );
    }
  }

  const modules = [
    // order is significant
    Promise.resolve().then(function () { return locationHash; }),
    Promise.resolve().then(function () { return l10n$d; }),
    Promise.resolve().then(function () { return pcisigDefaults$1; }),
    Promise.resolve().then(function () { return style; }),
    Promise.resolve().then(function () { return pcisigStyle; }),
    Promise.resolve().then(function () { return github$1; }),
    Promise.resolve().then(function () { return dataInclude; }),
    Promise.resolve().then(function () { return markdown; }),
    Promise.resolve().then(function () { return pcisigHeaders; }),
    Promise.resolve().then(function () { return footnotes; }),
    Promise.resolve().then(function () { return pcisigConformance; }),
    Promise.resolve().then(function () { return dataTransform; }),
    Promise.resolve().then(function () { return inlines; }),
    Promise.resolve().then(function () { return examples; }),
    Promise.resolve().then(function () { return issuesNotes; }),
    Promise.resolve().then(function () { return impnote; }),
    Promise.resolve().then(function () { return requirements; }),
    Promise.resolve().then(function () { return bestPractices; }),
    Promise.resolve().then(function () { return regpict; }),
    Promise.resolve().then(function () { return figures; }),
    Promise.resolve().then(function () { return tables; }),
    Promise.resolve().then(function () { return equations; }),
    Promise.resolve().then(function () { return preDfn; }),
    Promise.resolve().then(function () { return dfn; }),
    Promise.resolve().then(function () { return dataCite; }),
    Promise.resolve().then(function () { return linkToDfn; }),
    Promise.resolve().then(function () { return contrib; }),
    Promise.resolve().then(function () { return fixHeaders; }),
    Promise.resolve().then(function () { return structure; }),
    Promise.resolve().then(function () { return informative; }),
    Promise.resolve().then(function () { return idHeaders; }),
    Promise.resolve().then(function () { return figTblEqnNumbering; }),
    Promise.resolve().then(function () { return aria; }),
    Promise.resolve().then(function () { return xrefMap; }),
    Promise.resolve().then(function () { return aboutRespec; }),
    Promise.resolve().then(function () { return saveHtml; }),
    Promise.resolve().then(function () { return dataTests; }),
    Promise.resolve().then(function () { return includeFinalConfig; }),
    Promise.resolve().then(function () { return emptyReferences; }),
  ];

  var pcisig = run$A(modules);

  // @ts-check
  // Module core/location-hash
  // As ReSpec injects a bunch of stuff async, the scroll position is not always
  // at the right place when we are done processing. The purpose of this module
  // is to reset window's location hash, which will cause the browser to scroll
  // the window to the correct point in the document when processing is done.

  const name$z = "core/location-hash";

  function run$z() {
    if (!window.location.hash) {
      return;
    }

    // We have to use .then() here because otherwise we would get stuck
    // awaiting this plugin to finish.
    document.respec.ready.then(() => {
      const hash = decodeURIComponent(window.location.hash).slice(1);

      let newHash = hash;
      /** @type {HTMLElement|null} */
      const element = document.getElementById(newHash);

      // Check if hash contains any non-word character.
      const isLegacyFrag = /\W/.test(newHash);

      // Allow some degree of recovery for legacy fragments format.
      // See https://github.com/speced/respec/issues/1353
      if (!element && isLegacyFrag) {
        const id = newHash
          // Replace all non-word characters with a dash.
          .replace(/[\W]+/gim, "-")
          // Remove any leading dashes.
          .replace(/^-+/, "")
          // Remove any trailing dashes.
          .replace(/-+$/, "");

        /** @type {HTMLElement|null} */
        const updatedElement = document.getElementById(id);
        if (updatedElement) {
          newHash = id;
        }
      }
      window.location.hash = `#${newHash}`;
    });
  }

  var locationHash = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$z,
    run: run$z
  });

  /**
   * Sets the defaults for W3C specs
   */
  const name$y = "pcisig/pcisig-defaults";

  /*const cgbg = new Set(["BG-DRAFT", "BG-FINAL", "CG-DRAFT", "CG-FINAL"]);
  const licenses = new Map([
    [
      "cc0",
      {
        name: "Creative Commons 0 Public Domain Dedication",
        short: "CC0",
        url: "https://creativecommons.org/publicdomain/zero/1.0/",
      },
    ],
    [
      "w3c-software",
      {
        name: "W3C Software Notice and License",
        short: "W3C Software",
        url:
          "https://www.w3.org/Consortium/Legal/2002/copyright-software-20021231",
      },
    ],
    [
      "w3c-software-doc",
      {
        name: "W3C Software and Document Notice and License",
        short: "W3C Software and Document",
        url:
          "https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document",
      },
    ],
    [
      "cc-by",
      {
        name: "Creative Commons Attribution 4.0 International Public License",
        short: "CC-BY",
        url: "https://creativecommons.org/licenses/by/4.0/legalcode",
      },
    ],
  ]);
  */
  const pcisigDefaults = {
    processVersion: 2017,
    lint: {
      "no-headingless-sections": true,
      "privsec-section": true,
      "no-http-props": true,
    },
    doRDFa: false,
    license: "pcisig-draft",
    specStatus: "WD",
    logos: [],
  };

  /*function computeProps(conf) {
    return {
      isCCBY: conf.license === "cc-by",
      licenseInfo: licenses.get(conf.license),
      isCGBG: cgbg.has(conf.specStatus),
      isCGFinal: conf.isCGBG && /G-FINAL$/.test(conf.specStatus),
      isBasic: conf.specStatus === "base",
      isRegular: !conf.isCGBG && conf.specStatus === "base",
    };
  }
  */

  function run$y(conf) {
    // assign the defaults
    Object.assign(conf, { ...pcisigDefaults, ...conf });
    //computed properties
    //Object.assign(conf, computeProps(conf));
  }

  var pcisigDefaults$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$y,
    run: run$y
  });

  /* ReSpec specific CSS */
  const css$6 = String.raw;

  // Prettier ignore only to keep code indented from level 0.
  // prettier-ignore
  var css$7 = css$6`
@keyframes pop {
  0% {
    transform: scale(1, 1);
  }
  25% {
    transform: scale(1.25, 1.25);
    opacity: 0.75;
  }
  100% {
    transform: scale(1, 1);
  }
}

/* --- INLINES --- */
a.internalDFN {
  color: inherit;
  border-bottom: 1px solid #99c;
  text-decoration: none;
}

a.externalDFN {
  color: inherit;
  border-bottom: 1px dotted #ccc;
  text-decoration: none;
}

a.bibref {
  text-decoration: none;
}

.respec-offending-element:target {
  animation: pop 0.25s ease-in-out 0s 1;
}

.respec-offending-element,
a[href].respec-offending-element {
  text-decoration: red wavy underline;
}
@supports not (text-decoration: red wavy underline) {
  .respec-offending-element:not(pre) {
    display: inline-block;
  }
  .respec-offending-element {
    /* Red squiggly line */
    background: url(data:image/gif;base64,R0lGODdhBAADAPEAANv///8AAP///wAAACwAAAAABAADAEACBZQjmIAFADs=)
      bottom repeat-x;
  }
}

#references :target {
  background: #eaf3ff;
  animation: pop 0.4s ease-in-out 0s 1;
}

cite .bibref {
  font-style: italic;
}

a[href].orcid {
  padding-left: 4px;
  padding-right: 4px;
}

a[href].orcid > svg {
  margin-bottom: -2px;
}

/* --- TOF --- */
ul.tof,
ol.tof {
  list-style: none outside none;
}

.caption {
  margin-top: 0.5em;
  font-style: italic;
}
#issue-summary > ul {
  column-count: 2;
}

#issue-summary li {
  list-style: none;
  display: inline-block;
}

details.respec-tests-details {
  margin-left: 1em;
  display: inline-block;
  vertical-align: top;
}

details.respec-tests-details > * {
  padding-right: 2em;
}

details.respec-tests-details[open] {
  z-index: 999999;
  position: absolute;
  border: thin solid #cad3e2;
  border-radius: 0.3em;
  background-color: white;
  padding-bottom: 0.5em;
}

details.respec-tests-details[open] > summary {
  border-bottom: thin solid #cad3e2;
  padding-left: 1em;
  margin-bottom: 1em;
  line-height: 2em;
}

details.respec-tests-details > ul {
  width: 100%;
  margin-top: -0.3em;
}

details.respec-tests-details > li {
  padding-left: 1em;
}

.self-link:hover {
  opacity: 1;
  text-decoration: none;
  background-color: transparent;
}

aside.example .marker > a.self-link {
  color: inherit;
}

.header-wrapper {
  display: flex;
  align-items: baseline;
}

:is(h2, h3, h4, h5, h6):not(#toc > h2, #abstract > h2, #sotd > h2, .head > h2) {
  position: relative;
  left: -.5em;
}

:is(h2, h3, h4, h5, h6):not(#toc h2) + a.self-link {
  color: inherit;
  order: -1;
  position: relative;
  left: -1.1em;
  font-size: 1rem;
  opacity: 0.5;
}

:is(h2, h3, h4, h5, h6) + a.self-link::before {
  content: "Â§";
  text-decoration: none;
  color: var(--heading-text);
}

:is(h2, h3) + a.self-link {
  top: -0.2em;
}

:is(h4, h5, h6) + a.self-link::before {
  color: black;
}

@media (max-width: 767px) {
  dd {
    margin-left: 0;
  }
}

@media print {
  .removeOnSave {
    display: none;
  }
}
`;

  // @ts-check
  // Module core/style
  // The purpose of this module is to insert the default ReSpec CSS into the document.
  // If you don't want to use the default ReSpec CSS, set the `noReSpecCSS` configuration
  // option to `true`. If you want to use your own styles, create a ReSpec profile that
  // includes your own styles and sets the `noReSpecCSS` configuration option to `true`.

  /**
   * Module Name.
   * @type {string}
   */
  const name$x = "core/style";

  // Opportunistically inserts the style to reduce some FOUC.
  /** @type {HTMLStyleElement} */
  const styleElement = insertStyle();

  /**
   * Inserts the ReSpec CSS as a `style` element into the document's `head`.
   * @return {HTMLStyleElement} The `style` element that was inserted.
   */
  function insertStyle() {
    const styleElement = document.createElement("style");
    styleElement.id = "respec-mainstyle";
    styleElement.textContent = css$7;
    document.head.appendChild(styleElement);
    return styleElement;
  }

  /**
   * Removes the ReSpec CSS if the `noReSpecCSS` configuration option is `true`.
   * @param {Conf} conf The document configuration object.
   */
  function run$x(conf) {
    if (conf.noReSpecCSS) {
      styleElement.remove();
    }
  }

  var style = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$x,
    run: run$x
  });

  /*jshint strict: true, browser:true, jquery: true*/
  /*globals define*/
  // Module pcisig/style
  // Inserts a link to the appropriate PCISIG style for the specification's maturity level.
  // CONFIGURATION
  //  - specStatus: the short code for the specification's maturity level or type (required)


  const name$w = "pcisig/style";

  function attachFixupScript(doc, version) {
    const script = doc.createElement("script");
    script.addEventListener(
      "load",
      function () {
        if (window.location.hash) {
          window.location = window.location;
        }
      },
      {once: true}
    );
    script.src = `https://sglaser.github.io/respec/Spec/scripts/${version}/fixup.js`;
    doc.body.appendChild(script);
  }

  // Make a best effort to attach meta viewport at the top of the head.
  // Other plugins might subsequently push it down, but at least we start
  // at the right place. When ReSpec exports the HTML, it again moves the
  // meta viewport to the top of the head - so to make sure it's the first
  // thing the browser sees. See js/ui/save-html.js.
  function createMetaViewport() {
    const meta = document.createElement("meta");
    meta.name = "viewport";
    const contentProps = {
      width: "device-width",
      "initial-scale": "1",
      "shrink-to-fit": "no",
    };
    meta.content = toKeyValuePairs(contentProps).replace(/\"/g, "");
    return meta;
  }

  function createBaseStyle() {
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = "https://sglaser.github.io/respec/Spec/StyleSheets/2017/base.css";
    link.classList.add("removeOnSave");
    return link;
  }

  function selectStyleVersion(styleVersion) {
    let version = "";
    switch (styleVersion) {
      case null:
      case true:
        version = "2017";
        break;
      default:
        if (!isNaN(styleVersion)) {
          version = styleVersion.toString().trim();
        }
    }
    return version;
  }

  function createResourceHints() {
    const resourceHints = [
      {
        hint: "preconnect", // for PCISIG styles and scripts.
        href: "https://sglaser.github.io/respec/Spec",
      },
      {
        hint: "preload", // all specs need it, and we attach it on end-all.
        href: "https://sglaser.github.io/respec/Spec/scripts/2017/fixup.js",
        as: "script",
      },
      {
        hint: "preload", // all specs include on base.css.
        href: "https://sglaser.github.io/respec/Spec/StyleSheets/2017/base.css",
        as: "style",
      },
      {
        hint: "preload", // all specs show the logo.
        href: "https://sglaser.github.io/respec/Spec/StyleSheets/2017/logos/pci_express_PMS.svg",
        as: "image",
      },
    ]
      .map(createResourceHint)
      .reduce(function (frag, link) {
        frag.appendChild(link);
        return frag;
      }, document.createDocumentFragment());
    return resourceHints;
  }

  // Collect elements for insertion (document fragment)
  const elements = createResourceHints();

  // Opportunistically apply base style
  elements.appendChild(createBaseStyle());
  if (!document.head.querySelector("meta[name=viewport]")) {
    // Make meta viewport the first element in the head.
    elements.insertBefore(createMetaViewport(), elements.firstChild);
  }

  document.head.insertBefore(elements, document.head.firstChild);

  function run$w(conf, doc, cb) {
    if (!conf.specStatus) {
      const warn = "`respecConfig.specStatus` missing. Defaulting to 'base'.";
      conf.specStatus = "base";
      pub("warn", warn);
    }

    let styleFile = "PCISIG-";

    // Figure out which style file to use.
    switch (conf.specStatus.toUpperCase()) {
      case "WG-DRAFT-NOTE":
      case "PUB-DRAFT-NOTE":
      case "WG-NOTE":
      case "PUB-NOTE":
        styleFile = "NOTE";
        break;
      case "ED":
      case "ED-CWG":
      case "ED-MEM":
      case "ED-FINAL":
        styleFile += "ED";
        break;
      case "WD":
      case "WD-CWG":
      case "WD-MEM":
      case "WD-FINAL":
        styleFile += "WD";
        break;
      case "RC":
      case "RC-CWG":
      case "RC-MEM":
      case "RC-FINAL":
        styleFile += "RC";
        break;
      case "PUB":
      case "PUB-CWG":
      case "PUB-MEM":
        styleFile += "PUB";
        break;
      case "FINAL":
        styleFile += "FINAL";
        break;
      case "UNOFFICIAL":
      case "PRIVATE":
      case "BASE":
      case "NOTE":
      case "DRAFT-NOTE":
      case "MEMBER-PRIVATE":
      case "MEMBER-SUBMISSION":
      case "TEAM-PRIVATE":
      case "TEAM-SUBMISSION":
        styleFile = "base";
        break;
      default:
        styleFile = "base";
    }

    // Select between released styles and experimental style.
    const version = selectStyleVersion(conf.useExperimentalStyles || "2017");
    // Attach PCISIG fixup script after we are done.
    if (version && !conf.noToc) {
      sub(
        "end-all",
        function () {
          attachFixupScript(doc, version);
        },
        {once: true}
      );
    }
    const finalVersionPath = version ? version + "/" : "";
    const finalStyleURL = `https://sglaser.github.io/respec/Spec/StyleSheets/${finalVersionPath}${styleFile}.css`;

    if (conf.cssOverride) {
      linkCSS(doc, conf.cssOverride);
    } else {
      linkCSS(doc, finalStyleURL);
    }
    cb();
  }

  var pcisigStyle = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$w,
    run: run$w
  });

  // @ts-check
  /**
   * core/github
   *
   * @see https://github.com/speced/respec/wiki/github
   */

  const name$v = "core/github";

  let resolveGithubPromise;
  let rejectGithubPromise;
  /** @type {Promise<{ apiBase: string, fullName: string, branch: string, repoURL: string } | null>} */
  const github = new Promise((resolve, reject) => {
    resolveGithubPromise = resolve;
    rejectGithubPromise = message => {
      showError(message, name$v);
      reject(new Error(message));
    };
  });

  const localizationStrings$c = {
    en: {
      file_a_bug: "File an issue",
      participate: "Participate:",
      commit_history: "Commit history",
    },
    ko: {
      participate: "ì°¸ì¬",
    },
    zh: {
      file_a_bug: "åé¦éè¯¯",
      participate: "åä¸ï¼",
    },
    ja: {
      commit_history: "å¤æ´å±¥æ­´",
      file_a_bug: "åé¡å ±å",
      participate: "åå æ¹æ³ï¼",
    },
    nl: {
      commit_history: "Revisiehistorie",
      file_a_bug: "Dien een melding in",
      participate: "Doe mee:",
    },
    es: {
      commit_history: "Historia de cambios",
      file_a_bug: "Nota un bug",
      participate: "Participe:",
    },
    de: {
      commit_history: "Revisionen",
      file_a_bug: "Fehler melden",
      participate: "Mitmachen:",
    },
  };
  const l10n$b = getIntlData(localizationStrings$c);

  async function run$v(conf) {
    if (!conf.hasOwnProperty("github") || !conf.github) {
      // nothing to do, bail out.
      resolveGithubPromise(null);
      return;
    }
    if (
      typeof conf.github === "object" &&
      !conf.github.hasOwnProperty("repoURL")
    ) {
      const msg = docLink`Config option ${"[github]"} is missing property \`repoURL\`.`;
      rejectGithubPromise(msg);
      return;
    }
    let tempURL = conf.github.repoURL || conf.github;
    if (!tempURL.endsWith("/")) tempURL += "/";
    /** @type URL */
    let ghURL;
    try {
      ghURL = new URL(tempURL, "https://github.com");
    } catch {
      const msg = docLink`${"[github]"} configuration option is not a valid URL? (${tempURL}).`;
      rejectGithubPromise(msg);
      return;
    }
    if (ghURL.origin !== "https://github.com") {
      const msg = docLink`${"[github]"} configuration option must be HTTPS and pointing to GitHub. (${ghURL.href}).`;
      rejectGithubPromise(msg);
      return;
    }
    const [org, repo] = ghURL.pathname.split("/").filter(item => item);
    if (!org || !repo) {
      const msg = docLink`${"[github]"} URL needs a path. For example, "w3c/my-spec".`;
      rejectGithubPromise(msg);
      return;
    }
    const branch = conf.github.branch || "gh-pages";
    const issueBase = new URL("./issues/", ghURL).href;
    const commitHistoryURL = new URL(
      `./commits/${conf.github.branch ?? ""}`,
      ghURL.href
    );
    const newProps = {
      edDraftURI: `https://${org.toLowerCase()}.github.io/${repo}/`,
      githubToken: undefined,
      githubUser: undefined,
      issueBase,
      atRiskBase: issueBase,
      otherLinks: [],
      pullBase: new URL("./pulls/", ghURL).href,
      shortName: repo,
    };
    // Assign new properties, but retain existing ones
    let githubAPI = "https://respec.org/github";
    if (conf.githubAPI) {
      if (new URL(conf.githubAPI).hostname === window.parent.location.hostname) {
        // for testing
        githubAPI = conf.githubAPI;
      } else {
        const msg =
          "The `githubAPI` configuration option is private and should not be added manually.";
        showWarning(msg, name$v);
      }
    }
    if (!conf.excludeGithubLinks) {
      const otherLink = {
        key: l10n$b.participate,
        data: [
          {
            value: `GitHub ${org}/${repo}`,
            href: ghURL,
          },
          {
            value: l10n$b.file_a_bug,
            href: newProps.issueBase,
          },
          {
            value: l10n$b.commit_history,
            href: commitHistoryURL.href,
          },
          {
            value: "Pull requests",
            href: newProps.pullBase,
          },
        ],
      };
      if (!conf.otherLinks) {
        conf.otherLinks = [];
      }
      conf.otherLinks.unshift(otherLink);
    }
    const normalizedGHObj = {
      branch,
      repoURL: ghURL.href,
      apiBase: githubAPI,
      fullName: `${org}/${repo}`,
      issuesURL: issueBase,
      pullsURL: newProps.pullBase,
      newIssuesURL: new URL("./new/choose", issueBase).href,
      commitHistoryURL: commitHistoryURL.href,
    };
    resolveGithubPromise(normalizedGHObj);

    const normalizedConfig = {
      ...newProps,
      ...conf,
      github: normalizedGHObj,
      githubAPI,
    };
    Object.assign(conf, normalizedConfig);
  }

  var github$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    github: github,
    name: name$v,
    run: run$v
  });

  /**
   * Module core/sections
   *
   * Adds <section>s to the document, based on the heading structure.
   */

  class DOMBuilder {
    constructor(doc) {
      this.doc = doc;
      this.root = doc.createDocumentFragment();
      this.stack = [this.root];
      this.current = this.root;
    }

    static sectionClasses = new Set(["appendix", "informative", "notoc"]);

    findPosition(header) {
      return parseInt(header.tagName.charAt(1), 10);
    }
    findParent(position) {
      let parent;
      while (position > 0) {
        position--;
        parent = this.stack[position];
        if (parent) return parent;
      }
    }
    findHeader({ firstChild: node }) {
      while (node) {
        if (/H[1-6]/.test(node.tagName)) {
          return node;
        }
        node = node.nextSibling;
      }
      return null;
    }

    addHeader(header) {
      const section = this.doc.createElement("section");
      const position = this.findPosition(header);

      section.appendChild(header);
      this.findParent(position).appendChild(section);
      this.stack[position] = section;
      this.stack.length = position + 1;
      this.current = section;
      this.processHeader(header, section);
    }

    processHeader(header, section) {
      DOMBuilder.sectionClasses
        .intersection(new Set(header.classList))
        .forEach(className => {
          section.classList.add(className);
        });
    }

    addSection(node) {
      const header = this.findHeader(node);
      const position = header ? this.findPosition(header) : 1;
      const parent = this.findParent(position);

      if (header) {
        node.removeChild(header);
      }

      node.appendChild(structure$1(node));

      if (header) {
        node.prepend(header);
      }

      parent.appendChild(node);
      this.current = parent;
    }

    addElement(node) {
      this.current.appendChild(node);
    }
  }
  /**
   *
   * @param {Node} fragment
   * @returns
   */
  function structure$1(fragment) {
    const builder = new DOMBuilder(fragment.ownerDocument);
    while (fragment.firstChild) {
      const node = fragment.firstChild;
      switch (node.localName) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          builder.addHeader(node);
          break;
        case "section":
          builder.addSection(node);
          break;
        default:
          builder.addElement(node);
      }
    }
    return builder.root;
  }

  /**
   * Restructure a container element adding sections if needed.
   * @param {Element} elem
   */
  function restructure(elem) {
    const structuredInternals = structure$1(elem);
    if (
      structuredInternals.firstElementChild.localName === "section" &&
      elem.localName === "section"
    ) {
      const section = structuredInternals.firstElementChild;
      section.remove();
      elem.append(...section.childNodes);
    } else {
      elem.textContent = "";
    }
    elem.appendChild(structuredInternals);
  }

  // @ts-check
  // Module core/data-include
  // Support for the data-include attribute. Causes external content to be included inside an
  // element that has data-include='some URI'. There is also a data-oninclude attribute that
  // features a white space separated list of global methods that will be called with the
  // module object, the content, and the included URI.
  //
  // IMPORTANT:
  //  This module only really works when you are in an HTTP context, and will most likely
  //  fail if you are editing your documents on your local drive. That is due to security
  //  restrictions in the browser.

  const name$u = "core/data-include";

  /**
   * @param {HTMLElement} el
   * @param {string} data
   * @param {object} options
   * @param {boolean} options.replace
   */
  function fillWithText(el, data, { replace }) {
    const { includeFormat } = el.dataset;
    let fill = data;
    if (includeFormat === "markdown") {
      fill = markdownToHtml(fill);
    }

    if (includeFormat === "text") {
      el.textContent = fill;
    } else {
      el.innerHTML = fill;
    }

    if (includeFormat === "markdown") {
      restructure(el);
    }

    if (replace) {
      el.replaceWith(...el.childNodes);
    }
  }

  /**
   * @param {string} rawData
   * @param {string} id
   * @param {string} url
   */
  function processResponse(rawData, id, url) {
    /** @type {HTMLElement} */
    const el = document.querySelector(`[data-include-id=${id}]`);
    const data = runTransforms(rawData, el.dataset.oninclude, url);
    const replace = typeof el.dataset.includeReplace === "string";
    fillWithText(el, data, { replace });
    // If still in the dom tree, clean up
    if (!replace) {
      removeIncludeAttributes(el);
    }
  }
  /**
   * Removes attributes after they are used for inclusion, if present.
   *
   * @param {Element} el The element to clean up.
   */
  function removeIncludeAttributes(el) {
    [
      "data-include",
      "data-include-format",
      "data-include-replace",
      "data-include-id",
      "oninclude",
    ].forEach(attr => el.removeAttribute(attr));
  }

  async function run$u() {
    await runIncludes(document, 1);
  }

  /**
   * @param {HTMLElement | Document} root
   * @param {number} currentDepth
   */
  async function runIncludes(root, currentDepth) {
    /** @type {NodeListOf<HTMLElement>} */
    const includables = root.querySelectorAll("[data-include]");
    const promisesToInclude = Array.from(includables).map(async el => {
      const url = el.dataset.include;
      if (!url) {
        return; // just skip it
      }
      const id = `include-${String(Math.random()).slice(2)}`;
      el.dataset.includeId = id;
      try {
        const response = await fetch(url);
        const text = await response.text();
        processResponse(text, id, url);
        if (currentDepth < 3) {
          // For performance reasons, only allow limited nesting.
          await runIncludes(el, currentDepth + 1);
        }
      } catch (err) {
        const msg = `\`data-include\` failed: \`${url}\` (${err.message}).`;
        showError(msg, name$u, { elements: [el], cause: err });
      }
    });
    await Promise.all(promisesToInclude);
  }

  var dataInclude = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$u,
    run: run$u
  });

  var hb = "(() => {\n/**!\n\n @license\n handlebars v4.7.8\n\nCopyright (C) 2011-2019 by Yehuda Katz\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Handlebars\"] = factory();\n\telse\n\t\troot[\"Handlebars\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireWildcard = __webpack_require__(1)['default'];\n\n\tvar _interopRequireDefault = __webpack_require__(2)['default'];\n\n\texports.__esModule = true;\n\n\tvar _handlebarsBase = __webpack_require__(3);\n\n\tvar base = _interopRequireWildcard(_handlebarsBase);\n\n\t// Each of these augment the Handlebars object. No need to setup here.\n\t// (This is done to easily share code between commonjs and browse envs)\n\n\tvar _handlebarsSafeString = __webpack_require__(76);\n\n\tvar _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);\n\n\tvar _handlebarsException = __webpack_require__(5);\n\n\tvar _handlebarsException2 = _interopRequireDefault(_handlebarsException);\n\n\tvar _handlebarsUtils = __webpack_require__(4);\n\n\tvar Utils = _interopRequireWildcard(_handlebarsUtils);\n\n\tvar _handlebarsRuntime = __webpack_require__(77);\n\n\tvar runtime = _interopRequireWildcard(_handlebarsRuntime);\n\n\tvar _handlebarsNoConflict = __webpack_require__(82);\n\n\tvar _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);\n\n\t// For compatibility and usage outside of module systems, make the Handlebars object a namespace\n\tfunction create() {\n\t  var hb = new base.HandlebarsEnvironment();\n\n\t  Utils.extend(hb, base);\n\t  hb.SafeString = _handlebarsSafeString2['default'];\n\t  hb.Exception = _handlebarsException2['default'];\n\t  hb.Utils = Utils;\n\t  hb.escapeExpression = Utils.escapeExpression;\n\n\t  hb.VM = runtime;\n\t  hb.template = function (spec) {\n\t    return runtime.template(spec, hb);\n\t  };\n\n\t  return hb;\n\t}\n\n\tvar inst = create();\n\tinst.create = create;\n\n\t_handlebarsNoConflict2['default'](inst);\n\n\tinst['default'] = inst;\n\n\texports['default'] = inst;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\n\texports[\"default\"] = function (obj) {\n\t  if (obj && obj.__esModule) {\n\t    return obj;\n\t  } else {\n\t    var newObj = {};\n\n\t    if (obj != null) {\n\t      for (var key in obj) {\n\t        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n\t      }\n\t    }\n\n\t    newObj[\"default\"] = obj;\n\t    return newObj;\n\t  }\n\t};\n\n\texports.__esModule = true;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\n\texports[\"default\"] = function (obj) {\n\t  return obj && obj.__esModule ? obj : {\n\t    \"default\": obj\n\t  };\n\t};\n\n\texports.__esModule = true;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireDefault = __webpack_require__(2)['default'];\n\n\texports.__esModule = true;\n\texports.HandlebarsEnvironment = HandlebarsEnvironment;\n\n\tvar _utils = __webpack_require__(4);\n\n\tvar _exception = __webpack_require__(5);\n\n\tvar _exception2 = _interopRequireDefault(_exception);\n\n\tvar _helpers = __webpack_require__(9);\n\n\tvar _decorators = __webpack_require__(69);\n\n\tvar _logger = __webpack_require__(71);\n\n\tvar _logger2 = _interopRequireDefault(_logger);\n\n\tvar _internalProtoAccess = __webpack_require__(72);\n\n\tvar VERSION = '4.7.8';\n\texports.VERSION = VERSION;\n\tvar COMPILER_REVISION = 8;\n\texports.COMPILER_REVISION = COMPILER_REVISION;\n\tvar LAST_COMPATIBLE_COMPILER_REVISION = 7;\n\n\texports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;\n\tvar REVISION_CHANGES = {\n\t  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it\n\t  2: '== 1.0.0-rc.3',\n\t  3: '== 1.0.0-rc.4',\n\t  4: '== 1.x.x',\n\t  5: '== 2.0.0-alpha.x',\n\t  6: '>= 2.0.0-beta.1',\n\t  7: '>= 4.0.0 <4.3.0',\n\t  8: '>= 4.3.0'\n\t};\n\n\texports.REVISION_CHANGES = REVISION_CHANGES;\n\tvar objectType = '[object Object]';\n\n\tfunction HandlebarsEnvironment(helpers, partials, decorators) {\n\t  this.helpers = helpers || {};\n\t  this.partials = partials || {};\n\t  this.decorators = decorators || {};\n\n\t  _helpers.registerDefaultHelpers(this);\n\t  _decorators.registerDefaultDecorators(this);\n\t}\n\n\tHandlebarsEnvironment.prototype = {\n\t  constructor: HandlebarsEnvironment,\n\n\t  logger: _logger2['default'],\n\t  log: _logger2['default'].log,\n\n\t  registerHelper: function registerHelper(name, fn) {\n\t    if (_utils.toString.call(name) === objectType) {\n\t      if (fn) {\n\t        throw new _exception2['default']('Arg not supported with multiple helpers');\n\t      }\n\t      _utils.extend(this.helpers, name);\n\t    } else {\n\t      this.helpers[name] = fn;\n\t    }\n\t  },\n\t  unregisterHelper: function unregisterHelper(name) {\n\t    delete this.helpers[name];\n\t  },\n\n\t  registerPartial: function registerPartial(name, partial) {\n\t    if (_utils.toString.call(name) === objectType) {\n\t      _utils.extend(this.partials, name);\n\t    } else {\n\t      if (typeof partial === 'undefined') {\n\t        throw new _exception2['default']('Attempting to register a partial called \"' + name + '\" as undefined');\n\t      }\n\t      this.partials[name] = partial;\n\t    }\n\t  },\n\t  unregisterPartial: function unregisterPartial(name) {\n\t    delete this.partials[name];\n\t  },\n\n\t  registerDecorator: function registerDecorator(name, fn) {\n\t    if (_utils.toString.call(name) === objectType) {\n\t      if (fn) {\n\t        throw new _exception2['default']('Arg not supported with multiple decorators');\n\t      }\n\t      _utils.extend(this.decorators, name);\n\t    } else {\n\t      this.decorators[name] = fn;\n\t    }\n\t  },\n\t  unregisterDecorator: function unregisterDecorator(name) {\n\t    delete this.decorators[name];\n\t  },\n\t  /**\n\t   * Reset the memory of illegal property accesses that have already been logged.\n\t   * @deprecated should only be used in handlebars test-cases\n\t   */\n\t  resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {\n\t    _internalProtoAccess.resetLoggedProperties();\n\t  }\n\t};\n\n\tvar log = _logger2['default'].log;\n\n\texports.log = log;\n\texports.createFrame = _utils.createFrame;\n\texports.logger = _logger2['default'];\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\texports.extend = extend;\n\texports.indexOf = indexOf;\n\texports.escapeExpression = escapeExpression;\n\texports.isEmpty = isEmpty;\n\texports.createFrame = createFrame;\n\texports.blockParams = blockParams;\n\texports.appendContextPath = appendContextPath;\n\tvar escape = {\n\t  '&': '&amp;',\n\t  '<': '&lt;',\n\t  '>': '&gt;',\n\t  '\"': '&quot;',\n\t  \"'\": '&#x27;',\n\t  '`': '&#x60;',\n\t  '=': '&#x3D;'\n\t};\n\n\tvar badChars = /[&<>\"'`=]/g,\n\t    possible = /[&<>\"'`=]/;\n\n\tfunction escapeChar(chr) {\n\t  return escape[chr];\n\t}\n\n\tfunction extend(obj /* , ...source */) {\n\t  for (var i = 1; i < arguments.length; i++) {\n\t    for (var key in arguments[i]) {\n\t      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {\n\t        obj[key] = arguments[i][key];\n\t      }\n\t    }\n\t  }\n\n\t  return obj;\n\t}\n\n\tvar toString = Object.prototype.toString;\n\n\texports.toString = toString;\n\t// Sourced from lodash\n\t// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt\n\t/* eslint-disable func-style */\n\tvar isFunction = function isFunction(value) {\n\t  return typeof value === 'function';\n\t};\n\t// fallback for older versions of Chrome and Safari\n\t/* istanbul ignore next */\n\tif (isFunction(/x/)) {\n\t  exports.isFunction = isFunction = function (value) {\n\t    return typeof value === 'function' && toString.call(value) === '[object Function]';\n\t  };\n\t}\n\texports.isFunction = isFunction;\n\n\t/* eslint-enable func-style */\n\n\t/* istanbul ignore next */\n\tvar isArray = Array.isArray || function (value) {\n\t  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;\n\t};\n\n\texports.isArray = isArray;\n\t// Older IE versions do not directly support indexOf so we must implement our own, sadly.\n\n\tfunction indexOf(array, value) {\n\t  for (var i = 0, len = array.length; i < len; i++) {\n\t    if (array[i] === value) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\n\tfunction escapeExpression(string) {\n\t  if (typeof string !== 'string') {\n\t    // don't escape SafeStrings, since they're already safe\n\t    if (string && string.toHTML) {\n\t      return string.toHTML();\n\t    } else if (string == null) {\n\t      return '';\n\t    } else if (!string) {\n\t      return string + '';\n\t    }\n\n\t    // Force a string conversion as this will be done by the append regardless and\n\t    // the regex test will do this transparently behind the scenes, causing issues if\n\t    // an object's to string has escaped characters in it.\n\t    string = '' + string;\n\t  }\n\n\t  if (!possible.test(string)) {\n\t    return string;\n\t  }\n\t  return string.replace(badChars, escapeChar);\n\t}\n\n\tfunction isEmpty(value) {\n\t  if (!value && value !== 0) {\n\t    return true;\n\t  } else if (isArray(value) && value.length === 0) {\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\n\tfunction createFrame(object) {\n\t  var frame = extend({}, object);\n\t  frame._parent = object;\n\t  return frame;\n\t}\n\n\tfunction blockParams(params, ids) {\n\t  params.path = ids;\n\t  return params;\n\t}\n\n\tfunction appendContextPath(contextPath, id) {\n\t  return (contextPath ? contextPath + '.' : '') + id;\n\t}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _Object$defineProperty = __webpack_require__(6)['default'];\n\n\texports.__esModule = true;\n\tvar errorProps = ['description', 'fileName', 'lineNumber', 'endLineNumber', 'message', 'name', 'number', 'stack'];\n\n\tfunction Exception(message, node) {\n\t  var loc = node && node.loc,\n\t      line = undefined,\n\t      endLineNumber = undefined,\n\t      column = undefined,\n\t      endColumn = undefined;\n\n\t  if (loc) {\n\t    line = loc.start.line;\n\t    endLineNumber = loc.end.line;\n\t    column = loc.start.column;\n\t    endColumn = loc.end.column;\n\n\t    message += ' - ' + line + ':' + column;\n\t  }\n\n\t  var tmp = Error.prototype.constructor.call(this, message);\n\n\t  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.\n\t  for (var idx = 0; idx < errorProps.length; idx++) {\n\t    this[errorProps[idx]] = tmp[errorProps[idx]];\n\t  }\n\n\t  /* istanbul ignore else */\n\t  if (Error.captureStackTrace) {\n\t    Error.captureStackTrace(this, Exception);\n\t  }\n\n\t  try {\n\t    if (loc) {\n\t      this.lineNumber = line;\n\t      this.endLineNumber = endLineNumber;\n\n\t      // Work around issue under safari where we can't directly set the column value\n\t      /* istanbul ignore next */\n\t      if (_Object$defineProperty) {\n\t        Object.defineProperty(this, 'column', {\n\t          value: column,\n\t          enumerable: true\n\t        });\n\t        Object.defineProperty(this, 'endColumn', {\n\t          value: endColumn,\n\t          enumerable: true\n\t        });\n\t      } else {\n\t        this.column = column;\n\t        this.endColumn = endColumn;\n\t      }\n\t    }\n\t  } catch (nop) {\n\t    /* Ignore if the browser is very particular */\n\t  }\n\t}\n\n\tException.prototype = new Error();\n\n\texports['default'] = Exception;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(7), __esModule: true };\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar $ = __webpack_require__(8);\n\tmodule.exports = function defineProperty(it, key, desc){\n\t  return $.setDesc(it, key, desc);\n\t};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\tvar $Object = Object;\n\tmodule.exports = {\n\t  create:     $Object.create,\n\t  getProto:   $Object.getPrototypeOf,\n\t  isEnum:     {}.propertyIsEnumerable,\n\t  getDesc:    $Object.getOwnPropertyDescriptor,\n\t  setDesc:    $Object.defineProperty,\n\t  setDescs:   $Object.defineProperties,\n\t  getKeys:    $Object.keys,\n\t  getNames:   $Object.getOwnPropertyNames,\n\t  getSymbols: $Object.getOwnPropertySymbols,\n\t  each:       [].forEach\n\t};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireDefault = __webpack_require__(2)['default'];\n\n\texports.__esModule = true;\n\texports.registerDefaultHelpers = registerDefaultHelpers;\n\texports.moveHelperToHooks = moveHelperToHooks;\n\n\tvar _helpersBlockHelperMissing = __webpack_require__(10);\n\n\tvar _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);\n\n\tvar _helpersEach = __webpack_require__(11);\n\n\tvar _helpersEach2 = _interopRequireDefault(_helpersEach);\n\n\tvar _helpersHelperMissing = __webpack_require__(64);\n\n\tvar _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);\n\n\tvar _helpersIf = __webpack_require__(65);\n\n\tvar _helpersIf2 = _interopRequireDefault(_helpersIf);\n\n\tvar _helpersLog = __webpack_require__(66);\n\n\tvar _helpersLog2 = _interopRequireDefault(_helpersLog);\n\n\tvar _helpersLookup = __webpack_require__(67);\n\n\tvar _helpersLookup2 = _interopRequireDefault(_helpersLookup);\n\n\tvar _helpersWith = __webpack_require__(68);\n\n\tvar _helpersWith2 = _interopRequireDefault(_helpersWith);\n\n\tfunction registerDefaultHelpers(instance) {\n\t  _helpersBlockHelperMissing2['default'](instance);\n\t  _helpersEach2['default'](instance);\n\t  _helpersHelperMissing2['default'](instance);\n\t  _helpersIf2['default'](instance);\n\t  _helpersLog2['default'](instance);\n\t  _helpersLookup2['default'](instance);\n\t  _helpersWith2['default'](instance);\n\t}\n\n\tfunction moveHelperToHooks(instance, helperName, keepHelper) {\n\t  if (instance.helpers[helperName]) {\n\t    instance.hooks[helperName] = instance.helpers[helperName];\n\t    if (!keepHelper) {\n\t      delete instance.helpers[helperName];\n\t    }\n\t  }\n\t}\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _utils = __webpack_require__(4);\n\n\texports['default'] = function (instance) {\n\t  instance.registerHelper('blockHelperMissing', function (context, options) {\n\t    var inverse = options.inverse,\n\t        fn = options.fn;\n\n\t    if (context === true) {\n\t      return fn(this);\n\t    } else if (context === false || context == null) {\n\t      return inverse(this);\n\t    } else if (_utils.isArray(context)) {\n\t      if (context.length > 0) {\n\t        if (options.ids) {\n\t          options.ids = [options.name];\n\t        }\n\n\t        return instance.helpers.each(context, options);\n\t      } else {\n\t        return inverse(this);\n\t      }\n\t    } else {\n\t      if (options.data && options.ids) {\n\t        var data = _utils.createFrame(options.data);\n\t        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);\n\t        options = { data: data };\n\t      }\n\n\t      return fn(context, options);\n\t    }\n\t  });\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _Symbol = __webpack_require__(12)['default'];\n\n\tvar _Symbol$iterator = __webpack_require__(42)['default'];\n\n\tvar _getIterator = __webpack_require__(54)['default'];\n\n\tvar _Object$keys = __webpack_require__(59)['default'];\n\n\tvar _interopRequireDefault = __webpack_require__(2)['default'];\n\n\texports.__esModule = true;\n\n\tvar _utils = __webpack_require__(4);\n\n\tvar _exception = __webpack_require__(5);\n\n\tvar _exception2 = _interopRequireDefault(_exception);\n\n\texports['default'] = function (instance) {\n\t  instance.registerHelper('each', function (context, options) {\n\t    if (!options) {\n\t      throw new _exception2['default']('Must pass iterator to #each');\n\t    }\n\n\t    var fn = options.fn,\n\t        inverse = options.inverse,\n\t        i = 0,\n\t        ret = '',\n\t        data = undefined,\n\t        contextPath = undefined;\n\n\t    if (options.data && options.ids) {\n\t      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n\t    }\n\n\t    if (_utils.isFunction(context)) {\n\t      context = context.call(this);\n\t    }\n\n\t    if (options.data) {\n\t      data = _utils.createFrame(options.data);\n\t    }\n\n\t    function execIteration(field, index, last) {\n\t      if (data) {\n\t        data.key = field;\n\t        data.index = index;\n\t        data.first = index === 0;\n\t        data.last = !!last;\n\n\t        if (contextPath) {\n\t          data.contextPath = contextPath + field;\n\t        }\n\t      }\n\n\t      ret = ret + fn(context[field], {\n\t        data: data,\n\t        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])\n\t      });\n\t    }\n\n\t    if (context && typeof context === 'object') {\n\t      if (_utils.isArray(context)) {\n\t        for (var j = context.length; i < j; i++) {\n\t          if (i in context) {\n\t            execIteration(i, i, i === context.length - 1);\n\t          }\n\t        }\n\t      } else if (typeof _Symbol === 'function' && context[_Symbol$iterator]) {\n\t        var newContext = [];\n\t        var iterator = _getIterator(context);\n\t        for (var it = iterator.next(); !it.done; it = iterator.next()) {\n\t          newContext.push(it.value);\n\t        }\n\t        context = newContext;\n\t        for (var j = context.length; i < j; i++) {\n\t          execIteration(i, i, i === context.length - 1);\n\t        }\n\t      } else {\n\t        (function () {\n\t          var priorKey = undefined;\n\n\t          _Object$keys(context).forEach(function (key) {\n\t            // We're running the iterations one step out of sync so we can detect\n\t            // the last iteration without have to scan the object twice and create\n\t            // an itermediate keys array.\n\t            if (priorKey !== undefined) {\n\t              execIteration(priorKey, i - 1);\n\t            }\n\t            priorKey = key;\n\t            i++;\n\t          });\n\t          if (priorKey !== undefined) {\n\t            execIteration(priorKey, i - 1, true);\n\t          }\n\t        })();\n\t      }\n\t    }\n\n\t    if (i === 0) {\n\t      ret = inverse(this);\n\t    }\n\n\t    return ret;\n\t  });\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(13), __esModule: true };\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(14);\n\t__webpack_require__(41);\n\tmodule.exports = __webpack_require__(20).Symbol;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// ECMAScript 6 symbols shim\n\tvar $              = __webpack_require__(8)\n\t  , global         = __webpack_require__(15)\n\t  , has            = __webpack_require__(16)\n\t  , DESCRIPTORS    = __webpack_require__(17)\n\t  , $export        = __webpack_require__(19)\n\t  , redefine       = __webpack_require__(23)\n\t  , $fails         = __webpack_require__(18)\n\t  , shared         = __webpack_require__(26)\n\t  , setToStringTag = __webpack_require__(27)\n\t  , uid            = __webpack_require__(29)\n\t  , wks            = __webpack_require__(28)\n\t  , keyOf          = __webpack_require__(30)\n\t  , $names         = __webpack_require__(35)\n\t  , enumKeys       = __webpack_require__(36)\n\t  , isArray        = __webpack_require__(37)\n\t  , anObject       = __webpack_require__(38)\n\t  , toIObject      = __webpack_require__(31)\n\t  , createDesc     = __webpack_require__(25)\n\t  , getDesc        = $.getDesc\n\t  , setDesc        = $.setDesc\n\t  , _create        = $.create\n\t  , getNames       = $names.get\n\t  , $Symbol        = global.Symbol\n\t  , $JSON          = global.JSON\n\t  , _stringify     = $JSON && $JSON.stringify\n\t  , setter         = false\n\t  , HIDDEN         = wks('_hidden')\n\t  , isEnum         = $.isEnum\n\t  , SymbolRegistry = shared('symbol-registry')\n\t  , AllSymbols     = shared('symbols')\n\t  , useNative      = typeof $Symbol == 'function'\n\t  , ObjectProto    = Object.prototype;\n\n\t// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\tvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n\t  return _create(setDesc({}, 'a', {\n\t    get: function(){ return setDesc(this, 'a', {value: 7}).a; }\n\t  })).a != 7;\n\t}) ? function(it, key, D){\n\t  var protoDesc = getDesc(ObjectProto, key);\n\t  if(protoDesc)delete ObjectProto[key];\n\t  setDesc(it, key, D);\n\t  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);\n\t} : setDesc;\n\n\tvar wrap = function(tag){\n\t  var sym = AllSymbols[tag] = _create($Symbol.prototype);\n\t  sym._k = tag;\n\t  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {\n\t    configurable: true,\n\t    set: function(value){\n\t      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n\t      setSymbolDesc(this, tag, createDesc(1, value));\n\t    }\n\t  });\n\t  return sym;\n\t};\n\n\tvar isSymbol = function(it){\n\t  return typeof it == 'symbol';\n\t};\n\n\tvar $defineProperty = function defineProperty(it, key, D){\n\t  if(D && has(AllSymbols, key)){\n\t    if(!D.enumerable){\n\t      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));\n\t      it[HIDDEN][key] = true;\n\t    } else {\n\t      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n\t      D = _create(D, {enumerable: createDesc(0, false)});\n\t    } return setSymbolDesc(it, key, D);\n\t  } return setDesc(it, key, D);\n\t};\n\tvar $defineProperties = function defineProperties(it, P){\n\t  anObject(it);\n\t  var keys = enumKeys(P = toIObject(P))\n\t    , i    = 0\n\t    , l = keys.length\n\t    , key;\n\t  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n\t  return it;\n\t};\n\tvar $create = function create(it, P){\n\t  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n\t};\n\tvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n\t  var E = isEnum.call(this, key);\n\t  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]\n\t    ? E : true;\n\t};\n\tvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n\t  var D = getDesc(it = toIObject(it), key);\n\t  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n\t  return D;\n\t};\n\tvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n\t  var names  = getNames(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);\n\t  return result;\n\t};\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n\t  var names  = getNames(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);\n\t  return result;\n\t};\n\tvar $stringify = function stringify(it){\n\t  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n\t  var args = [it]\n\t    , i    = 1\n\t    , $$   = arguments\n\t    , replacer, $replacer;\n\t  while($$.length > i)args.push($$[i++]);\n\t  replacer = args[1];\n\t  if(typeof replacer == 'function')$replacer = replacer;\n\t  if($replacer || !isArray(replacer))replacer = function(key, value){\n\t    if($replacer)value = $replacer.call(this, key, value);\n\t    if(!isSymbol(value))return value;\n\t  };\n\t  args[1] = replacer;\n\t  return _stringify.apply($JSON, args);\n\t};\n\tvar buggyJSON = $fails(function(){\n\t  var S = $Symbol();\n\t  // MS Edge converts symbol values to JSON as {}\n\t  // WebKit converts symbol values to JSON as null\n\t  // V8 throws on boxed symbols\n\t  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n\t});\n\n\t// 19.4.1.1 Symbol([description])\n\tif(!useNative){\n\t  $Symbol = function Symbol(){\n\t    if(isSymbol(this))throw TypeError('Symbol is not a constructor');\n\t    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));\n\t  };\n\t  redefine($Symbol.prototype, 'toString', function toString(){\n\t    return this._k;\n\t  });\n\n\t  isSymbol = function(it){\n\t    return it instanceof $Symbol;\n\t  };\n\n\t  $.create     = $create;\n\t  $.isEnum     = $propertyIsEnumerable;\n\t  $.getDesc    = $getOwnPropertyDescriptor;\n\t  $.setDesc    = $defineProperty;\n\t  $.setDescs   = $defineProperties;\n\t  $.getNames   = $names.get = $getOwnPropertyNames;\n\t  $.getSymbols = $getOwnPropertySymbols;\n\n\t  if(DESCRIPTORS && !__webpack_require__(40)){\n\t    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n\t  }\n\t}\n\n\tvar symbolStatics = {\n\t  // 19.4.2.1 Symbol.for(key)\n\t  'for': function(key){\n\t    return has(SymbolRegistry, key += '')\n\t      ? SymbolRegistry[key]\n\t      : SymbolRegistry[key] = $Symbol(key);\n\t  },\n\t  // 19.4.2.5 Symbol.keyFor(sym)\n\t  keyFor: function keyFor(key){\n\t    return keyOf(SymbolRegistry, key);\n\t  },\n\t  useSetter: function(){ setter = true; },\n\t  useSimple: function(){ setter = false; }\n\t};\n\t// 19.4.2.2 Symbol.hasInstance\n\t// 19.4.2.3 Symbol.isConcatSpreadable\n\t// 19.4.2.4 Symbol.iterator\n\t// 19.4.2.6 Symbol.match\n\t// 19.4.2.8 Symbol.replace\n\t// 19.4.2.9 Symbol.search\n\t// 19.4.2.10 Symbol.species\n\t// 19.4.2.11 Symbol.split\n\t// 19.4.2.12 Symbol.toPrimitive\n\t// 19.4.2.13 Symbol.toStringTag\n\t// 19.4.2.14 Symbol.unscopables\n\t$.each.call((\n\t  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +\n\t  'species,split,toPrimitive,toStringTag,unscopables'\n\t).split(','), function(it){\n\t  var sym = wks(it);\n\t  symbolStatics[it] = useNative ? sym : wrap(sym);\n\t});\n\n\tsetter = true;\n\n\t$export($export.G + $export.W, {Symbol: $Symbol});\n\n\t$export($export.S, 'Symbol', symbolStatics);\n\n\t$export($export.S + $export.F * !useNative, 'Object', {\n\t  // 19.1.2.2 Object.create(O [, Properties])\n\t  create: $create,\n\t  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n\t  defineProperty: $defineProperty,\n\t  // 19.1.2.3 Object.defineProperties(O, Properties)\n\t  defineProperties: $defineProperties,\n\t  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n\t  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n\t  // 19.1.2.7 Object.getOwnPropertyNames(O)\n\t  getOwnPropertyNames: $getOwnPropertyNames,\n\t  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n\t  getOwnPropertySymbols: $getOwnPropertySymbols\n\t});\n\n\t// 24.3.2 JSON.stringify(value [, replacer [, space]])\n\t$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});\n\n\t// 19.4.3.5 Symbol.prototype[@@toStringTag]\n\tsetToStringTag($Symbol, 'Symbol');\n\t// 20.2.1.9 Math[@@toStringTag]\n\tsetToStringTag(Math, 'Math', true);\n\t// 24.3.3 JSON[@@toStringTag]\n\tsetToStringTag(global.JSON, 'JSON', true);\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(18)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(15)\n\t  , core      = __webpack_require__(20)\n\t  , ctx       = __webpack_require__(21)\n\t  , PROTOTYPE = 'prototype';\n\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && key in target;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(param){\n\t        return this instanceof C ? new C(param) : C(param);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;  // forced\n\t$export.G = 2;  // global\n\t$export.S = 4;  // static\n\t$export.P = 8;  // proto\n\t$export.B = 16; // bind\n\t$export.W = 32; // wrap\n\tmodule.exports = $export;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\n\tvar core = module.exports = {version: '1.2.6'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(22);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(24);\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar $          = __webpack_require__(8)\n\t  , createDesc = __webpack_require__(25);\n\tmodule.exports = __webpack_require__(17) ? function(object, key, value){\n\t  return $.setDesc(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(15)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(8).setDesc\n\t  , has = __webpack_require__(16)\n\t  , TAG = __webpack_require__(28)('toStringTag');\n\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar store  = __webpack_require__(26)('wks')\n\t  , uid    = __webpack_require__(29)\n\t  , Symbol = __webpack_require__(15).Symbol;\n\tmodule.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));\n\t};\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar $         = __webpack_require__(8)\n\t  , toIObject = __webpack_require__(31);\n\tmodule.exports = function(object, el){\n\t  var O      = toIObject(object)\n\t    , keys   = $.getKeys(O)\n\t    , length = keys.length\n\t    , index  = 0\n\t    , key;\n\t  while(length > index)if(O[key = keys[index++]] === el)return key;\n\t};\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(32)\n\t  , defined = __webpack_require__(34);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(33);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports) {\n\n\tvar toString = {}.toString;\n\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar toIObject = __webpack_require__(31)\n\t  , getNames  = __webpack_require__(8).getNames\n\t  , toString  = {}.toString;\n\n\tvar windowNames = typeof window == 'object' && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\n\tvar getWindowNames = function(it){\n\t  try {\n\t    return getNames(it);\n\t  } catch(e){\n\t    return windowNames.slice();\n\t  }\n\t};\n\n\tmodule.exports.get = function getOwnPropertyNames(it){\n\t  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);\n\t  return getNames(toIObject(it));\n\t};\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// all enumerable object keys, includes symbols\n\tvar $ = __webpack_require__(8);\n\tmodule.exports = function(it){\n\t  var keys       = $.getKeys(it)\n\t    , getSymbols = $.getSymbols;\n\t  if(getSymbols){\n\t    var symbols = getSymbols(it)\n\t      , isEnum  = $.isEnum\n\t      , i       = 0\n\t      , key;\n\t    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);\n\t  }\n\t  return keys;\n\t};\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 7.2.2 IsArray(argument)\n\tvar cof = __webpack_require__(33);\n\tmodule.exports = Array.isArray || function(arg){\n\t  return cof(arg) == 'Array';\n\t};\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(39);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports) {\n\n\t\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(43), __esModule: true };\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(44);\n\t__webpack_require__(50);\n\tmodule.exports = __webpack_require__(28)('iterator');\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(45)(true);\n\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(47)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(46)\n\t  , defined   = __webpack_require__(34);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(40)\n\t  , $export        = __webpack_require__(19)\n\t  , redefine       = __webpack_require__(23)\n\t  , hide           = __webpack_require__(24)\n\t  , has            = __webpack_require__(16)\n\t  , Iterators      = __webpack_require__(48)\n\t  , $iterCreate    = __webpack_require__(49)\n\t  , setToStringTag = __webpack_require__(27)\n\t  , getProto       = __webpack_require__(8).getProto\n\t  , ITERATOR       = __webpack_require__(28)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\n\tvar returnThis = function(){ return this; };\n\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , methods, key;\n\t  // Fix native\n\t  if($native){\n\t    var IteratorPrototype = getProto($default.call(new Base));\n\t    // Set @@toStringTag to native iterators\n\t    setToStringTag(IteratorPrototype, TAG, true);\n\t    // FF fix\n\t    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    // fix Array#{values, @@iterator}.name in V8 / FF\n\t    if(DEF_VALUES && $native.name !== VALUES){\n\t      VALUES_BUG = true;\n\t      $default = function values(){ return $native.call(this); };\n\t    }\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES  ? $default : getMethod(VALUES),\n\t      keys:    IS_SET      ? $default : getMethod(KEYS),\n\t      entries: !DEF_VALUES ? $default : getMethod('entries')\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $              = __webpack_require__(8)\n\t  , descriptor     = __webpack_require__(25)\n\t  , setToStringTag = __webpack_require__(27)\n\t  , IteratorPrototype = {};\n\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(24)(IteratorPrototype, __webpack_require__(28)('iterator'), function(){ return this; });\n\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(51);\n\tvar Iterators = __webpack_require__(48);\n\tIterators.NodeList = Iterators.HTMLCollection = Iterators.Array;\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar addToUnscopables = __webpack_require__(52)\n\t  , step             = __webpack_require__(53)\n\t  , Iterators        = __webpack_require__(48)\n\t  , toIObject        = __webpack_require__(31);\n\n\t// 22.1.3.4 Array.prototype.entries()\n\t// 22.1.3.13 Array.prototype.keys()\n\t// 22.1.3.29 Array.prototype.values()\n\t// 22.1.3.30 Array.prototype[@@iterator]()\n\tmodule.exports = __webpack_require__(47)(Array, 'Array', function(iterated, kind){\n\t  this._t = toIObject(iterated); // target\n\t  this._i = 0;                   // next index\n\t  this._k = kind;                // kind\n\t// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , kind  = this._k\n\t    , index = this._i++;\n\t  if(!O || index >= O.length){\n\t    this._t = undefined;\n\t    return step(1);\n\t  }\n\t  if(kind == 'keys'  )return step(0, index);\n\t  if(kind == 'values')return step(0, O[index]);\n\t  return step(0, [index, O[index]]);\n\t}, 'values');\n\n\t// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\tIterators.Arguments = Iterators.Array;\n\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(){ /* empty */ };\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(done, value){\n\t  return {value: value, done: !!done};\n\t};\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(55), __esModule: true };\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(50);\n\t__webpack_require__(44);\n\tmodule.exports = __webpack_require__(56);\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar anObject = __webpack_require__(38)\n\t  , get      = __webpack_require__(57);\n\tmodule.exports = __webpack_require__(20).getIterator = function(it){\n\t  var iterFn = get(it);\n\t  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');\n\t  return anObject(iterFn.call(it));\n\t};\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar classof   = __webpack_require__(58)\n\t  , ITERATOR  = __webpack_require__(28)('iterator')\n\t  , Iterators = __webpack_require__(48);\n\tmodule.exports = __webpack_require__(20).getIteratorMethod = function(it){\n\t  if(it != undefined)return it[ITERATOR]\n\t    || it['@@iterator']\n\t    || Iterators[classof(it)];\n\t};\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// getting tag from 19.1.3.6 Object.prototype.toString()\n\tvar cof = __webpack_require__(33)\n\t  , TAG = __webpack_require__(28)('toStringTag')\n\t  // ES3 wrong here\n\t  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n\tmodule.exports = function(it){\n\t  var O, T, B;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T\n\t    // builtinTag case\n\t    : ARG ? cof(O)\n\t    // ES3 arguments fallback\n\t    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n\t};\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(60), __esModule: true };\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(61);\n\tmodule.exports = __webpack_require__(20).Object.keys;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 Object.keys(O)\n\tvar toObject = __webpack_require__(62);\n\n\t__webpack_require__(63)('keys', function($keys){\n\t  return function keys(it){\n\t    return $keys(toObject(it));\n\t  };\n\t});\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(34);\n\tmodule.exports = function(it){\n\t  return Object(defined(it));\n\t};\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// most Object methods by ES6 should accept primitives\n\tvar $export = __webpack_require__(19)\n\t  , core    = __webpack_require__(20)\n\t  , fails   = __webpack_require__(18);\n\tmodule.exports = function(KEY, exec){\n\t  var fn  = (core.Object || {})[KEY] || Object[KEY]\n\t    , exp = {};\n\t  exp[KEY] = exec(fn);\n\t  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n\t};\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireDefault = __webpack_require__(2)['default'];\n\n\texports.__esModule = true;\n\n\tvar _exception = __webpack_require__(5);\n\n\tvar _exception2 = _interopRequireDefault(_exception);\n\n\texports['default'] = function (instance) {\n\t  instance.registerHelper('helperMissing', function () /* [args, ]options */{\n\t    if (arguments.length === 1) {\n\t      // A missing field in a {{foo}} construct.\n\t      return undefined;\n\t    } else {\n\t      // Someone is actually trying to call something, blow up.\n\t      throw new _exception2['default']('Missing helper: \"' + arguments[arguments.length - 1].name + '\"');\n\t    }\n\t  });\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireDefault = __webpack_require__(2)['default'];\n\n\texports.__esModule = true;\n\n\tvar _utils = __webpack_require__(4);\n\n\tvar _exception = __webpack_require__(5);\n\n\tvar _exception2 = _interopRequireDefault(_exception);\n\n\texports['default'] = function (instance) {\n\t  instance.registerHelper('if', function (conditional, options) {\n\t    if (arguments.length != 2) {\n\t      throw new _exception2['default']('#if requires exactly one argument');\n\t    }\n\t    if (_utils.isFunction(conditional)) {\n\t      conditional = conditional.call(this);\n\t    }\n\n\t    // Default behavior is to render the positive path if the value is truthy and not empty.\n\t    // The `includeZero` option may be set to treat the condtional as purely not empty based on the\n\t    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n\t    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {\n\t      return options.inverse(this);\n\t    } else {\n\t      return options.fn(this);\n\t    }\n\t  });\n\n\t  instance.registerHelper('unless', function (conditional, options) {\n\t    if (arguments.length != 2) {\n\t      throw new _exception2['default']('#unless requires exactly one argument');\n\t    }\n\t    return instance.helpers['if'].call(this, conditional, {\n\t      fn: options.inverse,\n\t      inverse: options.fn,\n\t      hash: options.hash\n\t    });\n\t  });\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\texports['default'] = function (instance) {\n\t  instance.registerHelper('log', function () /* message, options */{\n\t    var args = [undefined],\n\t        options = arguments[arguments.length - 1];\n\t    for (var i = 0; i < arguments.length - 1; i++) {\n\t      args.push(arguments[i]);\n\t    }\n\n\t    var level = 1;\n\t    if (options.hash.level != null) {\n\t      level = options.hash.level;\n\t    } else if (options.data && options.data.level != null) {\n\t      level = options.data.level;\n\t    }\n\t    args[0] = level;\n\n\t    instance.log.apply(instance, args);\n\t  });\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\texports['default'] = function (instance) {\n\t  instance.registerHelper('lookup', function (obj, field, options) {\n\t    if (!obj) {\n\t      // Note for 5.0: Change to \"obj == null\" in 5.0\n\t      return obj;\n\t    }\n\t    return options.lookupProperty(obj, field);\n\t  });\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireDefault = __webpack_require__(2)['default'];\n\n\texports.__esModule = true;\n\n\tvar _utils = __webpack_require__(4);\n\n\tvar _exception = __webpack_require__(5);\n\n\tvar _exception2 = _interopRequireDefault(_exception);\n\n\texports['default'] = function (instance) {\n\t  instance.registerHelper('with', function (context, options) {\n\t    if (arguments.length != 2) {\n\t      throw new _exception2['default']('#with requires exactly one argument');\n\t    }\n\t    if (_utils.isFunction(context)) {\n\t      context = context.call(this);\n\t    }\n\n\t    var fn = options.fn;\n\n\t    if (!_utils.isEmpty(context)) {\n\t      var data = options.data;\n\t      if (options.data && options.ids) {\n\t        data = _utils.createFrame(options.data);\n\t        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);\n\t      }\n\n\t      return fn(context, {\n\t        data: data,\n\t        blockParams: _utils.blockParams([context], [data && data.contextPath])\n\t      });\n\t    } else {\n\t      return options.inverse(this);\n\t    }\n\t  });\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _interopRequireDefault = __webpack_require__(2)['default'];\n\n\texports.__esModule = true;\n\texports.registerDefaultDecorators = registerDefaultDecorators;\n\n\tvar _decoratorsInline = __webpack_require__(70);\n\n\tvar _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);\n\n\tfunction registerDefaultDecorators(instance) {\n\t  _decoratorsInline2['default'](instance);\n\t}\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _utils = __webpack_require__(4);\n\n\texports['default'] = function (instance) {\n\t  instance.registerDecorator('inline', function (fn, props, container, options) {\n\t    var ret = fn;\n\t    if (!props.partials) {\n\t      props.partials = {};\n\t      ret = function (context, options) {\n\t        // Create a new partials stack frame prior to exec.\n\t        var original = container.partials;\n\t        container.partials = _utils.extend({}, original, props.partials);\n\t        var ret = fn(context, options);\n\t        container.partials = original;\n\t        return ret;\n\t      };\n\t    }\n\n\t    props.partials[options.args[0]] = options.fn;\n\n\t    return ret;\n\t  });\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _utils = __webpack_require__(4);\n\n\tvar logger = {\n\t  methodMap: ['debug', 'info', 'warn', 'error'],\n\t  level: 'info',\n\n\t  // Maps a given level value to the `methodMap` indexes above.\n\t  lookupLevel: function lookupLevel(level) {\n\t    if (typeof level === 'string') {\n\t      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());\n\t      if (levelMap >= 0) {\n\t        level = levelMap;\n\t      } else {\n\t        level = parseInt(level, 10);\n\t      }\n\t    }\n\n\t    return level;\n\t  },\n\n\t  // Can be overridden in the host environment\n\t  log: function log(level) {\n\t    level = logger.lookupLevel(level);\n\n\t    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {\n\t      var method = logger.methodMap[level];\n\t      // eslint-disable-next-line no-console\n\t      if (!console[method]) {\n\t        method = 'log';\n\t      }\n\n\t      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        message[_key - 1] = arguments[_key];\n\t      }\n\n\t      console[method].apply(console, message); // eslint-disable-line no-console\n\t    }\n\t  }\n\t};\n\n\texports['default'] = logger;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _Object$create = __webpack_require__(73)['default'];\n\n\tvar _Object$keys = __webpack_require__(59)['default'];\n\n\tvar _interopRequireDefault = __webpack_require__(2)['default'];\n\n\texports.__esModule = true;\n\texports.createProtoAccessControl = createProtoAccessControl;\n\texports.resultIsAllowed = resultIsAllowed;\n\texports.resetLoggedProperties = resetLoggedProperties;\n\n\tvar _createNewLookupObject = __webpack_require__(75);\n\n\tvar _logger = __webpack_require__(71);\n\n\tvar _logger2 = _interopRequireDefault(_logger);\n\n\tvar loggedProperties = _Object$create(null);\n\n\tfunction createProtoAccessControl(runtimeOptions) {\n\t  var defaultMethodWhiteList = _Object$create(null);\n\t  defaultMethodWhiteList['constructor'] = false;\n\t  defaultMethodWhiteList['__defineGetter__'] = false;\n\t  defaultMethodWhiteList['__defineSetter__'] = false;\n\t  defaultMethodWhiteList['__lookupGetter__'] = false;\n\n\t  var defaultPropertyWhiteList = _Object$create(null);\n\t  // eslint-disable-next-line no-proto\n\t  defaultPropertyWhiteList['__proto__'] = false;\n\n\t  return {\n\t    properties: {\n\t      whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),\n\t      defaultValue: runtimeOptions.allowProtoPropertiesByDefault\n\t    },\n\t    methods: {\n\t      whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),\n\t      defaultValue: runtimeOptions.allowProtoMethodsByDefault\n\t    }\n\t  };\n\t}\n\n\tfunction resultIsAllowed(result, protoAccessControl, propertyName) {\n\t  if (typeof result === 'function') {\n\t    return checkWhiteList(protoAccessControl.methods, propertyName);\n\t  } else {\n\t    return checkWhiteList(protoAccessControl.properties, propertyName);\n\t  }\n\t}\n\n\tfunction checkWhiteList(protoAccessControlForType, propertyName) {\n\t  if (protoAccessControlForType.whitelist[propertyName] !== undefined) {\n\t    return protoAccessControlForType.whitelist[propertyName] === true;\n\t  }\n\t  if (protoAccessControlForType.defaultValue !== undefined) {\n\t    return protoAccessControlForType.defaultValue;\n\t  }\n\t  logUnexpecedPropertyAccessOnce(propertyName);\n\t  return false;\n\t}\n\n\tfunction logUnexpecedPropertyAccessOnce(propertyName) {\n\t  if (loggedProperties[propertyName] !== true) {\n\t    loggedProperties[propertyName] = true;\n\t    _logger2['default'].log('error', 'Handlebars: Access has been denied to resolve the property \"' + propertyName + '\" because it is not an \"own property\" of its parent.\\n' + 'You can add a runtime option to disable the check or this warning:\\n' + 'See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');\n\t  }\n\t}\n\n\tfunction resetLoggedProperties() {\n\t  _Object$keys(loggedProperties).forEach(function (propertyName) {\n\t    delete loggedProperties[propertyName];\n\t  });\n\t}\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(74), __esModule: true };\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar $ = __webpack_require__(8);\n\tmodule.exports = function create(P, D){\n\t  return $.create(P, D);\n\t};\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _Object$create = __webpack_require__(73)['default'];\n\n\texports.__esModule = true;\n\texports.createNewLookupObject = createNewLookupObject;\n\n\tvar _utils = __webpack_require__(4);\n\n\t/**\n\t * Create a new object with \"null\"-prototype to avoid truthy results on prototype properties.\n\t * The resulting object can be used with \"object[property]\" to check if a property exists\n\t * @param {...object} sources a varargs parameter of source objects that will be merged\n\t * @returns {object}\n\t */\n\n\tfunction createNewLookupObject() {\n\t  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n\t    sources[_key] = arguments[_key];\n\t  }\n\n\t  return _utils.extend.apply(undefined, [_Object$create(null)].concat(sources));\n\t}\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports) {\n\n\t// Build out our basic SafeString type\n\t'use strict';\n\n\texports.__esModule = true;\n\tfunction SafeString(string) {\n\t  this.string = string;\n\t}\n\n\tSafeString.prototype.toString = SafeString.prototype.toHTML = function () {\n\t  return '' + this.string;\n\t};\n\n\texports['default'] = SafeString;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _Object$seal = __webpack_require__(78)['default'];\n\n\tvar _Object$keys = __webpack_require__(59)['default'];\n\n\tvar _interopRequireWildcard = __webpack_require__(1)['default'];\n\n\tvar _interopRequireDefault = __webpack_require__(2)['default'];\n\n\texports.__esModule = true;\n\texports.checkRevision = checkRevision;\n\texports.template = template;\n\texports.wrapProgram = wrapProgram;\n\texports.resolvePartial = resolvePartial;\n\texports.invokePartial = invokePartial;\n\texports.noop = noop;\n\n\tvar _utils = __webpack_require__(4);\n\n\tvar Utils = _interopRequireWildcard(_utils);\n\n\tvar _exception = __webpack_require__(5);\n\n\tvar _exception2 = _interopRequireDefault(_exception);\n\n\tvar _base = __webpack_require__(3);\n\n\tvar _helpers = __webpack_require__(9);\n\n\tvar _internalWrapHelper = __webpack_require__(81);\n\n\tvar _internalProtoAccess = __webpack_require__(72);\n\n\tfunction checkRevision(compilerInfo) {\n\t  var compilerRevision = compilerInfo && compilerInfo[0] || 1,\n\t      currentRevision = _base.COMPILER_REVISION;\n\n\t  if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {\n\t    return;\n\t  }\n\n\t  if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {\n\t    var runtimeVersions = _base.REVISION_CHANGES[currentRevision],\n\t        compilerVersions = _base.REVISION_CHANGES[compilerRevision];\n\t    throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');\n\t  } else {\n\t    // Use the embedded version info since the runtime doesn't know about this revision yet\n\t    throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');\n\t  }\n\t}\n\n\tfunction template(templateSpec, env) {\n\t  /* istanbul ignore next */\n\t  if (!env) {\n\t    throw new _exception2['default']('No environment passed to template');\n\t  }\n\t  if (!templateSpec || !templateSpec.main) {\n\t    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);\n\t  }\n\n\t  templateSpec.main.decorator = templateSpec.main_d;\n\n\t  // Note: Using env.VM references rather than local var references throughout this section to allow\n\t  // for external users to override these as pseudo-supported APIs.\n\t  env.VM.checkRevision(templateSpec.compiler);\n\n\t  // backwards compatibility for precompiled templates with compiler-version 7 (<4.3.0)\n\t  var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;\n\n\t  function invokePartialWrapper(partial, context, options) {\n\t    if (options.hash) {\n\t      context = Utils.extend({}, context, options.hash);\n\t      if (options.ids) {\n\t        options.ids[0] = true;\n\t      }\n\t    }\n\t    partial = env.VM.resolvePartial.call(this, partial, context, options);\n\n\t    var extendedOptions = Utils.extend({}, options, {\n\t      hooks: this.hooks,\n\t      protoAccessControl: this.protoAccessControl\n\t    });\n\n\t    var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);\n\n\t    if (result == null && env.compile) {\n\t      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);\n\t      result = options.partials[options.name](context, extendedOptions);\n\t    }\n\t    if (result != null) {\n\t      if (options.indent) {\n\t        var lines = result.split('\\n');\n\t        for (var i = 0, l = lines.length; i < l; i++) {\n\t          if (!lines[i] && i + 1 === l) {\n\t            break;\n\t          }\n\n\t          lines[i] = options.indent + lines[i];\n\t        }\n\t        result = lines.join('\\n');\n\t      }\n\t      return result;\n\t    } else {\n\t      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');\n\t    }\n\t  }\n\n\t  // Just add water\n\t  var container = {\n\t    strict: function strict(obj, name, loc) {\n\t      if (!obj || !(name in obj)) {\n\t        throw new _exception2['default']('\"' + name + '\" not defined in ' + obj, {\n\t          loc: loc\n\t        });\n\t      }\n\t      return container.lookupProperty(obj, name);\n\t    },\n\t    lookupProperty: function lookupProperty(parent, propertyName) {\n\t      var result = parent[propertyName];\n\t      if (result == null) {\n\t        return result;\n\t      }\n\t      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n\t        return result;\n\t      }\n\n\t      if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {\n\t        return result;\n\t      }\n\t      return undefined;\n\t    },\n\t    lookup: function lookup(depths, name) {\n\t      var len = depths.length;\n\t      for (var i = 0; i < len; i++) {\n\t        var result = depths[i] && container.lookupProperty(depths[i], name);\n\t        if (result != null) {\n\t          return depths[i][name];\n\t        }\n\t      }\n\t    },\n\t    lambda: function lambda(current, context) {\n\t      return typeof current === 'function' ? current.call(context) : current;\n\t    },\n\n\t    escapeExpression: Utils.escapeExpression,\n\t    invokePartial: invokePartialWrapper,\n\n\t    fn: function fn(i) {\n\t      var ret = templateSpec[i];\n\t      ret.decorator = templateSpec[i + '_d'];\n\t      return ret;\n\t    },\n\n\t    programs: [],\n\t    program: function program(i, data, declaredBlockParams, blockParams, depths) {\n\t      var programWrapper = this.programs[i],\n\t          fn = this.fn(i);\n\t      if (data || depths || blockParams || declaredBlockParams) {\n\t        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);\n\t      } else if (!programWrapper) {\n\t        programWrapper = this.programs[i] = wrapProgram(this, i, fn);\n\t      }\n\t      return programWrapper;\n\t    },\n\n\t    data: function data(value, depth) {\n\t      while (value && depth--) {\n\t        value = value._parent;\n\t      }\n\t      return value;\n\t    },\n\t    mergeIfNeeded: function mergeIfNeeded(param, common) {\n\t      var obj = param || common;\n\n\t      if (param && common && param !== common) {\n\t        obj = Utils.extend({}, common, param);\n\t      }\n\n\t      return obj;\n\t    },\n\t    // An empty object to use as replacement for null-contexts\n\t    nullContext: _Object$seal({}),\n\n\t    noop: env.VM.noop,\n\t    compilerInfo: templateSpec.compiler\n\t  };\n\n\t  function ret(context) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t    var data = options.data;\n\n\t    ret._setup(options);\n\t    if (!options.partial && templateSpec.useData) {\n\t      data = initData(context, data);\n\t    }\n\t    var depths = undefined,\n\t        blockParams = templateSpec.useBlockParams ? [] : undefined;\n\t    if (templateSpec.useDepths) {\n\t      if (options.depths) {\n\t        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;\n\t      } else {\n\t        depths = [context];\n\t      }\n\t    }\n\n\t    function main(context /*, options*/) {\n\t      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);\n\t    }\n\n\t    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);\n\t    return main(context, options);\n\t  }\n\n\t  ret.isTop = true;\n\n\t  ret._setup = function (options) {\n\t    if (!options.partial) {\n\t      var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);\n\t      wrapHelpersToPassLookupProperty(mergedHelpers, container);\n\t      container.helpers = mergedHelpers;\n\n\t      if (templateSpec.usePartial) {\n\t        // Use mergeIfNeeded here to prevent compiling global partials multiple times\n\t        container.partials = container.mergeIfNeeded(options.partials, env.partials);\n\t      }\n\t      if (templateSpec.usePartial || templateSpec.useDecorators) {\n\t        container.decorators = Utils.extend({}, env.decorators, options.decorators);\n\t      }\n\n\t      container.hooks = {};\n\t      container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);\n\n\t      var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;\n\t      _helpers.moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);\n\t      _helpers.moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);\n\t    } else {\n\t      container.protoAccessControl = options.protoAccessControl; // internal option\n\t      container.helpers = options.helpers;\n\t      container.partials = options.partials;\n\t      container.decorators = options.decorators;\n\t      container.hooks = options.hooks;\n\t    }\n\t  };\n\n\t  ret._child = function (i, data, blockParams, depths) {\n\t    if (templateSpec.useBlockParams && !blockParams) {\n\t      throw new _exception2['default']('must pass block params');\n\t    }\n\t    if (templateSpec.useDepths && !depths) {\n\t      throw new _exception2['default']('must pass parent depths');\n\t    }\n\n\t    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);\n\t  };\n\t  return ret;\n\t}\n\n\tfunction wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {\n\t  function prog(context) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t    var currentDepths = depths;\n\t    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {\n\t      currentDepths = [context].concat(depths);\n\t    }\n\n\t    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);\n\t  }\n\n\t  prog = executeDecorators(fn, prog, container, depths, data, blockParams);\n\n\t  prog.program = i;\n\t  prog.depth = depths ? depths.length : 0;\n\t  prog.blockParams = declaredBlockParams || 0;\n\t  return prog;\n\t}\n\n\t/**\n\t * This is currently part of the official API, therefore implementation details should not be changed.\n\t */\n\n\tfunction resolvePartial(partial, context, options) {\n\t  if (!partial) {\n\t    if (options.name === '@partial-block') {\n\t      partial = options.data['partial-block'];\n\t    } else {\n\t      partial = options.partials[options.name];\n\t    }\n\t  } else if (!partial.call && !options.name) {\n\t    // This is a dynamic partial that returned a string\n\t    options.name = partial;\n\t    partial = options.partials[partial];\n\t  }\n\t  return partial;\n\t}\n\n\tfunction invokePartial(partial, context, options) {\n\t  // Use the current closure context to save the partial-block if this partial\n\t  var currentPartialBlock = options.data && options.data['partial-block'];\n\t  options.partial = true;\n\t  if (options.ids) {\n\t    options.data.contextPath = options.ids[0] || options.data.contextPath;\n\t  }\n\n\t  var partialBlock = undefined;\n\t  if (options.fn && options.fn !== noop) {\n\t    (function () {\n\t      options.data = _base.createFrame(options.data);\n\t      // Wrapper function to get access to currentPartialBlock from the closure\n\t      var fn = options.fn;\n\t      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {\n\t        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t        // Restore the partial-block from the closure for the execution of the block\n\t        // i.e. the part inside the block of the partial call.\n\t        options.data = _base.createFrame(options.data);\n\t        options.data['partial-block'] = currentPartialBlock;\n\t        return fn(context, options);\n\t      };\n\t      if (fn.partials) {\n\t        options.partials = Utils.extend({}, options.partials, fn.partials);\n\t      }\n\t    })();\n\t  }\n\n\t  if (partial === undefined && partialBlock) {\n\t    partial = partialBlock;\n\t  }\n\n\t  if (partial === undefined) {\n\t    throw new _exception2['default']('The partial ' + options.name + ' could not be found');\n\t  } else if (partial instanceof Function) {\n\t    return partial(context, options);\n\t  }\n\t}\n\n\tfunction noop() {\n\t  return '';\n\t}\n\n\tfunction initData(context, data) {\n\t  if (!data || !('root' in data)) {\n\t    data = data ? _base.createFrame(data) : {};\n\t    data.root = context;\n\t  }\n\t  return data;\n\t}\n\n\tfunction executeDecorators(fn, prog, container, depths, data, blockParams) {\n\t  if (fn.decorator) {\n\t    var props = {};\n\t    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);\n\t    Utils.extend(prog, props);\n\t  }\n\t  return prog;\n\t}\n\n\tfunction wrapHelpersToPassLookupProperty(mergedHelpers, container) {\n\t  _Object$keys(mergedHelpers).forEach(function (helperName) {\n\t    var helper = mergedHelpers[helperName];\n\t    mergedHelpers[helperName] = passLookupPropertyOption(helper, container);\n\t  });\n\t}\n\n\tfunction passLookupPropertyOption(helper, container) {\n\t  var lookupProperty = container.lookupProperty;\n\t  return _internalWrapHelper.wrapHelper(helper, function (options) {\n\t    return Utils.extend({ lookupProperty: lookupProperty }, options);\n\t  });\n\t}\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(79), __esModule: true };\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(80);\n\tmodule.exports = __webpack_require__(20).Object.seal;\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.17 Object.seal(O)\n\tvar isObject = __webpack_require__(39);\n\n\t__webpack_require__(63)('seal', function($seal){\n\t  return function seal(it){\n\t    return $seal && isObject(it) ? $seal(it) : it;\n\t  };\n\t});\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\texports.wrapHelper = wrapHelper;\n\n\tfunction wrapHelper(helper, transformOptionsFn) {\n\t  if (typeof helper !== 'function') {\n\t    // This should not happen, but apparently it does in https://github.com/wycats/handlebars.js/issues/1639\n\t    // We try to make the wrapper least-invasive by not wrapping it, if the helper is not a function.\n\t    return helper;\n\t  }\n\t  var wrapper = function wrapper() /* dynamic arguments */{\n\t    var options = arguments[arguments.length - 1];\n\t    arguments[arguments.length - 1] = transformOptionsFn(options);\n\t    return helper.apply(this, arguments);\n\t  };\n\t  return wrapper;\n\t}\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports) {\n\n\t/* global globalThis */\n\t'use strict';\n\n\texports.__esModule = true;\n\n\texports['default'] = function (Handlebars) {\n\t  /* istanbul ignore next */\n\t  // https://mathiasbynens.be/notes/globalthis\n\t  (function () {\n\t    if (typeof globalThis === 'object') return;\n\t    Object.prototype.__defineGetter__('__magic__', function () {\n\t      return this;\n\t    });\n\t    __magic__.globalThis = __magic__; // eslint-disable-line no-undef\n\t    delete Object.prototype.__magic__;\n\t  })();\n\n\t  var $Handlebars = globalThis.Handlebars;\n\n\t  /* istanbul ignore next */\n\t  Handlebars.noConflict = function () {\n\t    if (globalThis.Handlebars === Handlebars) {\n\t      globalThis.Handlebars = $Handlebars;\n\t    }\n\t    return Handlebars;\n\t  };\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ })\n/******/ ])\n});\n;})()";

  (function() {
    var template = hb.template, templates = hb.templates = hb.templates || {};
  templates['attribute.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression((lookupProperty(helpers,"escapeAttributeName")||(depth0 && lookupProperty(depth0,"escapeAttributeName"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1),{"name":"escapeAttributeName","hash":{},"data":data,"loc":{"start":{"line":3,"column":47},"end":{"line":3,"column":79}}}));
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), alias4=container.hooks.helperMissing, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlAttribute' id=\""
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"idlId") : stack1), depth0))
      + "\" data-idl data-title='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0))
      + "'>"
      + alias2((lookupProperty(helpers,"extAttr")||(depth0 && lookupProperty(depth0,"extAttr"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"extAttr","hash":{},"data":data,"loc":{"start":{"line":1,"column":81},"end":{"line":2,"column":2}}}))
      + alias2((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":2,"column":2},"end":{"line":2,"column":16}}}))
      + alias2(((helper = (helper = lookupProperty(helpers,"qualifiers") || (depth0 != null ? lookupProperty(depth0,"qualifiers") : depth0)) != null ? helper : alias4),(typeof helper === "function" ? helper.call(alias3,{"name":"qualifiers","hash":{},"data":data,"loc":{"start":{"line":2,"column":16},"end":{"line":2,"column":30}}}) : helper)))
      + "attribute <span class='idlAttrType'>"
      + alias2((lookupProperty(helpers,"idlType")||(depth0 && lookupProperty(depth0,"idlType"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"idlType","hash":{},"data":data,"loc":{"start":{"line":2,"column":66},"end":{"line":2,"column":81}}}))
      + "</span> "
      + alias2((lookupProperty(helpers,"pads")||(depth0 && lookupProperty(depth0,"pads"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"pad") : depth0),{"name":"pads","hash":{},"data":data,"loc":{"start":{"line":2,"column":89},"end":{"line":3,"column":5}}}))
      + "<span class='idlAttrName'>"
      + ((stack1 = (lookupProperty(helpers,"tryLink")||(depth0 && lookupProperty(depth0,"tryLink"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"tryLink","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":3,"column":31},"end":{"line":3,"column":91}}})) != null ? stack1 : "")
      + "</span>;</span>\r\n";
  },"useData":true});
  templates['callback.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0));
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), alias4=container.hooks.helperMissing, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlCallback' id='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"idlId") : stack1), depth0))
      + "' data-idl data-title='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0))
      + "'>"
      + alias2((lookupProperty(helpers,"extAttr")||(depth0 && lookupProperty(depth0,"extAttr"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"extAttr","hash":{},"data":data,"loc":{"start":{"line":1,"column":80},"end":{"line":2,"column":2}}}))
      + alias2((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":2,"column":2},"end":{"line":2,"column":16}}}))
      + "callback <span class='idlCallbackID'>"
      + ((stack1 = (lookupProperty(helpers,"tryLink")||(depth0 && lookupProperty(depth0,"tryLink"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"tryLink","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":53},"end":{"line":3,"column":14}}})) != null ? stack1 : "")
      + "</span> = <span class='idlCallbackType'>"
      + alias2((lookupProperty(helpers,"idlType")||(depth0 && lookupProperty(depth0,"idlType"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"idlType","hash":{},"data":data,"loc":{"start":{"line":3,"column":54},"end":{"line":3,"column":69}}}))
      + "</span> ("
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"children") || (depth0 != null ? lookupProperty(depth0,"children") : depth0)) != null ? helper : alias4),(typeof helper === "function" ? helper.call(alias3,{"name":"children","hash":{},"data":data,"loc":{"start":{"line":3,"column":78},"end":{"line":3,"column":92}}}) : helper))) != null ? stack1 : "")
      + ");</span>";
  },"useData":true});
  templates['const.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0));
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), alias4=container.hooks.helperMissing, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlConst' id=\""
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"idlId") : stack1), depth0))
      + "\" data-idl data-title='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0))
      + "'>"
      + alias2((lookupProperty(helpers,"extAttr")||(depth0 && lookupProperty(depth0,"extAttr"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"extAttr","hash":{},"data":data,"loc":{"start":{"line":1,"column":77},"end":{"line":2,"column":2}}}))
      + alias2((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":2,"column":2},"end":{"line":2,"column":16}}}))
      + "const <span class='idlConstType'>"
      + alias2((lookupProperty(helpers,"idlType")||(depth0 && lookupProperty(depth0,"idlType"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"idlType","hash":{},"data":data,"loc":{"start":{"line":2,"column":49},"end":{"line":2,"column":64}}}))
      + "</span>"
      + alias2(((helper = (helper = lookupProperty(helpers,"nullable") || (depth0 != null ? lookupProperty(depth0,"nullable") : depth0)) != null ? helper : alias4),(typeof helper === "function" ? helper.call(alias3,{"name":"nullable","hash":{},"data":data,"loc":{"start":{"line":2,"column":71},"end":{"line":2,"column":83}}}) : helper)))
      + " "
      + alias2((lookupProperty(helpers,"pads")||(depth0 && lookupProperty(depth0,"pads"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"pad") : depth0),{"name":"pads","hash":{},"data":data,"loc":{"start":{"line":2,"column":84},"end":{"line":3,"column":2}}}))
      + "<span class='idlConstName'>"
      + ((stack1 = (lookupProperty(helpers,"tryLink")||(depth0 && lookupProperty(depth0,"tryLink"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"tryLink","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":3,"column":29},"end":{"line":4,"column":14}}})) != null ? stack1 : "")
      + "</span> = <span class='idlConstValue'>"
      + alias2((lookupProperty(helpers,"stringifyIdlConst")||(depth0 && lookupProperty(depth0,"stringifyIdlConst"))||alias4).call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"value") : stack1),{"name":"stringifyIdlConst","hash":{},"data":data,"loc":{"start":{"line":4,"column":52},"end":{"line":4,"column":83}}}))
      + "</span>;</span>\r\n";
  },"useData":true});
  templates['dict-member.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0));
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return " = <span class='idlMemberValue'>"
      + container.escapeExpression((lookupProperty(helpers,"stringifyIdlConst")||(depth0 && lookupProperty(depth0,"stringifyIdlConst"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"default") : stack1),{"name":"stringifyIdlConst","hash":{},"data":data,"loc":{"start":{"line":4,"column":34},"end":{"line":4,"column":67}}}))
      + "</span>";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), alias4=container.hooks.helperMissing, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlMember' id=\""
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"idlId") : stack1), depth0))
      + "\" data-idl data-title='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0))
      + "'>"
      + alias2((lookupProperty(helpers,"extAttr")||(depth0 && lookupProperty(depth0,"extAttr"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"extAttr","hash":{},"data":data,"loc":{"start":{"line":1,"column":78},"end":{"line":2,"column":2}}}))
      + alias2((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":2,"column":2},"end":{"line":2,"column":16}}}))
      + alias2(((helper = (helper = lookupProperty(helpers,"qualifiers") || (depth0 != null ? lookupProperty(depth0,"qualifiers") : depth0)) != null ? helper : alias4),(typeof helper === "function" ? helper.call(alias3,{"name":"qualifiers","hash":{},"data":data,"loc":{"start":{"line":2,"column":16},"end":{"line":2,"column":30}}}) : helper)))
      + "<span class='idlMemberType'>"
      + alias2((lookupProperty(helpers,"idlType")||(depth0 && lookupProperty(depth0,"idlType"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"idlType","hash":{},"data":data,"loc":{"start":{"line":2,"column":58},"end":{"line":2,"column":73}}}))
      + "</span> "
      + alias2((lookupProperty(helpers,"pads")||(depth0 && lookupProperty(depth0,"pads"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"typePad") : depth0),{"name":"pads","hash":{},"data":data,"loc":{"start":{"line":2,"column":81},"end":{"line":3,"column":2}}}))
      + "<span class='idlMemberName'>"
      + ((stack1 = (lookupProperty(helpers,"tryLink")||(depth0 && lookupProperty(depth0,"tryLink"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"tryLink","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":3,"column":30},"end":{"line":3,"column":70}}})) != null ? stack1 : "")
      + "</span>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"default") : stack1),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":3,"column":77},"end":{"line":4,"column":81}}})) != null ? stack1 : "")
      + ";</span>\r\n";
  },"useData":true});
  templates['dictionary.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0));
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return " : <span class='idlSuperclass'><a>"
      + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"inheritance") : stack1), depth0))
      + "</a></span>";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), alias4=container.hooks.helperMissing, alias5="function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlDictionary' id='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"idlId") : stack1), depth0))
      + "' data-idl data-title='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0))
      + "'>"
      + alias2((lookupProperty(helpers,"extAttr")||(depth0 && lookupProperty(depth0,"extAttr"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"extAttr","hash":{},"data":data,"loc":{"start":{"line":1,"column":82},"end":{"line":2,"column":2}}}))
      + alias2((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":2,"column":2},"end":{"line":2,"column":16}}}))
      + alias2(((helper = (helper = lookupProperty(helpers,"partial") || (depth0 != null ? lookupProperty(depth0,"partial") : depth0)) != null ? helper : alias4),(typeof helper === alias5 ? helper.call(alias3,{"name":"partial","hash":{},"data":data,"loc":{"start":{"line":2,"column":16},"end":{"line":2,"column":27}}}) : helper)))
      + "dictionary <span class='idlDictionaryID'>"
      + ((stack1 = (lookupProperty(helpers,"tryLink")||(depth0 && lookupProperty(depth0,"tryLink"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"tryLink","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":68},"end":{"line":3,"column":2}}})) != null ? stack1 : "")
      + "</span>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"inheritance") : stack1),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":3,"column":9},"end":{"line":3,"column":103}}})) != null ? stack1 : "")
      + " &#123;\r\n"
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"children") || (depth0 != null ? lookupProperty(depth0,"children") : depth0)) != null ? helper : alias4),(typeof helper === alias5 ? helper.call(alias3,{"name":"children","hash":{},"data":data,"loc":{"start":{"line":4,"column":0},"end":{"line":4,"column":14}}}) : helper))) != null ? stack1 : "")
      + "&#125;;</span>";
  },"useData":true});
  templates['enum-item.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      return ",";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3=container.escapeExpression, alias4="function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return alias3((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias2).call(alias1,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":1,"column":0},"end":{"line":1,"column":14}}}))
      + "<a href=\"#dom-"
      + alias3(((helper = (helper = lookupProperty(helpers,"parentID") || (depth0 != null ? lookupProperty(depth0,"parentID") : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"parentID","hash":{},"data":data,"loc":{"start":{"line":1,"column":28},"end":{"line":1,"column":40}}}) : helper)))
      + "-"
      + alias3(((helper = (helper = lookupProperty(helpers,"lname") || (depth0 != null ? lookupProperty(depth0,"lname") : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"lname","hash":{},"data":data,"loc":{"start":{"line":1,"column":41},"end":{"line":1,"column":50}}}) : helper)))
      + "\" class=\"idlEnumItem\">\""
      + alias3(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"name","hash":{},"data":data,"loc":{"start":{"line":1,"column":73},"end":{"line":1,"column":81}}}) : helper)))
      + "\"</a>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"needsComma") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":1,"column":86},"end":{"line":1,"column":112}}})) != null ? stack1 : "")
      + "\r\n";
  },"useData":true});
  templates['enum.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0));
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), alias4=container.hooks.helperMissing, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlEnum' id='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"idlId") : stack1), depth0))
      + "' data-idl data-title='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0))
      + "'>"
      + alias2((lookupProperty(helpers,"extAttr")||(depth0 && lookupProperty(depth0,"extAttr"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"extAttr","hash":{},"data":data,"loc":{"start":{"line":1,"column":76},"end":{"line":2,"column":2}}}))
      + alias2((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":2,"column":2},"end":{"line":2,"column":16}}}))
      + "enum <span class='idlEnumID'>"
      + ((stack1 = (lookupProperty(helpers,"tryLink")||(depth0 && lookupProperty(depth0,"tryLink"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"tryLink","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":45},"end":{"line":2,"column":85}}})) != null ? stack1 : "")
      + "</span> &#123;\r\n"
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"children") || (depth0 != null ? lookupProperty(depth0,"children") : depth0)) != null ? helper : alias4),(typeof helper === "function" ? helper.call(alias3,{"name":"children","hash":{},"data":data,"loc":{"start":{"line":3,"column":0},"end":{"line":3,"column":14}}}) : helper))) != null ? stack1 : "")
      + alias2((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":3,"column":14},"end":{"line":3,"column":28}}}))
      + "&#125;;</span>";
  },"useData":true});
  templates['extended-attribute.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='"
      + alias4(((helper = (helper = lookupProperty(helpers,"extAttrClassName") || (depth0 != null ? lookupProperty(depth0,"extAttrClassName") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"extAttrClassName","hash":{},"data":data,"loc":{"start":{"line":3,"column":17},"end":{"line":3,"column":37}}}) : helper)))
      + "'><span class=\"extAttrName\">"
      + alias4(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data,"loc":{"start":{"line":3,"column":65},"end":{"line":4,"column":4}}}) : helper)))
      + "</span>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"rhs") : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":4,"column":11},"end":{"line":5,"column":4}}})) != null ? stack1 : "")
      + ((stack1 = (lookupProperty(helpers,"jsIf")||(depth0 && lookupProperty(depth0,"jsIf"))||alias2).call(alias1,(depth0 != null ? lookupProperty(depth0,"arguments") : depth0),{"name":"jsIf","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":5,"column":4},"end":{"line":6,"column":2}}})) != null ? stack1 : "")
      + "</span>";
  },"2":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "=<span class=\"extAttrRhs\">"
      + ((stack1 = (lookupProperty(helpers,"extAttrRhs")||(depth0 && lookupProperty(depth0,"extAttrRhs"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"rhs") : depth0),{"name":"extAttrRhs","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":4,"column":48},"end":{"line":4,"column":92}}})) != null ? stack1 : "")
      + "</span>";
  },"3":function(container,depth0,helpers,partials,data) {
      return container.escapeExpression(container.lambda(depth0, depth0));
  },"5":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "("
      + ((stack1 = (lookupProperty(helpers,"joinNonWhitespace")||(depth0 && lookupProperty(depth0,"joinNonWhitespace"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"arguments") : depth0),", ",{"name":"joinNonWhitespace","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":5,"column":24},"end":{"line":5,"column":97}}})) != null ? stack1 : "")
      + ")";
  },"6":function(container,depth0,helpers,partials,data) {
      var lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression((lookupProperty(helpers,"param")||(depth0 && lookupProperty(depth0,"param"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),depth0,{"name":"param","hash":{},"data":data,"loc":{"start":{"line":5,"column":61},"end":{"line":5,"column":75}}}));
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return alias3((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias2).call(alias1,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":2,"column":4},"end":{"line":2,"column":18}}}))
      + "["
      + ((stack1 = (lookupProperty(helpers,"join")||(depth0 && lookupProperty(depth0,"join"))||alias2).call(alias1,(depth0 != null ? lookupProperty(depth0,"extAttrs") : depth0),(depth0 != null ? lookupProperty(depth0,"sep") : depth0),{"name":"join","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":19},"end":{"line":6,"column":18}}})) != null ? stack1 : "")
      + "]"
      + alias3(((helper = (helper = lookupProperty(helpers,"end") || (depth0 != null ? lookupProperty(depth0,"end") : depth0)) != null ? helper : alias2),(typeof helper === "function" ? helper.call(alias1,{"name":"end","hash":{},"data":data,"loc":{"start":{"line":6,"column":19},"end":{"line":6,"column":26}}}) : helper)));
  },"useData":true});
  templates['field.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0));
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), alias4=container.hooks.helperMissing, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlField' id=\""
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"idlId") : stack1), depth0))
      + "\" data-idl data-title='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0))
      + "'>"
      + alias2((lookupProperty(helpers,"extAttr")||(depth0 && lookupProperty(depth0,"extAttr"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"extAttr","hash":{},"data":data,"loc":{"start":{"line":1,"column":77},"end":{"line":2,"column":2}}}))
      + alias2((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":2,"column":2},"end":{"line":2,"column":16}}}))
      + "<span class='idlFieldType'>"
      + alias2((lookupProperty(helpers,"idlType")||(depth0 && lookupProperty(depth0,"idlType"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"idlType","hash":{},"data":data,"loc":{"start":{"line":2,"column":43},"end":{"line":2,"column":58}}}))
      + "</span> "
      + alias2((lookupProperty(helpers,"pads")||(depth0 && lookupProperty(depth0,"pads"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"pad") : depth0),{"name":"pads","hash":{},"data":data,"loc":{"start":{"line":2,"column":66},"end":{"line":3,"column":5}}}))
      + "<span class='idlFieldName'>"
      + ((stack1 = (lookupProperty(helpers,"tryLink")||(depth0 && lookupProperty(depth0,"tryLink"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"tryLink","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":3,"column":32},"end":{"line":3,"column":72}}})) != null ? stack1 : "")
      + "</span>;</span>\r\n";
  },"useData":true});
  templates['implements.html'] = template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3=container.escapeExpression, alias4=container.lambda, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlImplements'>"
      + alias3((lookupProperty(helpers,"extAttr")||(depth0 && lookupProperty(depth0,"extAttr"))||alias2).call(alias1,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"extAttr","hash":{},"data":data,"loc":{"start":{"line":1,"column":28},"end":{"line":2,"column":2}}}))
      + alias3((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias2).call(alias1,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":2,"column":2},"end":{"line":2,"column":16}}}))
      + "<a>"
      + alias3(alias4(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"target") : stack1), depth0))
      + "</a> implements <a>"
      + alias3(alias4(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"implements") : stack1), depth0))
      + "</a>;</span>";
  },"useData":true});
  templates['interface.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0));
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return " : <span class='idlSuperclass'><a>"
      + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"inheritance") : stack1), depth0))
      + "</a></span>";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), alias4=container.hooks.helperMissing, alias5="function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlInterface' id='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"idlId") : stack1), depth0))
      + "' data-idl data-title='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0))
      + "'>"
      + alias2((lookupProperty(helpers,"extAttr")||(depth0 && lookupProperty(depth0,"extAttr"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"extAttr","hash":{},"data":data,"loc":{"start":{"line":1,"column":81},"end":{"line":2,"column":2}}}))
      + alias2((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":2,"column":2},"end":{"line":2,"column":16}}}))
      + alias2(((helper = (helper = lookupProperty(helpers,"partial") || (depth0 != null ? lookupProperty(depth0,"partial") : depth0)) != null ? helper : alias4),(typeof helper === alias5 ? helper.call(alias3,{"name":"partial","hash":{},"data":data,"loc":{"start":{"line":2,"column":16},"end":{"line":2,"column":27}}}) : helper)))
      + alias2(((helper = (helper = lookupProperty(helpers,"callback") || (depth0 != null ? lookupProperty(depth0,"callback") : depth0)) != null ? helper : alias4),(typeof helper === alias5 ? helper.call(alias3,{"name":"callback","hash":{},"data":data,"loc":{"start":{"line":2,"column":27},"end":{"line":2,"column":39}}}) : helper)))
      + "interface <span class='idlInterfaceID'>"
      + ((stack1 = (lookupProperty(helpers,"tryLink")||(depth0 && lookupProperty(depth0,"tryLink"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"tryLink","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":78},"end":{"line":3,"column":2}}})) != null ? stack1 : "")
      + "</span>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias3,((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"inheritance") : stack1),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":3,"column":9},"end":{"line":3,"column":103}}})) != null ? stack1 : "")
      + " &#123;\r\n"
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"children") || (depth0 != null ? lookupProperty(depth0,"children") : depth0)) != null ? helper : alias4),(typeof helper === alias5 ? helper.call(alias3,{"name":"children","hash":{},"data":data,"loc":{"start":{"line":4,"column":0},"end":{"line":4,"column":14}}}) : helper))) != null ? stack1 : "")
      + alias2((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":4,"column":14},"end":{"line":4,"column":28}}}))
      + "&#125;;</span>";
  },"useData":true});
  templates['iterable.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      return "iterable";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.escapeExpression, alias2=depth0 != null ? depth0 : (container.nullContext || {}), alias3=container.hooks.helperMissing, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlIterable' id=\""
      + alias1(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"idlId") : stack1), depth0))
      + "\" data-idl data-title='iterable'>"
      + alias1((lookupProperty(helpers,"extAttr")||(depth0 && lookupProperty(depth0,"extAttr"))||alias3).call(alias2,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"extAttr","hash":{},"data":data,"loc":{"start":{"line":1,"column":76},"end":{"line":2,"column":2}}}))
      + alias1((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias3).call(alias2,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":2,"column":2},"end":{"line":2,"column":16}}}))
      + alias1(((helper = (helper = lookupProperty(helpers,"qualifiers") || (depth0 != null ? lookupProperty(depth0,"qualifiers") : depth0)) != null ? helper : alias3),(typeof helper === "function" ? helper.call(alias2,{"name":"qualifiers","hash":{},"data":data,"loc":{"start":{"line":2,"column":16},"end":{"line":2,"column":30}}}) : helper)))
      + ((stack1 = (lookupProperty(helpers,"tryLink")||(depth0 && lookupProperty(depth0,"tryLink"))||alias3).call(alias2,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"tryLink","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":30},"end":{"line":3,"column":2}}})) != null ? stack1 : "")
      + "&lt;"
      + alias1((lookupProperty(helpers,"idlType")||(depth0 && lookupProperty(depth0,"idlType"))||alias3).call(alias2,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"idlType","hash":{},"data":data,"loc":{"start":{"line":3,"column":6},"end":{"line":3,"column":21}}}))
      + "&gt;;</span>\r\n";
  },"useData":true});
  templates['line-comment.html'] = template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlSectionComment'>"
      + alias3((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias2).call(alias1,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":1,"column":32},"end":{"line":1,"column":46}}}))
      + "//"
      + alias3(((helper = (helper = lookupProperty(helpers,"comment") || (depth0 != null ? lookupProperty(depth0,"comment") : depth0)) != null ? helper : alias2),(typeof helper === "function" ? helper.call(alias1,{"name":"comment","hash":{},"data":data,"loc":{"start":{"line":1,"column":48},"end":{"line":1,"column":59}}}) : helper)))
      + "</span>\r\n";
  },"useData":true});
  templates['maplike.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      return "maplike";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.escapeExpression, alias2=depth0 != null ? depth0 : (container.nullContext || {}), alias3=container.hooks.helperMissing, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlMaplike' id=\""
      + alias1(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"idlId") : stack1), depth0))
      + "\" data-idl data-title='maplike'>"
      + alias1((lookupProperty(helpers,"extAttr")||(depth0 && lookupProperty(depth0,"extAttr"))||alias3).call(alias2,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"extAttr","hash":{},"data":data,"loc":{"start":{"line":1,"column":74},"end":{"line":2,"column":2}}}))
      + alias1((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias3).call(alias2,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":2,"column":2},"end":{"line":2,"column":16}}}))
      + alias1(((helper = (helper = lookupProperty(helpers,"qualifiers") || (depth0 != null ? lookupProperty(depth0,"qualifiers") : depth0)) != null ? helper : alias3),(typeof helper === "function" ? helper.call(alias2,{"name":"qualifiers","hash":{},"data":data,"loc":{"start":{"line":2,"column":16},"end":{"line":2,"column":30}}}) : helper)))
      + ((stack1 = (lookupProperty(helpers,"tryLink")||(depth0 && lookupProperty(depth0,"tryLink"))||alias3).call(alias2,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"tryLink","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":30},"end":{"line":3,"column":2}}})) != null ? stack1 : "")
      + "&lt;"
      + alias1((lookupProperty(helpers,"idlType")||(depth0 && lookupProperty(depth0,"idlType"))||alias3).call(alias2,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"idlType","hash":{},"data":data,"loc":{"start":{"line":3,"column":6},"end":{"line":3,"column":21}}}))
      + "&gt;;</span>\r\n";
  },"useData":true});
  templates['method.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0));
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), alias4=container.hooks.helperMissing, alias5="function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlMethod' id=\""
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"idlId") : stack1), depth0))
      + "\" data-idl data-title='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0))
      + "'>"
      + alias2((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":1,"column":78},"end":{"line":1,"column":92}}}))
      + alias2((lookupProperty(helpers,"extAttrInline")||(depth0 && lookupProperty(depth0,"extAttrInline"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"extAttrInline","hash":{},"data":data,"loc":{"start":{"line":1,"column":92},"end":{"line":2,"column":2}}}))
      + alias2(((helper = (helper = lookupProperty(helpers,"static") || (depth0 != null ? lookupProperty(depth0,"static") : depth0)) != null ? helper : alias4),(typeof helper === alias5 ? helper.call(alias3,{"name":"static","hash":{},"data":data,"loc":{"start":{"line":2,"column":2},"end":{"line":2,"column":12}}}) : helper)))
      + alias2(((helper = (helper = lookupProperty(helpers,"special") || (depth0 != null ? lookupProperty(depth0,"special") : depth0)) != null ? helper : alias4),(typeof helper === alias5 ? helper.call(alias3,{"name":"special","hash":{},"data":data,"loc":{"start":{"line":2,"column":12},"end":{"line":2,"column":23}}}) : helper)))
      + "<span class='idlMethType'>"
      + alias2((lookupProperty(helpers,"idlType")||(depth0 && lookupProperty(depth0,"idlType"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"idlType","hash":{},"data":data,"loc":{"start":{"line":2,"column":49},"end":{"line":2,"column":64}}}))
      + "</span> "
      + alias2((lookupProperty(helpers,"pads")||(depth0 && lookupProperty(depth0,"pads"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"pad") : depth0),{"name":"pads","hash":{},"data":data,"loc":{"start":{"line":2,"column":72},"end":{"line":3,"column":2}}}))
      + "<span class='idlMethName'>"
      + ((stack1 = (lookupProperty(helpers,"tryLink")||(depth0 && lookupProperty(depth0,"tryLink"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"tryLink","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":3,"column":28},"end":{"line":3,"column":68}}})) != null ? stack1 : "")
      + "</span>("
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"children") || (depth0 != null ? lookupProperty(depth0,"children") : depth0)) != null ? helper : alias4),(typeof helper === alias5 ? helper.call(alias3,{"name":"children","hash":{},"data":data,"loc":{"start":{"line":3,"column":76},"end":{"line":3,"column":90}}}) : helper))) != null ? stack1 : "")
      + ");</span>\r\n";
  },"useData":true});
  templates['multiline-comment.html'] = template({"1":function(container,depth0,helpers,partials,data,blockParams,depths) {
      var alias1=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return alias1((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depths[1] != null ? lookupProperty(depths[1],"indent") : depths[1]),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":2,"column":19},"end":{"line":2,"column":36}}}))
      + alias1(container.lambda(depth0, depth0))
      + "\r\n";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data,blockParams,depths) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3=container.escapeExpression, alias4="function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlSectionComment'>"
      + alias3((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias2).call(alias1,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":1,"column":32},"end":{"line":1,"column":46}}}))
      + "/*"
      + alias3(((helper = (helper = lookupProperty(helpers,"firstLine") || (depth0 != null ? lookupProperty(depth0,"firstLine") : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"firstLine","hash":{},"data":data,"loc":{"start":{"line":1,"column":48},"end":{"line":1,"column":61}}}) : helper)))
      + "\r\n"
      + ((stack1 = lookupProperty(helpers,"each").call(alias1,(depth0 != null ? lookupProperty(depth0,"innerLine") : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0, blockParams, depths),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":0},"end":{"line":3,"column":9}}})) != null ? stack1 : "")
      + alias3((lookupProperty(helpers,"idn")||(depth0 && lookupProperty(depth0,"idn"))||alias2).call(alias1,(depth0 != null ? lookupProperty(depth0,"indent") : depth0),{"name":"idn","hash":{},"data":data,"loc":{"start":{"line":3,"column":9},"end":{"line":3,"column":23}}}))
      + alias3(((helper = (helper = lookupProperty(helpers,"lastLine") || (depth0 != null ? lookupProperty(depth0,"lastLine") : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"lastLine","hash":{},"data":data,"loc":{"start":{"line":3,"column":23},"end":{"line":3,"column":35}}}) : helper)))
      + "*/</span>\r\n";
  },"useData":true,"useDepths":true});
  templates['param.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return " = <span class='idlDefaultValue'>"
      + container.escapeExpression((lookupProperty(helpers,"stringifyIdlConst")||(depth0 && lookupProperty(depth0,"stringifyIdlConst"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"default") : stack1),{"name":"stringifyIdlConst","hash":{},"data":data,"loc":{"start":{"line":5,"column":35},"end":{"line":5,"column":68}}}))
      + "</span>";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3=container.escapeExpression, alias4="function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlParam'>"
      + alias3((lookupProperty(helpers,"extAttrInline")||(depth0 && lookupProperty(depth0,"extAttrInline"))||alias2).call(alias1,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"extAttrInline","hash":{},"data":data,"loc":{"start":{"line":2,"column":27},"end":{"line":3,"column":2}}}))
      + alias3(((helper = (helper = lookupProperty(helpers,"optional") || (depth0 != null ? lookupProperty(depth0,"optional") : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"optional","hash":{},"data":data,"loc":{"start":{"line":3,"column":2},"end":{"line":3,"column":14}}}) : helper)))
      + "<span class='idlParamType'>"
      + alias3((lookupProperty(helpers,"idlType")||(depth0 && lookupProperty(depth0,"idlType"))||alias2).call(alias1,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"idlType","hash":{},"data":data,"loc":{"start":{"line":3,"column":41},"end":{"line":3,"column":56}}}))
      + alias3(((helper = (helper = lookupProperty(helpers,"variadic") || (depth0 != null ? lookupProperty(depth0,"variadic") : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"variadic","hash":{},"data":data,"loc":{"start":{"line":3,"column":56},"end":{"line":4,"column":2}}}) : helper)))
      + "</span> <span class='idlParamName'>"
      + alias3(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0))
      + "</span>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"default") : stack1),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":4,"column":56},"end":{"line":5,"column":82}}})) != null ? stack1 : "")
      + "</span>";
  },"useData":true});
  templates['typedef.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0));
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), alias4=container.hooks.helperMissing, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<span class='idlTypedef' id='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"idlId") : stack1), depth0))
      + "' data-idl data-title='"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"obj") : depth0)) != null ? lookupProperty(stack1,"name") : stack1), depth0))
      + "'>typedef <span class='idlTypedefType'>"
      + alias2((lookupProperty(helpers,"idlType")||(depth0 && lookupProperty(depth0,"idlType"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"idlType","hash":{},"data":data,"loc":{"start":{"line":1,"column":116},"end":{"line":2,"column":2}}}))
      + "</span> <span class='idlTypedefID'>"
      + ((stack1 = (lookupProperty(helpers,"tryLink")||(depth0 && lookupProperty(depth0,"tryLink"))||alias4).call(alias3,(depth0 != null ? lookupProperty(depth0,"obj") : depth0),{"name":"tryLink","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":37},"end":{"line":2,"column":77}}})) != null ? stack1 : "")
      + "</span>;</span>";
  },"useData":true});
  templates['pcisig-conformance'] = template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      return "<h2>Conformance</h2>\r\n<p>\r\n  As well as sections marked as non-normative, all implementation\r\n  notes and notes in this specification are non-normative. Everything\r\n  else in this specification is normative.\r\n</p>\r\n<p id='respecRFC2119'>\r\n  to be interpreted as described in [[!RFC2119]].\r\n</p>\r\n";
  },"useData":true});
  templates['pcisig-headers'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"prependPCIeLogo") : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data,"loc":{"start":{"line":4,"column":6},"end":{"line":16,"column":13}}})) != null ? stack1 : "");
  },"2":function(container,depth0,helpers,partials,data) {
      return "        <a href=\"https://www.pcisig.com/\">\r\n          <img width=\"210\" height=\"80\" alt=\"PCI Express Logo\"\r\n               src=\"https://sglaser.github.io/respec/Spec/StyleSheets/pcisig/pci_express_PMS.svg\"/>\r\n        </a>\r\n";
  },"4":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"prependPCISIGLogo") : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":10,"column":8},"end":{"line":15,"column":15}}})) != null ? stack1 : "");
  },"5":function(container,depth0,helpers,partials,data) {
      return "          <a href=\"https://www.pcisig.com/\">\r\n            <img width=\"210\" height=\"108\" alt=\"PCI-SIG Logo\"\r\n                 src=\"https://sglaser.github.io/respec/Spec/StyleSheets/pcisig/pci_sig_logo_PMS_273.svg\"/>\r\n          </a>\r\n";
  },"7":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      &nbsp;&mdash;&nbsp;<span id=\"respec-banner-chapter\">"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"specChapter") || (depth0 != null ? lookupProperty(depth0,"specChapter") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"specChapter","hash":{},"data":data,"loc":{"start":{"line":24,"column":58},"end":{"line":24,"column":73}}}) : helper)))
      + "</span>\r\n";
  },"9":function(container,depth0,helpers,partials,data) {
      return " property='dcterms:title'";
  },"11":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    <h2 "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(12, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":32,"column":8},"end":{"line":32,"column":54}}})) != null ? stack1 : "")
      + "id='subtitle'>"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"subtitle") || (depth0 != null ? lookupProperty(depth0,"subtitle") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"subtitle","hash":{},"data":data,"loc":{"start":{"line":32,"column":68},"end":{"line":32,"column":80}}}) : helper)))
      + "</h2>\r\n";
  },"12":function(container,depth0,helpers,partials,data) {
      return "property='bibo:subtitle' ";
  },"14":function(container,depth0,helpers,partials,data) {
      return "PCI-SIG ";
  },"16":function(container,depth0,helpers,partials,data) {
      return "property=\"dcterms:issued\"";
  },"18":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), alias4=container.hooks.helperMissing, alias5="function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"this_version") : stack1), depth0))
      + "</dt>\r\n      <dd><a class='u-url' href='"
      + alias2(((helper = (helper = lookupProperty(helpers,"thisVersion") || (depth0 != null ? lookupProperty(depth0,"thisVersion") : depth0)) != null ? helper : alias4),(typeof helper === alias5 ? helper.call(alias3,{"name":"thisVersion","hash":{},"data":data,"loc":{"start":{"line":43,"column":33},"end":{"line":43,"column":48}}}) : helper)))
      + "'>"
      + alias2(((helper = (helper = lookupProperty(helpers,"thisVersion") || (depth0 != null ? lookupProperty(depth0,"thisVersion") : depth0)) != null ? helper : alias4),(typeof helper === alias5 ? helper.call(alias3,{"name":"thisVersion","hash":{},"data":data,"loc":{"start":{"line":43,"column":50},"end":{"line":43,"column":65}}}) : helper)))
      + "</a></dd>\r\n      <dt>"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"latest_published_version") : stack1), depth0))
      + "</dt>\r\n      <dd>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias3,(depth0 != null ? lookupProperty(depth0,"latestVersion") : depth0),{"name":"if","hash":{},"fn":container.program(19, data, 0),"inverse":container.program(21, data, 0),"data":data,"loc":{"start":{"line":45,"column":10},"end":{"line":45,"column":99}}})) != null ? stack1 : "")
      + "</dd>\r\n";
  },"19":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<a href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"latestVersion") || (depth0 != null ? lookupProperty(depth0,"latestVersion") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"latestVersion","hash":{},"data":data,"loc":{"start":{"line":45,"column":40},"end":{"line":45,"column":57}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"latestVersion") || (depth0 != null ? lookupProperty(depth0,"latestVersion") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"latestVersion","hash":{},"data":data,"loc":{"start":{"line":45,"column":59},"end":{"line":45,"column":76}}}) : helper)))
      + "</a>";
  },"21":function(container,depth0,helpers,partials,data) {
      return "none";
  },"23":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"bug_tracker") : stack1), depth0))
      + "</dt>\r\n      <dd>"
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"bugTrackerHTML") || (depth0 != null ? lookupProperty(depth0,"bugTrackerHTML") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"bugTrackerHTML","hash":{},"data":data,"loc":{"start":{"line":49,"column":10},"end":{"line":49,"column":30}}}) : helper))) != null ? stack1 : "")
      + "</dd>\r\n";
  },"25":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>Previous version:</dt>\r\n      <dd><a "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(26, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":53,"column":13},"end":{"line":53,"column":56}}})) != null ? stack1 : "")
      + " href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevVersion") || (depth0 != null ? lookupProperty(depth0,"prevVersion") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevVersion","hash":{},"data":data,"loc":{"start":{"line":53,"column":63},"end":{"line":53,"column":78}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevVersion") || (depth0 != null ? lookupProperty(depth0,"prevVersion") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevVersion","hash":{},"data":data,"loc":{"start":{"line":53,"column":80},"end":{"line":53,"column":95}}}) : helper)))
      + "</a></dd>\r\n";
  },"26":function(container,depth0,helpers,partials,data) {
      return "rel=\"dcterms:replaces\"";
  },"28":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"multipleWGs") : depth0),{"name":"if","hash":{},"fn":container.program(29, data, 0),"inverse":container.program(31, data, 0),"data":data,"loc":{"start":{"line":56,"column":10},"end":{"line":56,"column":81}}})) != null ? stack1 : "")
      + "</dt>\r\n      <dd>"
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"wgHTML") || (depth0 != null ? lookupProperty(depth0,"wgHTML") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"wgHTML","hash":{},"data":data,"loc":{"start":{"line":57,"column":10},"end":{"line":57,"column":22}}}) : helper))) != null ? stack1 : "")
      + "</dd>\r\n";
  },"29":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"workgroups") : stack1), depth0));
  },"31":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"workgroup") : stack1), depth0));
  },"33":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"multipleEditors") : depth0),{"name":"if","hash":{},"fn":container.program(34, data, 0),"inverse":container.program(36, data, 0),"data":data,"loc":{"start":{"line":60,"column":10},"end":{"line":60,"column":79}}})) != null ? stack1 : "")
      + "</dt>\r\n      "
      + container.escapeExpression((lookupProperty(helpers,"showPeople")||(depth0 && lookupProperty(depth0,"showPeople"))||container.hooks.helperMissing).call(alias1,"Editor",(depth0 != null ? lookupProperty(depth0,"editors") : depth0),{"name":"showPeople","hash":{},"data":data,"loc":{"start":{"line":61,"column":6},"end":{"line":61,"column":37}}}))
      + "\r\n";
  },"34":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"editors") : stack1), depth0));
  },"36":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"editor") : stack1), depth0));
  },"38":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"multipleAuthors") : depth0),{"name":"if","hash":{},"fn":container.program(39, data, 0),"inverse":container.program(41, data, 0),"data":data,"loc":{"start":{"line":64,"column":10},"end":{"line":64,"column":79}}})) != null ? stack1 : "")
      + "</dt>\r\n      "
      + container.escapeExpression((lookupProperty(helpers,"showPeople")||(depth0 && lookupProperty(depth0,"showPeople"))||container.hooks.helperMissing).call(alias1,"Author",(depth0 != null ? lookupProperty(depth0,"authors") : depth0),{"name":"showPeople","hash":{},"data":data,"loc":{"start":{"line":65,"column":6},"end":{"line":65,"column":37}}}))
      + "\r\n";
  },"39":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"authors") : stack1), depth0));
  },"41":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"author") : stack1), depth0));
  },"43":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"each").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"otherLinks") : depth0),{"name":"each","hash":{},"fn":container.program(44, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":68,"column":6},"end":{"line":101,"column":15}}})) != null ? stack1 : "");
  },"44":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"key") : depth0),{"name":"if","hash":{},"fn":container.program(45, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":69,"column":8},"end":{"line":100,"column":15}}})) != null ? stack1 : "");
  },"45":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "          <dt "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"class") : depth0),{"name":"if","hash":{},"fn":container.program(46, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":70,"column":14},"end":{"line":70,"column":51}}})) != null ? stack1 : "")
      + ">"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"key") || (depth0 != null ? lookupProperty(depth0,"key") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"key","hash":{},"data":data,"loc":{"start":{"line":70,"column":52},"end":{"line":70,"column":59}}}) : helper)))
      + ":</dt>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"data") : depth0),{"name":"if","hash":{},"fn":container.program(48, data, 0),"inverse":container.program(58, data, 0),"data":data,"loc":{"start":{"line":71,"column":10},"end":{"line":99,"column":17}}})) != null ? stack1 : "");
  },"46":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "class=\""
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"class") || (depth0 != null ? lookupProperty(depth0,"class") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"class","hash":{},"data":data,"loc":{"start":{"line":70,"column":34},"end":{"line":70,"column":43}}}) : helper)))
      + "\"";
  },"48":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"each").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"data") : depth0),{"name":"each","hash":{},"fn":container.program(49, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":72,"column":12},"end":{"line":84,"column":21}}})) != null ? stack1 : "");
  },"49":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"value") : depth0),{"name":"if","hash":{},"fn":container.program(50, data, 0),"inverse":container.program(55, data, 0),"data":data,"loc":{"start":{"line":73,"column":14},"end":{"line":83,"column":21}}})) != null ? stack1 : "");
  },"50":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "                <dd "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"class") : depth0),{"name":"if","hash":{},"fn":container.program(46, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":74,"column":20},"end":{"line":74,"column":57}}})) != null ? stack1 : "")
      + ">\r\n                  "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(51, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":75,"column":18},"end":{"line":75,"column":56}}})) != null ? stack1 : "")
      + "\r\n                  "
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"value") || (depth0 != null ? lookupProperty(depth0,"value") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"value","hash":{},"data":data,"loc":{"start":{"line":76,"column":18},"end":{"line":76,"column":27}}}) : helper)))
      + "\r\n                  "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(53, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":77,"column":18},"end":{"line":77,"column":41}}})) != null ? stack1 : "")
      + "\r\n                </dd>\r\n";
  },"51":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<a href=\""
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"href","hash":{},"data":data,"loc":{"start":{"line":75,"column":39},"end":{"line":75,"column":47}}}) : helper)))
      + "\">";
  },"53":function(container,depth0,helpers,partials,data) {
      return "</a>";
  },"55":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(56, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":80,"column":16},"end":{"line":82,"column":23}}})) != null ? stack1 : "");
  },"56":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "                  <dd><a href=\""
      + alias4(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"href","hash":{},"data":data,"loc":{"start":{"line":81,"column":31},"end":{"line":81,"column":39}}}) : helper)))
      + "\">"
      + alias4(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"href","hash":{},"data":data,"loc":{"start":{"line":81,"column":41},"end":{"line":81,"column":49}}}) : helper)))
      + "</a></dd>\r\n";
  },"58":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"value") : depth0),{"name":"if","hash":{},"fn":container.program(59, data, 0),"inverse":container.program(61, data, 0),"data":data,"loc":{"start":{"line":86,"column":12},"end":{"line":98,"column":19}}})) != null ? stack1 : "");
  },"59":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "              <dd "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"class") : depth0),{"name":"if","hash":{},"fn":container.program(46, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":87,"column":18},"end":{"line":87,"column":55}}})) != null ? stack1 : "")
      + ">\r\n                "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(51, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":88,"column":16},"end":{"line":88,"column":54}}})) != null ? stack1 : "")
      + "\r\n                "
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"value") || (depth0 != null ? lookupProperty(depth0,"value") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"value","hash":{},"data":data,"loc":{"start":{"line":89,"column":16},"end":{"line":89,"column":25}}}) : helper)))
      + "\r\n                "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(53, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":90,"column":16},"end":{"line":90,"column":39}}})) != null ? stack1 : "")
      + "\r\n              </dd>\r\n";
  },"61":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(62, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":93,"column":14},"end":{"line":97,"column":21}}})) != null ? stack1 : "");
  },"62":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "                <dd "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"class") : depth0),{"name":"if","hash":{},"fn":container.program(46, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":94,"column":20},"end":{"line":94,"column":57}}})) != null ? stack1 : "")
      + ">\r\n                  <a href=\""
      + alias4(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"href","hash":{},"data":data,"loc":{"start":{"line":95,"column":27},"end":{"line":95,"column":35}}}) : helper)))
      + "\">"
      + alias4(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"href","hash":{},"data":data,"loc":{"start":{"line":95,"column":37},"end":{"line":95,"column":45}}}) : helper)))
      + "</a>\r\n                </dd>\r\n";
  },"64":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    <p>\r\n      Please check the <a href=\""
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"errata") || (depth0 != null ? lookupProperty(depth0,"errata") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"errata","hash":{},"data":data,"loc":{"start":{"line":106,"column":32},"end":{"line":106,"column":42}}}) : helper)))
      + "\"><strong>errata</strong></a> for any errors or issues\r\n      reported since publication.\r\n    </p>\r\n";
  },"66":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    <p>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"multipleAlternates") : depth0),{"name":"if","hash":{},"fn":container.program(67, data, 0),"inverse":container.program(69, data, 0),"data":data,"loc":{"start":{"line":112,"column":6},"end":{"line":116,"column":13}}})) != null ? stack1 : "")
      + "      "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"alternatesHTML") || (depth0 != null ? lookupProperty(depth0,"alternatesHTML") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"alternatesHTML","hash":{},"data":data,"loc":{"start":{"line":117,"column":6},"end":{"line":117,"column":26}}}) : helper))) != null ? stack1 : "")
      + "\r\n    </p>\r\n";
  },"67":function(container,depth0,helpers,partials,data) {
      return "        This document is also available in these non-normative formats:\r\n";
  },"69":function(container,depth0,helpers,partials,data) {
      return "        This document is also available in this non-normative format:\r\n";
  },"71":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"additionalCopyrightHolders") : depth0),{"name":"if","hash":{},"fn":container.program(72, data, 0),"inverse":container.program(74, data, 0),"data":data,"loc":{"start":{"line":121,"column":4},"end":{"line":133,"column":11}}})) != null ? stack1 : "");
  },"72":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <p class='copyright'>"
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalCopyrightHolders") || (depth0 != null ? lookupProperty(depth0,"additionalCopyrightHolders") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"additionalCopyrightHolders","hash":{},"data":data,"loc":{"start":{"line":122,"column":27},"end":{"line":122,"column":59}}}) : helper))) != null ? stack1 : "")
      + "</p>\r\n";
  },"74":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"overrideCopyright") : depth0),{"name":"if","hash":{},"fn":container.program(75, data, 0),"inverse":container.program(77, data, 0),"data":data,"loc":{"start":{"line":124,"column":6},"end":{"line":132,"column":13}}})) != null ? stack1 : "");
  },"75":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "        "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"overrideCopyright") || (depth0 != null ? lookupProperty(depth0,"overrideCopyright") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"overrideCopyright","hash":{},"data":data,"loc":{"start":{"line":125,"column":8},"end":{"line":125,"column":31}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"77":function(container,depth0,helpers,partials,data) {
      return "        <p class='copyright'>\r\n          This document is licensed under a\r\n          <a class='subfoot' href='https://creativecommons.org/licenses/by/3.0/' rel='license'>Creative Commons\r\n            Attribution 3.0 License</a>.\r\n        </p>\r\n";
  },"79":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"overrideCopyright") : depth0),{"name":"if","hash":{},"fn":container.program(80, data, 0),"inverse":container.program(82, data, 0),"data":data,"loc":{"start":{"line":135,"column":4},"end":{"line":199,"column":11}}})) != null ? stack1 : "");
  },"80":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"overrideCopyright") || (depth0 != null ? lookupProperty(depth0,"overrideCopyright") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"overrideCopyright","hash":{},"data":data,"loc":{"start":{"line":136,"column":6},"end":{"line":136,"column":29}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"82":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <p class=\"copyright\">\r\n        Copyright &copy; "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"copyrightStart") : depth0),{"name":"if","hash":{},"fn":container.program(83, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":139,"column":25},"end":{"line":139,"column":73}}})) != null ? stack1 : "")
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"publishYear") || (depth0 != null ? lookupProperty(depth0,"publishYear") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"publishYear","hash":{},"data":data,"loc":{"start":{"line":139,"column":73},"end":{"line":139,"column":88}}}) : helper)))
      + " "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"additionalCopyrightHolders") : depth0),{"name":"if","hash":{},"fn":container.program(85, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":139,"column":89},"end":{"line":140,"column":82}}})) != null ? stack1 : "")
      + "\r\n        <a href=\"https://www.pcisig.com/\">PCI-SIG</a>\r\n        <sup>&reg;</sup>\r\n      </p>\r\n      <p class=\"copyright\">\r\n        PCI, PCI Express, PCIe, and PCI-SIG are trademarks or registered trademarks of PCI-SIG.\r\n        All other product names are trademarks, registered trademarks, or servicemarks of their respective owners.\r\n      </p>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isNoTrack") : depth0),{"name":"if","hash":{},"fn":container.program(87, data, 0),"inverse":container.program(89, data, 0),"data":data,"loc":{"start":{"line":148,"column":6},"end":{"line":198,"column":13}}})) != null ? stack1 : "");
  },"83":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(((helper = (helper = lookupProperty(helpers,"copyrightStart") || (depth0 != null ? lookupProperty(depth0,"copyrightStart") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"copyrightStart","hash":{},"data":data,"loc":{"start":{"line":139,"column":47},"end":{"line":139,"column":65}}}) : helper)))
      + "-";
  },"85":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return " "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalCopyrightHolders") || (depth0 != null ? lookupProperty(depth0,"additionalCopyrightHolders") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"additionalCopyrightHolders","hash":{},"data":data,"loc":{"start":{"line":140,"column":37},"end":{"line":140,"column":69}}}) : helper))) != null ? stack1 : "")
      + " &amp;";
  },"87":function(container,depth0,helpers,partials,data) {
      return "        <p class=\"copyright\">\r\n          PCI-SIG disclaims all warranties and liability for the use of this document\r\n          and the information contained herein and assumes no responsibility\r\n          for any errors that may appear in this document, nor does PCI-SIG make a commitment\r\n          to update the information contained herein.\r\n        </p>\r\n";
  },"89":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "        <p class=\"copyright\">\r\n          Contact PCI-SIG Membership Services for questions about membership in the PCI-SIG\r\n          or to obtain the latest revision of this specification.\r\n          Contact PCI-SIG Technical Support for technical questions about this specification.\r\n        </p>\r\n        <dl class=\"copyright\">\r\n          <dt>Web Site</dt>\r\n          <dd><a href=\"http://www.pcisig.com\">http://www.pcisig.com</a></dd>\r\n          <dt>Membership Services</dt>\r\n          <dd><a href=\"mailto:administration@pcisig.com\">administration@pcisig.com</a></dd>\r\n          <dd><a href=\"tel:+1-503-619-0569\">+1-503-619-0569</a> (Phone)</dd>\r\n          <dd><a href=\"tel:+1-503-644-6708\">+1-503-644-6708</a> (Fax)</dd>\r\n          <dt>Technical Support</dt>\r\n          <dd><a href=\"mailto:techsupp@pcisig.com\">techsupp@pcisig.com</a></dd>\r\n        </dl>\r\n        <p class=\"copyright\"><strong>DISCLAIMER</strong></p>\r\n        <p class=\"copyright\">\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"isClickThrough") : depth0),{"name":"if","hash":{},"fn":container.program(90, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":173,"column":10},"end":{"line":177,"column":17}}})) != null ? stack1 : "")
      + "          PCI-SIG disclaims all warranties and liability for the use of this document\r\n          and the information contained herein and assumes no responsibility\r\n          for any errors that may appear in this document, nor does PCI-SIG make a commitment\r\n          to update the information contained herein.\r\n        </p>\r\n        <p class=\"copyright\">\r\n          This PCI Specification is provided âas isâ without any warranties of any kind,\r\n          including any warranty of merchantability, non-infringement, fitness for any\r\n          particular purpose, or any warranty otherwise arising out of any proposal,\r\n          specification, or sample. PCI-SIG disclaims all liability for infringement\r\n          of proprietary rights, relating to use of information in this specification.\r\n          This document itself may not be modified in any way, including by removing the\r\n          copyright notice or references to PCI-SIG.\r\n          No license, express or implied, by estoppel or otherwise, to any intellectual\r\n          property rights is granted herein.\r\n          PCI, PCI Express, PCIe, and PCI-SIG are trademarks or registered trademarks of\r\n          PCI-SIG.\r\n          All other product names are trademarks, registered trademarks, or servicemarks of\r\n          their respective owners.\r\n        </p>\r\n";
  },"90":function(container,depth0,helpers,partials,data) {
      return "            This specification is the sole property of PCI-SIGÂ® and\r\n            provided under a click through license through its website,\r\n            <a href=\"http://www.pcisig.com\">www.pcisig.com</a>\r\n";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<div class='head'>\r\n  <p>\r\n"
      + ((stack1 = lookupProperty(helpers,"unless").call(alias1,(depth0 != null ? lookupProperty(depth0,"isUnofficial") : depth0),{"name":"unless","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":3,"column":4},"end":{"line":17,"column":15}}})) != null ? stack1 : "")
      + "    "
      + ((stack1 = (lookupProperty(helpers,"showLogos")||(depth0 && lookupProperty(depth0,"showLogos"))||alias2).call(alias1,(depth0 != null ? lookupProperty(depth0,"logos") : depth0),{"name":"showLogos","hash":{},"data":data,"loc":{"start":{"line":18,"column":4},"end":{"line":18,"column":25}}})) != null ? stack1 : "")
      + "\r\n  </p>\r\n\r\n  <div id=\"respec-banner\">\r\n    <span id=\"respec-banner-status\">"
      + alias4(((helper = (helper = lookupProperty(helpers,"maturity") || (depth0 != null ? lookupProperty(depth0,"maturity") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"maturity","hash":{},"data":data,"loc":{"start":{"line":22,"column":36},"end":{"line":22,"column":48}}}) : helper)))
      + "</span>&nbsp;&mdash;&nbsp;\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"specChapter") : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":23,"column":4},"end":{"line":25,"column":11}}})) != null ? stack1 : "")
      + "    &nbsp;&mdash;&nbsp;<span id=\"respec-banner-spec-name\">"
      + alias4(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data,"loc":{"start":{"line":26,"column":58},"end":{"line":26,"column":67}}}) : helper)))
      + "</span>\r\n  </div>\r\n\r\n  <h1 class='title p-name' id='title'"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":29,"column":37},"end":{"line":29,"column":83}}})) != null ? stack1 : "")
      + ">"
      + alias4(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data,"loc":{"start":{"line":29,"column":84},"end":{"line":29,"column":93}}}) : helper)))
      + "</h1>\r\n\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"subtitle") : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":31,"column":2},"end":{"line":33,"column":9}}})) != null ? stack1 : "")
      + "\r\n  <h2>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"prependPCISIG") : depth0),{"name":"if","hash":{},"fn":container.program(14, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":35,"column":6},"end":{"line":35,"column":42}}})) != null ? stack1 : "")
      + alias4(((helper = (helper = lookupProperty(helpers,"textStatus") || (depth0 != null ? lookupProperty(depth0,"textStatus") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"textStatus","hash":{},"data":data,"loc":{"start":{"line":35,"column":42},"end":{"line":35,"column":56}}}) : helper)))
      + "\r\n    <time "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(16, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":36,"column":10},"end":{"line":36,"column":56}}})) != null ? stack1 : "")
      + " class='dt-published'\r\n          datetime='"
      + alias4(((helper = (helper = lookupProperty(helpers,"dashDate") || (depth0 != null ? lookupProperty(depth0,"dashDate") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"dashDate","hash":{},"data":data,"loc":{"start":{"line":37,"column":20},"end":{"line":37,"column":32}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"publishHumanDate") || (depth0 != null ? lookupProperty(depth0,"publishHumanDate") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"publishHumanDate","hash":{},"data":data,"loc":{"start":{"line":37,"column":34},"end":{"line":37,"column":54}}}) : helper)))
      + "</time>\r\n  </h2>\r\n\r\n  <dl>\r\n"
      + ((stack1 = lookupProperty(helpers,"unless").call(alias1,(depth0 != null ? lookupProperty(depth0,"isNoTrack") : depth0),{"name":"unless","hash":{},"fn":container.program(18, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":41,"column":4},"end":{"line":46,"column":15}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"bugTrackerHTML") : depth0),{"name":"if","hash":{},"fn":container.program(23, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":47,"column":4},"end":{"line":50,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"showPreviousVersion") : depth0),{"name":"if","hash":{},"fn":container.program(25, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":51,"column":4},"end":{"line":54,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"wg") : depth0),{"name":"if","hash":{},"fn":container.program(28, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":55,"column":4},"end":{"line":58,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"editors") : depth0),{"name":"if","hash":{},"fn":container.program(33, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":59,"column":4},"end":{"line":62,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"authors") : depth0),{"name":"if","hash":{},"fn":container.program(38, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":63,"column":4},"end":{"line":66,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"otherLinks") : depth0),{"name":"if","hash":{},"fn":container.program(43, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":67,"column":4},"end":{"line":102,"column":11}}})) != null ? stack1 : "")
      + "  </dl>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"errata") : depth0),{"name":"if","hash":{},"fn":container.program(64, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":104,"column":2},"end":{"line":109,"column":9}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"alternateFormats") : depth0),{"name":"if","hash":{},"fn":container.program(66, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":110,"column":2},"end":{"line":119,"column":9}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isUnofficial") : depth0),{"name":"if","hash":{},"fn":container.program(71, data, 0),"inverse":container.program(79, data, 0),"data":data,"loc":{"start":{"line":120,"column":2},"end":{"line":200,"column":9}}})) != null ? stack1 : "")
      + "  <hr title=\"Separator for header\">\r\n</div>\r\n";
  },"useData":true});
  templates['pcisig-sotd'] = template({"1":function(container,depth0,helpers,partials,data) {
      return "  <details class=\"annoying-warning\" open=\"\">\r\n    <summary>This is a preview</summary>\r\n    <p>\r\n      Do not attempt to implement this version of the specification. Do not reference this\r\n      version as authoritative in any way.\r\n    </p>\r\n  </details>\r\n";
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "  <p>\r\n    This document is draft of a potential specification. It has no official standing of\r\n    any kind and does not represent the support or consensus of any standards organisation.\r\n  </p>\r\n  "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalContent") || (depth0 != null ? lookupProperty(depth0,"additionalContent") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"additionalContent","hash":{},"data":data,"loc":{"start":{"line":16,"column":2},"end":{"line":16,"column":25}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"5":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isNoTrack") : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.program(8, data, 0),"data":data,"loc":{"start":{"line":18,"column":2},"end":{"line":65,"column":9}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isSubmission") : depth0),{"name":"if","hash":{},"fn":container.program(27, data, 0),"inverse":container.program(29, data, 0),"data":data,"loc":{"start":{"line":66,"column":2},"end":{"line":84,"column":9}}})) != null ? stack1 : "");
  },"6":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    <p>\r\n      This document is a PCISIG internal document. It has no official standing of any kind and does not represent\r\n      consensus of the PCISIG Membership.\r\n    </p>\r\n    "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalContent") || (depth0 != null ? lookupProperty(depth0,"additionalContent") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"additionalContent","hash":{},"data":data,"loc":{"start":{"line":23,"column":4},"end":{"line":23,"column":27}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"8":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"unless").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"overrideStatus") : depth0),{"name":"unless","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":25,"column":4},"end":{"line":64,"column":15}}})) != null ? stack1 : "");
  },"9":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"isFinal") : depth0),{"name":"if","hash":{},"fn":container.program(10, data, 0),"inverse":container.program(12, data, 0),"data":data,"loc":{"start":{"line":26,"column":6},"end":{"line":63,"column":13}}})) != null ? stack1 : "");
  },"10":function(container,depth0,helpers,partials,data) {
      return "        <p>\r\n          This specification is an official publication of the PCISIG. The PCISIG\r\n          may publish errata to this specification and may develop future revisions to this\r\n          specification.\r\n        </p>\r\n";
  },"12":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "        <p>\r\n          This specification is intended to become a PCISIG Standard.\r\n          This particular document is a <strong>"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"specStatusLong") || (depth0 != null ? lookupProperty(depth0,"specStatusLong") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"specStatusLong","hash":{},"data":data,"loc":{"start":{"line":35,"column":48},"end":{"line":35,"column":66}}}) : helper)))
      + "</strong>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"specLevelLong") : depth0),{"name":"if","hash":{},"fn":container.program(13, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":36,"column":10},"end":{"line":41,"column":17}}})) != null ? stack1 : "")
      + ".\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"specReviewLong") : depth0),{"name":"if","hash":{},"fn":container.program(16, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":42,"column":10},"end":{"line":46,"column":17}}})) != null ? stack1 : "")
      + "        </p>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"is09") : depth0),{"name":"if","hash":{},"fn":container.program(19, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":48,"column":8},"end":{"line":51,"column":15}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"is07") : depth0),{"name":"if","hash":{},"fn":container.program(21, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":52,"column":8},"end":{"line":56,"column":15}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"is05") : depth0),{"name":"if","hash":{},"fn":container.program(23, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":57,"column":8},"end":{"line":59,"column":15}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"is03") : depth0),{"name":"if","hash":{},"fn":container.program(25, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":60,"column":8},"end":{"line":62,"column":15}}})) != null ? stack1 : "");
  },"13":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "            of the <strong>"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"specLevelLong") || (depth0 != null ? lookupProperty(depth0,"specLevelLong") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"specLevelLong","hash":{},"data":data,"loc":{"start":{"line":37,"column":27},"end":{"line":37,"column":44}}}) : helper)))
      + "</strong> document\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"specReviewLong") : depth0),{"name":"if","hash":{},"fn":container.program(14, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":38,"column":12},"end":{"line":40,"column":19}}})) != null ? stack1 : "")
      + "          ";
  },"14":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "              for <strong>"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"specReviewLong") || (depth0 != null ? lookupProperty(depth0,"specReviewLong") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"specReviewLong","hash":{},"data":data,"loc":{"start":{"line":39,"column":26},"end":{"line":39,"column":44}}}) : helper)))
      + "</strong>\r\n";
  },"16":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"humanReviewEndDate") : depth0),{"name":"if","hash":{},"fn":container.program(17, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":43,"column":12},"end":{"line":45,"column":19}}})) != null ? stack1 : "");
  },"17":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "              The "
      + alias4(((helper = (helper = lookupProperty(helpers,"specReviewLong") || (depth0 != null ? lookupProperty(depth0,"specReviewLong") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"specReviewLong","hash":{},"data":data,"loc":{"start":{"line":44,"column":18},"end":{"line":44,"column":36}}}) : helper)))
      + " period ends 5:00 PM US Pacific Time on <b>"
      + alias4(((helper = (helper = lookupProperty(helpers,"humanReviewEndDate") || (depth0 != null ? lookupProperty(depth0,"humanReviewEndDate") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"humanReviewEndDate","hash":{},"data":data,"loc":{"start":{"line":44,"column":79},"end":{"line":44,"column":101}}}) : helper)))
      + "</b>.\r\n";
  },"19":function(container,depth0,helpers,partials,data) {
      return "          <p>PCISIG publishes a 0.9 maturity level specification to indicate that the document is believed to be\r\n            stable and to encourage implementation by the developer community.</p>\r\n";
  },"21":function(container,depth0,helpers,partials,data) {
      return "          <p>\r\n            PCISIG publishes a 0.7 maturity level specification to indicate that the ...\r\n          </p>\r\n";
  },"23":function(container,depth0,helpers,partials,data) {
      return "          <p>PCISIG publishes a 0.5 maturity level specification to indicate that the ...</p>\r\n";
  },"25":function(container,depth0,helpers,partials,data) {
      return "          <p>PCISIG publishes a 0.3 maturity level specification to indicate that the ...</p>\r\n";
  },"27":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalContent") || (depth0 != null ? lookupProperty(depth0,"additionalContent") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"additionalContent","hash":{},"data":data,"loc":{"start":{"line":67,"column":4},"end":{"line":67,"column":27}}}) : helper))) != null ? stack1 : "")
      + "\r\n    <p>PCISIG acknowledges that the Submitting Member have made a formal Submission request to PCISIG for\r\n      discussion. Publication of this document by PCISIG indicates no endorsement of its content by PCISIG, nor that\r\n      PCISIG has, is, or will be allocating any resources to the issues addressed by it. This document is not the\r\n      product of a chartered PCISIG Workgroup. </p>\r\n";
  },"29":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"unless").call(alias1,(depth0 != null ? lookupProperty(depth0,"sotdAfterWGinfo") : depth0),{"name":"unless","hash":{},"fn":container.program(30, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":73,"column":4},"end":{"line":75,"column":15}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"notRec") : depth0),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":76,"column":4},"end":{"line":82,"column":11}}})) != null ? stack1 : "")
      + "    "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"addPatentNote") : depth0),{"name":"if","hash":{},"fn":container.program(34, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":83,"column":4},"end":{"line":83,"column":58}}})) != null ? stack1 : "")
      + "\r\n";
  },"30":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalContent") || (depth0 != null ? lookupProperty(depth0,"additionalContent") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"additionalContent","hash":{},"data":data,"loc":{"start":{"line":74,"column":6},"end":{"line":74,"column":29}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"32":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <p>\r\n        Publication as "
      + alias4(((helper = (helper = lookupProperty(helpers,"anOrA") || (depth0 != null ? lookupProperty(depth0,"anOrA") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"anOrA","hash":{},"data":data,"loc":{"start":{"line":78,"column":23},"end":{"line":78,"column":32}}}) : helper)))
      + " "
      + alias4(((helper = (helper = lookupProperty(helpers,"textStatus") || (depth0 != null ? lookupProperty(depth0,"textStatus") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"textStatus","hash":{},"data":data,"loc":{"start":{"line":78,"column":33},"end":{"line":78,"column":47}}}) : helper)))
      + " does not imply endorsement by the PCISIG. This is a draft document and\r\n        may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document\r\n        as other than work in progress.\r\n      </p>\r\n";
  },"34":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<p>"
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"addPatentNote") || (depth0 != null ? lookupProperty(depth0,"addPatentNote") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"addPatentNote","hash":{},"data":data,"loc":{"start":{"line":83,"column":28},"end":{"line":83,"column":47}}}) : helper))) != null ? stack1 : "")
      + "</p>";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<h2>"
      + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"sotd") : stack1), depth0))
      + "</h2>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isPreview") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":0},"end":{"line":10,"column":7}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isUnofficial") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"data":data,"loc":{"start":{"line":11,"column":0},"end":{"line":85,"column":7}}})) != null ? stack1 : "")
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalSections") || (depth0 != null ? lookupProperty(depth0,"additionalSections") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"additionalSections","hash":{},"data":data,"loc":{"start":{"line":86,"column":0},"end":{"line":86,"column":24}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"useData":true});
  templates['cgbg-headers.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    "
      + ((stack1 = (lookupProperty(helpers,"showLogos")||(depth0 && lookupProperty(depth0,"showLogos"))||container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"logos") : depth0),{"name":"showLogos","hash":{},"data":data,"loc":{"start":{"line":6,"column":4},"end":{"line":6,"column":25}}})) != null ? stack1 : "")
      + "\r\n";
  },"3":function(container,depth0,helpers,partials,data) {
      return " property='dc:title'";
  },"5":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    <h2 "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":10,"column":8},"end":{"line":10,"column":54}}})) != null ? stack1 : "")
      + "id='subtitle'>"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"subtitle") || (depth0 != null ? lookupProperty(depth0,"subtitle") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"subtitle","hash":{},"data":data,"loc":{"start":{"line":10,"column":68},"end":{"line":10,"column":80}}}) : helper)))
      + "</h2>\r\n";
  },"6":function(container,depth0,helpers,partials,data) {
      return "property='bibo:subtitle' ";
  },"8":function(container,depth0,helpers,partials,data) {
      return "property=\"dc:issued\"";
  },"10":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.escapeExpression, alias2=depth0 != null ? depth0 : (container.nullContext || {}), alias3=container.hooks.helperMissing, alias4="function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + alias1(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"this_version") : stack1), depth0))
      + "</dt>\r\n      <dd><a class='u-url' href='"
      + alias1(((helper = (helper = lookupProperty(helpers,"thisVersion") || (depth0 != null ? lookupProperty(depth0,"thisVersion") : depth0)) != null ? helper : alias3),(typeof helper === alias4 ? helper.call(alias2,{"name":"thisVersion","hash":{},"data":data,"loc":{"start":{"line":16,"column":33},"end":{"line":16,"column":48}}}) : helper)))
      + "'>"
      + alias1(((helper = (helper = lookupProperty(helpers,"thisVersion") || (depth0 != null ? lookupProperty(depth0,"thisVersion") : depth0)) != null ? helper : alias3),(typeof helper === alias4 ? helper.call(alias2,{"name":"thisVersion","hash":{},"data":data,"loc":{"start":{"line":16,"column":50},"end":{"line":16,"column":65}}}) : helper)))
      + "</a></dd>\r\n";
  },"12":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.escapeExpression, alias2=depth0 != null ? depth0 : (container.nullContext || {}), alias3=container.hooks.helperMissing, alias4="function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + alias1(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"latest_published_version") : stack1), depth0))
      + "</dt>\r\n      <dd><a href='"
      + alias1(((helper = (helper = lookupProperty(helpers,"latestVersion") || (depth0 != null ? lookupProperty(depth0,"latestVersion") : depth0)) != null ? helper : alias3),(typeof helper === alias4 ? helper.call(alias2,{"name":"latestVersion","hash":{},"data":data,"loc":{"start":{"line":20,"column":19},"end":{"line":20,"column":36}}}) : helper)))
      + "'>"
      + alias1(((helper = (helper = lookupProperty(helpers,"latestVersion") || (depth0 != null ? lookupProperty(depth0,"latestVersion") : depth0)) != null ? helper : alias3),(typeof helper === alias4 ? helper.call(alias2,{"name":"latestVersion","hash":{},"data":data,"loc":{"start":{"line":20,"column":38},"end":{"line":20,"column":55}}}) : helper)))
      + "</a></dd>\r\n";
  },"14":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.escapeExpression, alias2=depth0 != null ? depth0 : (container.nullContext || {}), alias3=container.hooks.helperMissing, alias4="function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + alias1(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"latest_editors_draft") : stack1), depth0))
      + "</dt>\r\n      <dd><a href='"
      + alias1(((helper = (helper = lookupProperty(helpers,"edDraftURI") || (depth0 != null ? lookupProperty(depth0,"edDraftURI") : depth0)) != null ? helper : alias3),(typeof helper === alias4 ? helper.call(alias2,{"name":"edDraftURI","hash":{},"data":data,"loc":{"start":{"line":24,"column":19},"end":{"line":24,"column":33}}}) : helper)))
      + "'>"
      + alias1(((helper = (helper = lookupProperty(helpers,"edDraftURI") || (depth0 != null ? lookupProperty(depth0,"edDraftURI") : depth0)) != null ? helper : alias3),(typeof helper === alias4 ? helper.call(alias2,{"name":"edDraftURI","hash":{},"data":data,"loc":{"start":{"line":24,"column":35},"end":{"line":24,"column":49}}}) : helper)))
      + "</a></dd>\r\n";
  },"16":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>Test suite:</dt>\r\n      <dd><a href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"testSuiteURI") || (depth0 != null ? lookupProperty(depth0,"testSuiteURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"testSuiteURI","hash":{},"data":data,"loc":{"start":{"line":28,"column":19},"end":{"line":28,"column":35}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"testSuiteURI") || (depth0 != null ? lookupProperty(depth0,"testSuiteURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"testSuiteURI","hash":{},"data":data,"loc":{"start":{"line":28,"column":37},"end":{"line":28,"column":53}}}) : helper)))
      + "</a></dd>\r\n";
  },"18":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>Implementation report:</dt>\r\n      <dd><a href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"implementationReportURI") || (depth0 != null ? lookupProperty(depth0,"implementationReportURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"implementationReportURI","hash":{},"data":data,"loc":{"start":{"line":32,"column":19},"end":{"line":32,"column":46}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"implementationReportURI") || (depth0 != null ? lookupProperty(depth0,"implementationReportURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"implementationReportURI","hash":{},"data":data,"loc":{"start":{"line":32,"column":48},"end":{"line":32,"column":75}}}) : helper)))
      + "</a></dd>\r\n";
  },"20":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"bug_tracker") : stack1), depth0))
      + "</dt>\r\n      <dd>"
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"bugTrackerHTML") || (depth0 != null ? lookupProperty(depth0,"bugTrackerHTML") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"bugTrackerHTML","hash":{},"data":data,"loc":{"start":{"line":36,"column":10},"end":{"line":36,"column":30}}}) : helper))) != null ? stack1 : "")
      + "</dd>\r\n";
  },"22":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>Previous version:</dt>\r\n      <dd><a "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(23, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":40,"column":13},"end":{"line":40,"column":56}}})) != null ? stack1 : "")
      + " href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevVersion") || (depth0 != null ? lookupProperty(depth0,"prevVersion") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevVersion","hash":{},"data":data,"loc":{"start":{"line":40,"column":63},"end":{"line":40,"column":78}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevVersion") || (depth0 != null ? lookupProperty(depth0,"prevVersion") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevVersion","hash":{},"data":data,"loc":{"start":{"line":40,"column":80},"end":{"line":40,"column":95}}}) : helper)))
      + "</a></dd>\r\n";
  },"23":function(container,depth0,helpers,partials,data) {
      return "rel=\"dcterms:replaces\"";
  },"25":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"prevED") : depth0),{"name":"if","hash":{},"fn":container.program(26, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":43,"column":6},"end":{"line":46,"column":13}}})) != null ? stack1 : "");
  },"26":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "        <dt>Previous editor's draft:</dt>\r\n        <dd><a href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevED") || (depth0 != null ? lookupProperty(depth0,"prevED") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevED","hash":{},"data":data,"loc":{"start":{"line":45,"column":21},"end":{"line":45,"column":31}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevED") || (depth0 != null ? lookupProperty(depth0,"prevED") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevED","hash":{},"data":data,"loc":{"start":{"line":45,"column":33},"end":{"line":45,"column":43}}}) : helper)))
      + "</a></dd>\r\n";
  },"28":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"editors") : stack1), depth0));
  },"30":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"editor") : stack1), depth0));
  },"32":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"multipleAuthors") : depth0),{"name":"if","hash":{},"fn":container.program(33, data, 0),"inverse":container.program(35, data, 0),"data":data,"loc":{"start":{"line":51,"column":10},"end":{"line":51,"column":79}}})) != null ? stack1 : "")
      + "</dt>\r\n      "
      + container.escapeExpression((lookupProperty(helpers,"showPeople")||(depth0 && lookupProperty(depth0,"showPeople"))||container.hooks.helperMissing).call(alias1,"Author",(depth0 != null ? lookupProperty(depth0,"authors") : depth0),{"name":"showPeople","hash":{},"data":data,"loc":{"start":{"line":52,"column":6},"end":{"line":52,"column":37}}}))
      + "\r\n";
  },"33":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"authors") : stack1), depth0));
  },"35":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"author") : stack1), depth0));
  },"37":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"each").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"otherLinks") : depth0),{"name":"each","hash":{},"fn":container.program(38, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":55,"column":6},"end":{"line":88,"column":15}}})) != null ? stack1 : "");
  },"38":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"key") : depth0),{"name":"if","hash":{},"fn":container.program(39, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":56,"column":8},"end":{"line":87,"column":15}}})) != null ? stack1 : "");
  },"39":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "          <dt "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"class") : depth0),{"name":"if","hash":{},"fn":container.program(40, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":57,"column":14},"end":{"line":57,"column":51}}})) != null ? stack1 : "")
      + ">"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"key") || (depth0 != null ? lookupProperty(depth0,"key") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"key","hash":{},"data":data,"loc":{"start":{"line":57,"column":52},"end":{"line":57,"column":59}}}) : helper)))
      + ":</dt>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"data") : depth0),{"name":"if","hash":{},"fn":container.program(42, data, 0),"inverse":container.program(52, data, 0),"data":data,"loc":{"start":{"line":58,"column":10},"end":{"line":86,"column":17}}})) != null ? stack1 : "");
  },"40":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "class=\""
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"class") || (depth0 != null ? lookupProperty(depth0,"class") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"class","hash":{},"data":data,"loc":{"start":{"line":57,"column":34},"end":{"line":57,"column":43}}}) : helper)))
      + "\"";
  },"42":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"each").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"data") : depth0),{"name":"each","hash":{},"fn":container.program(43, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":59,"column":13},"end":{"line":71,"column":22}}})) != null ? stack1 : "");
  },"43":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"value") : depth0),{"name":"if","hash":{},"fn":container.program(44, data, 0),"inverse":container.program(49, data, 0),"data":data,"loc":{"start":{"line":60,"column":16},"end":{"line":70,"column":23}}})) != null ? stack1 : "");
  },"44":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "                  <dd "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"class") : depth0),{"name":"if","hash":{},"fn":container.program(40, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":61,"column":22},"end":{"line":61,"column":59}}})) != null ? stack1 : "")
      + ">\r\n                    "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(45, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":62,"column":20},"end":{"line":62,"column":58}}})) != null ? stack1 : "")
      + "\r\n                      "
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"value") || (depth0 != null ? lookupProperty(depth0,"value") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"value","hash":{},"data":data,"loc":{"start":{"line":63,"column":22},"end":{"line":63,"column":31}}}) : helper)))
      + "\r\n                    "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(47, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":64,"column":20},"end":{"line":64,"column":43}}})) != null ? stack1 : "")
      + "\r\n                  </dd>\r\n";
  },"45":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<a href=\""
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"href","hash":{},"data":data,"loc":{"start":{"line":62,"column":41},"end":{"line":62,"column":49}}}) : helper)))
      + "\">";
  },"47":function(container,depth0,helpers,partials,data) {
      return "</a>";
  },"49":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(50, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":67,"column":18},"end":{"line":69,"column":25}}})) != null ? stack1 : "");
  },"50":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "                    <dd><a href=\""
      + alias4(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"href","hash":{},"data":data,"loc":{"start":{"line":68,"column":33},"end":{"line":68,"column":41}}}) : helper)))
      + "\">"
      + alias4(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"href","hash":{},"data":data,"loc":{"start":{"line":68,"column":43},"end":{"line":68,"column":51}}}) : helper)))
      + "</a></dd>\r\n";
  },"52":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"value") : depth0),{"name":"if","hash":{},"fn":container.program(53, data, 0),"inverse":container.program(55, data, 0),"data":data,"loc":{"start":{"line":73,"column":12},"end":{"line":85,"column":19}}})) != null ? stack1 : "");
  },"53":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "              <dd "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"class") : depth0),{"name":"if","hash":{},"fn":container.program(40, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":74,"column":18},"end":{"line":74,"column":55}}})) != null ? stack1 : "")
      + ">\r\n                "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(45, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":75,"column":16},"end":{"line":75,"column":54}}})) != null ? stack1 : "")
      + "\r\n                  "
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"value") || (depth0 != null ? lookupProperty(depth0,"value") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"value","hash":{},"data":data,"loc":{"start":{"line":76,"column":18},"end":{"line":76,"column":27}}}) : helper)))
      + "\r\n                "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(47, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":77,"column":16},"end":{"line":77,"column":39}}})) != null ? stack1 : "")
      + "\r\n              </dd>\r\n";
  },"55":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(56, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":80,"column":14},"end":{"line":84,"column":21}}})) != null ? stack1 : "");
  },"56":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "                <dd "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"class") : depth0),{"name":"if","hash":{},"fn":container.program(40, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":81,"column":20},"end":{"line":81,"column":57}}})) != null ? stack1 : "")
      + ">\r\n                  <a href=\""
      + alias4(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"href","hash":{},"data":data,"loc":{"start":{"line":82,"column":27},"end":{"line":82,"column":35}}}) : helper)))
      + "\">"
      + alias4(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"href","hash":{},"data":data,"loc":{"start":{"line":82,"column":37},"end":{"line":82,"column":45}}}) : helper)))
      + "</a>\r\n                </dd>\r\n";
  },"58":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    <p>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"multipleAlternates") : depth0),{"name":"if","hash":{},"fn":container.program(59, data, 0),"inverse":container.program(61, data, 0),"data":data,"loc":{"start":{"line":93,"column":6},"end":{"line":97,"column":13}}})) != null ? stack1 : "")
      + "      "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"alternatesHTML") || (depth0 != null ? lookupProperty(depth0,"alternatesHTML") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"alternatesHTML","hash":{},"data":data,"loc":{"start":{"line":98,"column":6},"end":{"line":98,"column":26}}}) : helper))) != null ? stack1 : "")
      + "\r\n    </p>\r\n";
  },"59":function(container,depth0,helpers,partials,data) {
      return "        This document is also available in these non-normative formats: \r\n";
  },"61":function(container,depth0,helpers,partials,data) {
      return "        This document is also available in this non-normative format: \r\n";
  },"63":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(((helper = (helper = lookupProperty(helpers,"copyrightStart") || (depth0 != null ? lookupProperty(depth0,"copyrightStart") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"copyrightStart","hash":{},"data":data,"loc":{"start":{"line":103,"column":26},"end":{"line":103,"column":44}}}) : helper)))
      + "-";
  },"65":function(container,depth0,helpers,partials,data) {
      return "      <a href=\"https://www.w3.org/community/about/agreements/fsa/\">W3C Community Final Specification Agreement (FSA)</a>. \r\n      A human-readable <a href=\"https://www.w3.org/community/about/agreements/fsa-deed/\">summary</a> is available.\r\n";
  },"67":function(container,depth0,helpers,partials,data) {
      return "      <a href=\"https://www.w3.org/community/about/agreements/cla/\">W3C Community Contributor License Agreement (CLA)</a>.\r\n      A human-readable <a href=\"https://www.w3.org/community/about/agreements/cla-deed/\">summary</a> is available.\r\n";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<div class='head'>\r\n  <p>\r\n    <a class='logo' href='https://www.w3.org/'><img width='72' height='48' src='https://www.w3.org/StyleSheets/TR/2016/logos/W3C' alt='W3C'></a>\r\n  </p>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"logos") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":5,"column":2},"end":{"line":7,"column":9}}})) != null ? stack1 : "")
      + "  <h1 class='title p-name' id='title'"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":8,"column":37},"end":{"line":8,"column":78}}})) != null ? stack1 : "")
      + ">"
      + alias4(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data,"loc":{"start":{"line":8,"column":79},"end":{"line":8,"column":88}}}) : helper)))
      + "</h1>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"subtitle") : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":9,"column":2},"end":{"line":11,"column":9}}})) != null ? stack1 : "")
      + "  <h2>"
      + alias4(((helper = (helper = lookupProperty(helpers,"longStatus") || (depth0 != null ? lookupProperty(depth0,"longStatus") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"longStatus","hash":{},"data":data,"loc":{"start":{"line":12,"column":6},"end":{"line":12,"column":20}}}) : helper)))
      + " <time "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(8, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":12,"column":27},"end":{"line":12,"column":68}}})) != null ? stack1 : "")
      + "class='dt-published' datetime='"
      + alias4(((helper = (helper = lookupProperty(helpers,"dashDate") || (depth0 != null ? lookupProperty(depth0,"dashDate") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"dashDate","hash":{},"data":data,"loc":{"start":{"line":12,"column":99},"end":{"line":12,"column":111}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"publishHumanDate") || (depth0 != null ? lookupProperty(depth0,"publishHumanDate") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"publishHumanDate","hash":{},"data":data,"loc":{"start":{"line":12,"column":113},"end":{"line":12,"column":133}}}) : helper)))
      + "</time></h2>\r\n  <dl>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"thisVersion") : depth0),{"name":"if","hash":{},"fn":container.program(10, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":14,"column":4},"end":{"line":17,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"latestVersion") : depth0),{"name":"if","hash":{},"fn":container.program(12, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":18,"column":4},"end":{"line":21,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"edDraftURI") : depth0),{"name":"if","hash":{},"fn":container.program(14, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":22,"column":4},"end":{"line":25,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"testSuiteURI") : depth0),{"name":"if","hash":{},"fn":container.program(16, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":26,"column":4},"end":{"line":29,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"implementationReportURI") : depth0),{"name":"if","hash":{},"fn":container.program(18, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":30,"column":4},"end":{"line":33,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"bugTrackerHTML") : depth0),{"name":"if","hash":{},"fn":container.program(20, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":34,"column":4},"end":{"line":37,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"prevVersion") : depth0),{"name":"if","hash":{},"fn":container.program(22, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":38,"column":4},"end":{"line":41,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"unless").call(alias1,(depth0 != null ? lookupProperty(depth0,"isCGFinal") : depth0),{"name":"unless","hash":{},"fn":container.program(25, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":42,"column":4},"end":{"line":47,"column":15}}})) != null ? stack1 : "")
      + "    <dt>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"multipleEditors") : depth0),{"name":"if","hash":{},"fn":container.program(28, data, 0),"inverse":container.program(30, data, 0),"data":data,"loc":{"start":{"line":48,"column":8},"end":{"line":48,"column":77}}})) != null ? stack1 : "")
      + "</dt>\r\n    "
      + alias4((lookupProperty(helpers,"showPeople")||(depth0 && lookupProperty(depth0,"showPeople"))||alias2).call(alias1,"Editor",(depth0 != null ? lookupProperty(depth0,"editors") : depth0),{"name":"showPeople","hash":{},"data":data,"loc":{"start":{"line":49,"column":4},"end":{"line":49,"column":35}}}))
      + "\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"authors") : depth0),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":50,"column":4},"end":{"line":53,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"otherLinks") : depth0),{"name":"if","hash":{},"fn":container.program(37, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":54,"column":4},"end":{"line":89,"column":11}}})) != null ? stack1 : "")
      + "  </dl>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"alternateFormats") : depth0),{"name":"if","hash":{},"fn":container.program(58, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":91,"column":2},"end":{"line":100,"column":9}}})) != null ? stack1 : "")
      + "  <p class='copyright'>\r\n    <a href='https://www.w3.org/Consortium/Legal/ipr-notice#Copyright'>Copyright</a> &copy;\r\n    "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"copyrightStart") : depth0),{"name":"if","hash":{},"fn":container.program(63, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":103,"column":4},"end":{"line":103,"column":52}}})) != null ? stack1 : "")
      + alias4(((helper = (helper = lookupProperty(helpers,"publishYear") || (depth0 != null ? lookupProperty(depth0,"publishYear") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"publishYear","hash":{},"data":data,"loc":{"start":{"line":103,"column":52},"end":{"line":103,"column":67}}}) : helper)))
      + "\r\n    the Contributors to the "
      + alias4(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data,"loc":{"start":{"line":104,"column":28},"end":{"line":104,"column":37}}}) : helper)))
      + " Specification, published by the\r\n    <a href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgURI") || (depth0 != null ? lookupProperty(depth0,"wgURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgURI","hash":{},"data":data,"loc":{"start":{"line":105,"column":13},"end":{"line":105,"column":22}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"wg") || (depth0 != null ? lookupProperty(depth0,"wg") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wg","hash":{},"data":data,"loc":{"start":{"line":105,"column":24},"end":{"line":105,"column":30}}}) : helper)))
      + "</a> under the\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isCGFinal") : depth0),{"name":"if","hash":{},"fn":container.program(65, data, 0),"inverse":container.program(67, data, 0),"data":data,"loc":{"start":{"line":106,"column":4},"end":{"line":112,"column":11}}})) != null ? stack1 : "")
      + "  </p>\r\n  <hr title=\"Separator for header\">\r\n</div>\r\n";
  },"useData":true});
  templates['cgbg-sotd.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "  <details class=\"annoying-warning\" open=\"\">\r\n    <summary>This is a preview</summary>\r\n    <p>\r\n      Do not attempt to implement this version of the specification. Do not reference this\r\n      version as authoritative in any way.\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"edDraftURI") : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":8,"column":6},"end":{"line":10,"column":13}}})) != null ? stack1 : "")
      + "    </p>\r\n  </details>\r\n";
  },"2":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "        Instead, see <a href=\""
      + alias4(((helper = (helper = lookupProperty(helpers,"edDraftURI") || (depth0 != null ? lookupProperty(depth0,"edDraftURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"edDraftURI","hash":{},"data":data,"loc":{"start":{"line":9,"column":30},"end":{"line":9,"column":44}}}) : helper)))
      + "\">"
      + alias4(((helper = (helper = lookupProperty(helpers,"edDraftURI") || (depth0 != null ? lookupProperty(depth0,"edDraftURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"edDraftURI","hash":{},"data":data,"loc":{"start":{"line":9,"column":46},"end":{"line":9,"column":60}}}) : helper)))
      + "</a> for the Editor's draft.\r\n";
  },"4":function(container,depth0,helpers,partials,data) {
      return "    Please note that under the\r\n    <a href=\"https://www.w3.org/community/about/agreements/final/\">W3C Community Final Specification Agreement (FSA)</a>\r\n    other conditions apply.\r\n";
  },"6":function(container,depth0,helpers,partials,data) {
      return "    Please note that under the\r\n    <a href=\"https://www.w3.org/community/about/agreements/cla/\">W3C Community Contributor License Agreement (CLA)</a>\r\n    there is a limited opt-out and other conditions apply.\r\n";
  },"8":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "  "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalContent") || (depth0 != null ? lookupProperty(depth0,"additionalContent") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"additionalContent","hash":{},"data":data,"loc":{"start":{"line":30,"column":2},"end":{"line":30,"column":25}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"10":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    <p>If you wish to make comments regarding this document, please send them to\r\n    <a href='mailto:"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":34,"column":20},"end":{"line":34,"column":36}}}) : helper)))
      + "@w3.org"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"subjectPrefix") : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":34,"column":43},"end":{"line":34,"column":100}}})) != null ? stack1 : "")
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":34,"column":102},"end":{"line":34,"column":118}}}) : helper)))
      + "@w3.org</a>\r\n    (<a href='mailto:"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":35,"column":21},"end":{"line":35,"column":37}}}) : helper)))
      + "-request@w3.org?subject=subscribe'>subscribe</a>,\r\n    <a\r\n      href='https://lists.w3.org/Archives/Public/"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":37,"column":49},"end":{"line":37,"column":65}}}) : helper)))
      + "/'>archives</a>)"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"subjectPrefix") : depth0),{"name":"if","hash":{},"fn":container.program(13, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":37,"column":81},"end":{"line":39,"column":26}}})) != null ? stack1 : "")
      + ".</p>\r\n";
  },"11":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "?subject="
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"subjectPrefixEnc") || (depth0 != null ? lookupProperty(depth0,"subjectPrefixEnc") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"subjectPrefixEnc","hash":{},"data":data,"loc":{"start":{"line":34,"column":73},"end":{"line":34,"column":93}}}) : helper)));
  },"13":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "\r\n    with <code>"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"subjectPrefix") || (depth0 != null ? lookupProperty(depth0,"subjectPrefix") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"subjectPrefix","hash":{},"data":data,"loc":{"start":{"line":38,"column":15},"end":{"line":38,"column":32}}}) : helper)))
      + "</code> at the start of your\r\n    email's subject";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.escapeExpression, alias2=depth0 != null ? depth0 : (container.nullContext || {}), alias3=container.hooks.helperMissing, alias4="function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<h2>"
      + alias1(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"sotd") : stack1), depth0))
      + "</h2>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias2,(depth0 != null ? lookupProperty(depth0,"isPreview") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":0},"end":{"line":13,"column":7}}})) != null ? stack1 : "")
      + "<p>\r\n  This specification was published by the <a href='"
      + alias1(((helper = (helper = lookupProperty(helpers,"wgURI") || (depth0 != null ? lookupProperty(depth0,"wgURI") : depth0)) != null ? helper : alias3),(typeof helper === alias4 ? helper.call(alias2,{"name":"wgURI","hash":{},"data":data,"loc":{"start":{"line":15,"column":51},"end":{"line":15,"column":60}}}) : helper)))
      + "'>"
      + alias1(((helper = (helper = lookupProperty(helpers,"wg") || (depth0 != null ? lookupProperty(depth0,"wg") : depth0)) != null ? helper : alias3),(typeof helper === alias4 ? helper.call(alias2,{"name":"wg","hash":{},"data":data,"loc":{"start":{"line":15,"column":62},"end":{"line":15,"column":68}}}) : helper)))
      + "</a>.\r\n  It is not a W3C Standard nor is it on the W3C Standards Track.\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias2,(depth0 != null ? lookupProperty(depth0,"isCGFinal") : depth0),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.program(6, data, 0),"data":data,"loc":{"start":{"line":17,"column":2},"end":{"line":25,"column":9}}})) != null ? stack1 : "")
      + "  Learn more about\r\n  <a href=\"https://www.w3.org/community/\">W3C Community and Business Groups</a>.\r\n</p>\r\n"
      + ((stack1 = lookupProperty(helpers,"unless").call(alias2,(depth0 != null ? lookupProperty(depth0,"sotdAfterWGinfo") : depth0),{"name":"unless","hash":{},"fn":container.program(8, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":29,"column":0},"end":{"line":31,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias2,(depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0),{"name":"if","hash":{},"fn":container.program(10, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":32,"column":2},"end":{"line":40,"column":9}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias2,(depth0 != null ? lookupProperty(depth0,"sotdAfterWGinfo") : depth0),{"name":"if","hash":{},"fn":container.program(8, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":41,"column":0},"end":{"line":43,"column":7}}})) != null ? stack1 : "")
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalSections") || (depth0 != null ? lookupProperty(depth0,"additionalSections") : depth0)) != null ? helper : alias3),(typeof helper === alias4 ? helper.call(alias2,{"name":"additionalSections","hash":{},"data":data,"loc":{"start":{"line":44,"column":0},"end":{"line":44,"column":24}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"useData":true});
  templates['conformance.html'] = template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      return "<h2>Conformance</h2>\r\n<p>\r\n  As well as sections marked as non-normative, all authoring guidelines, diagrams, examples,\r\n  and notes in this specification are non-normative. Everything else in this specification is\r\n  normative.\r\n</p>\r\n<p id='respecRFC2119'>\r\n  to be interpreted as described in [[!RFC2119]].\r\n</p>\r\n";
  },"useData":true});
  templates['headers.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      return "    <p>\r\n      <a class='logo' href='https://www.w3.org/'><img width='72' height='48' src='https://www.w3.org/StyleSheets/TR/2016/logos/W3C' alt='W3C'></a>\r\n    </p>\r\n";
  },"3":function(container,depth0,helpers,partials,data) {
      return " property='dcterms:title'";
  },"5":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    <h2 "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":10,"column":8},"end":{"line":10,"column":54}}})) != null ? stack1 : "")
      + "id='subtitle'>"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"subtitle") || (depth0 != null ? lookupProperty(depth0,"subtitle") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"subtitle","hash":{},"data":data,"loc":{"start":{"line":10,"column":68},"end":{"line":10,"column":80}}}) : helper)))
      + "</h2>\r\n";
  },"6":function(container,depth0,helpers,partials,data) {
      return "property='bibo:subtitle' ";
  },"8":function(container,depth0,helpers,partials,data) {
      return "W3C ";
  },"10":function(container,depth0,helpers,partials,data) {
      return "property=\"dcterms:issued\"";
  },"12":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), alias4=container.hooks.helperMissing, alias5="function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"this_version") : stack1), depth0))
      + "</dt>\r\n      <dd><a class='u-url' href='"
      + alias2(((helper = (helper = lookupProperty(helpers,"thisVersion") || (depth0 != null ? lookupProperty(depth0,"thisVersion") : depth0)) != null ? helper : alias4),(typeof helper === alias5 ? helper.call(alias3,{"name":"thisVersion","hash":{},"data":data,"loc":{"start":{"line":16,"column":33},"end":{"line":16,"column":48}}}) : helper)))
      + "'>"
      + alias2(((helper = (helper = lookupProperty(helpers,"thisVersion") || (depth0 != null ? lookupProperty(depth0,"thisVersion") : depth0)) != null ? helper : alias4),(typeof helper === alias5 ? helper.call(alias3,{"name":"thisVersion","hash":{},"data":data,"loc":{"start":{"line":16,"column":50},"end":{"line":16,"column":65}}}) : helper)))
      + "</a></dd>\r\n      <dt>"
      + alias2(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"latest_published_version") : stack1), depth0))
      + "</dt>\r\n      <dd>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias3,(depth0 != null ? lookupProperty(depth0,"latestVersion") : depth0),{"name":"if","hash":{},"fn":container.program(13, data, 0),"inverse":container.program(15, data, 0),"data":data,"loc":{"start":{"line":18,"column":10},"end":{"line":18,"column":99}}})) != null ? stack1 : "")
      + "</dd>\r\n";
  },"13":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<a href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"latestVersion") || (depth0 != null ? lookupProperty(depth0,"latestVersion") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"latestVersion","hash":{},"data":data,"loc":{"start":{"line":18,"column":40},"end":{"line":18,"column":57}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"latestVersion") || (depth0 != null ? lookupProperty(depth0,"latestVersion") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"latestVersion","hash":{},"data":data,"loc":{"start":{"line":18,"column":59},"end":{"line":18,"column":76}}}) : helper)))
      + "</a>";
  },"15":function(container,depth0,helpers,partials,data) {
      return "none";
  },"17":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.escapeExpression, alias2=depth0 != null ? depth0 : (container.nullContext || {}), alias3=container.hooks.helperMissing, alias4="function", lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + alias1(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"latest_editors_draft") : stack1), depth0))
      + "</dt>\r\n      <dd><a href='"
      + alias1(((helper = (helper = lookupProperty(helpers,"edDraftURI") || (depth0 != null ? lookupProperty(depth0,"edDraftURI") : depth0)) != null ? helper : alias3),(typeof helper === alias4 ? helper.call(alias2,{"name":"edDraftURI","hash":{},"data":data,"loc":{"start":{"line":22,"column":19},"end":{"line":22,"column":33}}}) : helper)))
      + "'>"
      + alias1(((helper = (helper = lookupProperty(helpers,"edDraftURI") || (depth0 != null ? lookupProperty(depth0,"edDraftURI") : depth0)) != null ? helper : alias3),(typeof helper === alias4 ? helper.call(alias2,{"name":"edDraftURI","hash":{},"data":data,"loc":{"start":{"line":22,"column":35},"end":{"line":22,"column":49}}}) : helper)))
      + "</a></dd>\r\n";
  },"19":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>Test suite:</dt>\r\n      <dd><a href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"testSuiteURI") || (depth0 != null ? lookupProperty(depth0,"testSuiteURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"testSuiteURI","hash":{},"data":data,"loc":{"start":{"line":26,"column":19},"end":{"line":26,"column":35}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"testSuiteURI") || (depth0 != null ? lookupProperty(depth0,"testSuiteURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"testSuiteURI","hash":{},"data":data,"loc":{"start":{"line":26,"column":37},"end":{"line":26,"column":53}}}) : helper)))
      + "</a></dd>\r\n";
  },"21":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>Implementation report:</dt>\r\n      <dd><a href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"implementationReportURI") || (depth0 != null ? lookupProperty(depth0,"implementationReportURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"implementationReportURI","hash":{},"data":data,"loc":{"start":{"line":30,"column":19},"end":{"line":30,"column":46}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"implementationReportURI") || (depth0 != null ? lookupProperty(depth0,"implementationReportURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"implementationReportURI","hash":{},"data":data,"loc":{"start":{"line":30,"column":48},"end":{"line":30,"column":75}}}) : helper)))
      + "</a></dd>\r\n";
  },"23":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"bug_tracker") : stack1), depth0))
      + "</dt>\r\n      <dd>"
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"bugTrackerHTML") || (depth0 != null ? lookupProperty(depth0,"bugTrackerHTML") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"bugTrackerHTML","hash":{},"data":data,"loc":{"start":{"line":34,"column":10},"end":{"line":34,"column":30}}}) : helper))) != null ? stack1 : "")
      + "</dd>\r\n";
  },"25":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"prevED") : depth0),{"name":"if","hash":{},"fn":container.program(26, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":37,"column":6},"end":{"line":40,"column":13}}})) != null ? stack1 : "");
  },"26":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "        <dt>Previous editor's draft:</dt>\r\n        <dd><a href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevED") || (depth0 != null ? lookupProperty(depth0,"prevED") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevED","hash":{},"data":data,"loc":{"start":{"line":39,"column":21},"end":{"line":39,"column":31}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevED") || (depth0 != null ? lookupProperty(depth0,"prevED") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevED","hash":{},"data":data,"loc":{"start":{"line":39,"column":33},"end":{"line":39,"column":43}}}) : helper)))
      + "</a></dd>\r\n";
  },"28":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>Previous version:</dt>\r\n      <dd><a "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(29, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":44,"column":13},"end":{"line":44,"column":56}}})) != null ? stack1 : "")
      + " href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevVersion") || (depth0 != null ? lookupProperty(depth0,"prevVersion") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevVersion","hash":{},"data":data,"loc":{"start":{"line":44,"column":63},"end":{"line":44,"column":78}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevVersion") || (depth0 != null ? lookupProperty(depth0,"prevVersion") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevVersion","hash":{},"data":data,"loc":{"start":{"line":44,"column":80},"end":{"line":44,"column":95}}}) : helper)))
      + "</a></dd>\r\n";
  },"29":function(container,depth0,helpers,partials,data) {
      return "rel=\"dcterms:replaces\"";
  },"31":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"isRec") : depth0),{"name":"if","hash":{},"fn":container.program(32, data, 0),"inverse":container.program(34, data, 0),"data":data,"loc":{"start":{"line":47,"column":6},"end":{"line":53,"column":13}}})) != null ? stack1 : "");
  },"32":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "          <dt>Previous Recommendation:</dt>\r\n          <dd><a "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(29, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":49,"column":17},"end":{"line":49,"column":60}}})) != null ? stack1 : "")
      + " href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevRecURI") || (depth0 != null ? lookupProperty(depth0,"prevRecURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevRecURI","hash":{},"data":data,"loc":{"start":{"line":49,"column":67},"end":{"line":49,"column":81}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevRecURI") || (depth0 != null ? lookupProperty(depth0,"prevRecURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevRecURI","hash":{},"data":data,"loc":{"start":{"line":49,"column":83},"end":{"line":49,"column":97}}}) : helper)))
      + "</a></dd>\r\n";
  },"34":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "          <dt>Latest Recommendation:</dt>\r\n          <dd><a href='"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevRecURI") || (depth0 != null ? lookupProperty(depth0,"prevRecURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevRecURI","hash":{},"data":data,"loc":{"start":{"line":52,"column":23},"end":{"line":52,"column":37}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"prevRecURI") || (depth0 != null ? lookupProperty(depth0,"prevRecURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"prevRecURI","hash":{},"data":data,"loc":{"start":{"line":52,"column":39},"end":{"line":52,"column":53}}}) : helper)))
      + "</a></dd>\r\n";
  },"36":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"editors") : stack1), depth0));
  },"38":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"editor") : stack1), depth0));
  },"40":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <dt>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"multipleAuthors") : depth0),{"name":"if","hash":{},"fn":container.program(41, data, 0),"inverse":container.program(43, data, 0),"data":data,"loc":{"start":{"line":58,"column":10},"end":{"line":58,"column":79}}})) != null ? stack1 : "")
      + "</dt>\r\n      "
      + container.escapeExpression((lookupProperty(helpers,"showPeople")||(depth0 && lookupProperty(depth0,"showPeople"))||container.hooks.helperMissing).call(alias1,"Author",(depth0 != null ? lookupProperty(depth0,"authors") : depth0),{"name":"showPeople","hash":{},"data":data,"loc":{"start":{"line":59,"column":6},"end":{"line":59,"column":37}}}))
      + "\r\n";
  },"41":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"authors") : stack1), depth0));
  },"43":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"author") : stack1), depth0));
  },"45":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"each").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"otherLinks") : depth0),{"name":"each","hash":{},"fn":container.program(46, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":62,"column":6},"end":{"line":95,"column":15}}})) != null ? stack1 : "");
  },"46":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"key") : depth0),{"name":"if","hash":{},"fn":container.program(47, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":63,"column":8},"end":{"line":94,"column":15}}})) != null ? stack1 : "");
  },"47":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "          <dt "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"class") : depth0),{"name":"if","hash":{},"fn":container.program(48, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":64,"column":14},"end":{"line":64,"column":51}}})) != null ? stack1 : "")
      + ">"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"key") || (depth0 != null ? lookupProperty(depth0,"key") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"key","hash":{},"data":data,"loc":{"start":{"line":64,"column":52},"end":{"line":64,"column":59}}}) : helper)))
      + ":</dt>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"data") : depth0),{"name":"if","hash":{},"fn":container.program(50, data, 0),"inverse":container.program(60, data, 0),"data":data,"loc":{"start":{"line":65,"column":10},"end":{"line":93,"column":17}}})) != null ? stack1 : "");
  },"48":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "class=\""
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"class") || (depth0 != null ? lookupProperty(depth0,"class") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"class","hash":{},"data":data,"loc":{"start":{"line":64,"column":34},"end":{"line":64,"column":43}}}) : helper)))
      + "\"";
  },"50":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"each").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"data") : depth0),{"name":"each","hash":{},"fn":container.program(51, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":66,"column":13},"end":{"line":78,"column":22}}})) != null ? stack1 : "");
  },"51":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"value") : depth0),{"name":"if","hash":{},"fn":container.program(52, data, 0),"inverse":container.program(57, data, 0),"data":data,"loc":{"start":{"line":67,"column":16},"end":{"line":77,"column":23}}})) != null ? stack1 : "");
  },"52":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "                  <dd "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"class") : depth0),{"name":"if","hash":{},"fn":container.program(48, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":68,"column":22},"end":{"line":68,"column":59}}})) != null ? stack1 : "")
      + ">\r\n                    "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(53, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":69,"column":20},"end":{"line":69,"column":58}}})) != null ? stack1 : "")
      + "\r\n                      "
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"value") || (depth0 != null ? lookupProperty(depth0,"value") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"value","hash":{},"data":data,"loc":{"start":{"line":70,"column":22},"end":{"line":70,"column":31}}}) : helper)))
      + "\r\n                    "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(55, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":71,"column":20},"end":{"line":71,"column":43}}})) != null ? stack1 : "")
      + "\r\n                  </dd>\r\n";
  },"53":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<a href=\""
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"href","hash":{},"data":data,"loc":{"start":{"line":69,"column":41},"end":{"line":69,"column":49}}}) : helper)))
      + "\">";
  },"55":function(container,depth0,helpers,partials,data) {
      return "</a>";
  },"57":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(58, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":74,"column":18},"end":{"line":76,"column":25}}})) != null ? stack1 : "");
  },"58":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "                    <dd><a href=\""
      + alias4(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"href","hash":{},"data":data,"loc":{"start":{"line":75,"column":33},"end":{"line":75,"column":41}}}) : helper)))
      + "\">"
      + alias4(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"href","hash":{},"data":data,"loc":{"start":{"line":75,"column":43},"end":{"line":75,"column":51}}}) : helper)))
      + "</a></dd>\r\n";
  },"60":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"value") : depth0),{"name":"if","hash":{},"fn":container.program(61, data, 0),"inverse":container.program(63, data, 0),"data":data,"loc":{"start":{"line":80,"column":12},"end":{"line":92,"column":19}}})) != null ? stack1 : "");
  },"61":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "              <dd "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"class") : depth0),{"name":"if","hash":{},"fn":container.program(48, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":81,"column":18},"end":{"line":81,"column":55}}})) != null ? stack1 : "")
      + ">\r\n                "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(53, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":82,"column":16},"end":{"line":82,"column":54}}})) != null ? stack1 : "")
      + "\r\n                  "
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"value") || (depth0 != null ? lookupProperty(depth0,"value") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"value","hash":{},"data":data,"loc":{"start":{"line":83,"column":18},"end":{"line":83,"column":27}}}) : helper)))
      + "\r\n                "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(55, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":84,"column":16},"end":{"line":84,"column":39}}})) != null ? stack1 : "")
      + "\r\n              </dd>\r\n";
  },"63":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"href") : depth0),{"name":"if","hash":{},"fn":container.program(64, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":87,"column":14},"end":{"line":91,"column":21}}})) != null ? stack1 : "");
  },"64":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "                <dd "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"class") : depth0),{"name":"if","hash":{},"fn":container.program(48, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":88,"column":20},"end":{"line":88,"column":57}}})) != null ? stack1 : "")
      + ">\r\n                  <a href=\""
      + alias4(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"href","hash":{},"data":data,"loc":{"start":{"line":89,"column":27},"end":{"line":89,"column":35}}}) : helper)))
      + "\">"
      + alias4(((helper = (helper = lookupProperty(helpers,"href") || (depth0 != null ? lookupProperty(depth0,"href") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"href","hash":{},"data":data,"loc":{"start":{"line":89,"column":37},"end":{"line":89,"column":45}}}) : helper)))
      + "</a>\r\n                </dd>\r\n";
  },"66":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    <p>\r\n      Please check the <a href=\""
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"errata") || (depth0 != null ? lookupProperty(depth0,"errata") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"errata","hash":{},"data":data,"loc":{"start":{"line":100,"column":32},"end":{"line":100,"column":42}}}) : helper)))
      + "\"><strong>errata</strong></a> for any errors or issues\r\n      reported since publication.\r\n    </p>\r\n";
  },"68":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    <p>\r\n      See also <a href=\"http://www.w3.org/2003/03/Translations/byTechnology?technology="
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"shortName") || (depth0 != null ? lookupProperty(depth0,"shortName") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"shortName","hash":{},"data":data,"loc":{"start":{"line":106,"column":87},"end":{"line":106,"column":100}}}) : helper)))
      + "\">\r\n      <strong>translations</strong></a>.\r\n    </p>\r\n";
  },"70":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    <p>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"multipleAlternates") : depth0),{"name":"if","hash":{},"fn":container.program(71, data, 0),"inverse":container.program(73, data, 0),"data":data,"loc":{"start":{"line":112,"column":6},"end":{"line":116,"column":13}}})) != null ? stack1 : "")
      + "      "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"alternatesHTML") || (depth0 != null ? lookupProperty(depth0,"alternatesHTML") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"alternatesHTML","hash":{},"data":data,"loc":{"start":{"line":117,"column":6},"end":{"line":117,"column":26}}}) : helper))) != null ? stack1 : "")
      + "\r\n    </p>\r\n";
  },"71":function(container,depth0,helpers,partials,data) {
      return "        This document is also available in these non-normative formats:\r\n";
  },"73":function(container,depth0,helpers,partials,data) {
      return "        This document is also available in this non-normative format:\r\n";
  },"75":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"additionalCopyrightHolders") : depth0),{"name":"if","hash":{},"fn":container.program(76, data, 0),"inverse":container.program(78, data, 0),"data":data,"loc":{"start":{"line":121,"column":4},"end":{"line":133,"column":11}}})) != null ? stack1 : "");
  },"76":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <p class='copyright'>"
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalCopyrightHolders") || (depth0 != null ? lookupProperty(depth0,"additionalCopyrightHolders") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"additionalCopyrightHolders","hash":{},"data":data,"loc":{"start":{"line":122,"column":27},"end":{"line":122,"column":59}}}) : helper))) != null ? stack1 : "")
      + "</p>\r\n";
  },"78":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"overrideCopyright") : depth0),{"name":"if","hash":{},"fn":container.program(79, data, 0),"inverse":container.program(81, data, 0),"data":data,"loc":{"start":{"line":124,"column":6},"end":{"line":132,"column":13}}})) != null ? stack1 : "");
  },"79":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "        "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"overrideCopyright") || (depth0 != null ? lookupProperty(depth0,"overrideCopyright") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"overrideCopyright","hash":{},"data":data,"loc":{"start":{"line":125,"column":8},"end":{"line":125,"column":31}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"81":function(container,depth0,helpers,partials,data) {
      return "        <p class='copyright'>\r\n          This document is licensed under a\r\n          <a class='subfoot' href='https://creativecommons.org/licenses/by/3.0/' rel='license'>Creative Commons\r\n          Attribution 3.0 License</a>.\r\n        </p>\r\n";
  },"83":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"overrideCopyright") : depth0),{"name":"if","hash":{},"fn":container.program(84, data, 0),"inverse":container.program(86, data, 0),"data":data,"loc":{"start":{"line":135,"column":4},"end":{"line":164,"column":11}}})) != null ? stack1 : "");
  },"84":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"overrideCopyright") || (depth0 != null ? lookupProperty(depth0,"overrideCopyright") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"overrideCopyright","hash":{},"data":data,"loc":{"start":{"line":136,"column":6},"end":{"line":136,"column":29}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"86":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <p class='copyright'>\r\n        <a href='https://www.w3.org/Consortium/Legal/ipr-notice#Copyright'>Copyright</a> &copy;\r\n        "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"copyrightStart") : depth0),{"name":"if","hash":{},"fn":container.program(87, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":140,"column":8},"end":{"line":140,"column":56}}})) != null ? stack1 : "")
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"publishYear") || (depth0 != null ? lookupProperty(depth0,"publishYear") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"publishYear","hash":{},"data":data,"loc":{"start":{"line":140,"column":56},"end":{"line":140,"column":71}}}) : helper)))
      + "\r\n        "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"additionalCopyrightHolders") : depth0),{"name":"if","hash":{},"fn":container.program(89, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":141,"column":8},"end":{"line":141,"column":88}}})) != null ? stack1 : "")
      + "\r\n        <a href='https://www.w3.org/'><abbr title='World Wide Web Consortium'>W3C</abbr></a><sup>&reg;</sup>\r\n        (<a href='https://www.csail.mit.edu/'><abbr title='Massachusetts Institute of Technology'>MIT</abbr></a>,\r\n        <a href='https://www.ercim.eu/'><abbr title='European Research Consortium for Informatics and Mathematics'>ERCIM</abbr></a>,\r\n        <a href='https://www.keio.ac.jp/'>Keio</a>, <a href=\"http://ev.buaa.edu.cn/\">Beihang</a>).\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isCCBY") : depth0),{"name":"if","hash":{},"fn":container.program(91, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":146,"column":8},"end":{"line":150,"column":15}}})) != null ? stack1 : "")
      + "        W3C <a href='https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer'>liability</a>,\r\n        <a href='https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks'>trademark</a> and\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isCCBY") : depth0),{"name":"if","hash":{},"fn":container.program(93, data, 0),"inverse":container.program(95, data, 0),"data":data,"loc":{"start":{"line":153,"column":8},"end":{"line":161,"column":15}}})) != null ? stack1 : "")
      + "        rules apply.\r\n      </p>\r\n";
  },"87":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return container.escapeExpression(((helper = (helper = lookupProperty(helpers,"copyrightStart") || (depth0 != null ? lookupProperty(depth0,"copyrightStart") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"copyrightStart","hash":{},"data":data,"loc":{"start":{"line":140,"column":30},"end":{"line":140,"column":48}}}) : helper)))
      + "-";
  },"89":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return " "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalCopyrightHolders") || (depth0 != null ? lookupProperty(depth0,"additionalCopyrightHolders") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"additionalCopyrightHolders","hash":{},"data":data,"loc":{"start":{"line":141,"column":43},"end":{"line":141,"column":75}}}) : helper))) != null ? stack1 : "")
      + " &amp;";
  },"91":function(container,depth0,helpers,partials,data) {
      return "          Some Rights Reserved: this document is dual-licensed,\r\n          <a rel=\"license\" href=\"https://creativecommons.org/licenses/by/3.0/\">CC-BY</a> and\r\n          <a rel=\"license\" href=\"https://www.w3.org/Consortium/Legal/copyright-documents\">W3C Document License</a>.\r\n";
  },"93":function(container,depth0,helpers,partials,data) {
      return "          <a rel=\"license\" href='https://www.w3.org/Consortium/Legal/2013/copyright-documents-dual.html'>document use</a>\r\n";
  },"95":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"isW3CSoftAndDocLicense") : depth0),{"name":"if","hash":{},"fn":container.program(96, data, 0),"inverse":container.program(98, data, 0),"data":data,"loc":{"start":{"line":156,"column":10},"end":{"line":160,"column":17}}})) != null ? stack1 : "");
  },"96":function(container,depth0,helpers,partials,data) {
      return "            <a rel=\"license\" href='https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document'>permissive document license</a>\r\n";
  },"98":function(container,depth0,helpers,partials,data) {
      return "            <a rel=\"license\" href='https://www.w3.org/Consortium/Legal/copyright-documents'>document use</a>\r\n";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<div class='head'>\r\n"
      + ((stack1 = lookupProperty(helpers,"unless").call(alias1,(depth0 != null ? lookupProperty(depth0,"isUnofficial") : depth0),{"name":"unless","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":2},"end":{"line":6,"column":13}}})) != null ? stack1 : "")
      + "  "
      + ((stack1 = (lookupProperty(helpers,"showLogos")||(depth0 && lookupProperty(depth0,"showLogos"))||alias2).call(alias1,(depth0 != null ? lookupProperty(depth0,"logos") : depth0),{"name":"showLogos","hash":{},"data":data,"loc":{"start":{"line":7,"column":2},"end":{"line":7,"column":23}}})) != null ? stack1 : "")
      + "\r\n  <h1 class='title p-name' id='title'"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":8,"column":37},"end":{"line":8,"column":83}}})) != null ? stack1 : "")
      + ">"
      + alias4(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data,"loc":{"start":{"line":8,"column":84},"end":{"line":8,"column":93}}}) : helper)))
      + "</h1>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"subtitle") : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":9,"column":2},"end":{"line":11,"column":9}}})) != null ? stack1 : "")
      + "  <h2>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"prependW3C") : depth0),{"name":"if","hash":{},"fn":container.program(8, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":12,"column":6},"end":{"line":12,"column":35}}})) != null ? stack1 : "")
      + alias4(((helper = (helper = lookupProperty(helpers,"textStatus") || (depth0 != null ? lookupProperty(depth0,"textStatus") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"textStatus","hash":{},"data":data,"loc":{"start":{"line":12,"column":35},"end":{"line":12,"column":49}}}) : helper)))
      + " <time "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(10, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":12,"column":56},"end":{"line":12,"column":102}}})) != null ? stack1 : "")
      + "class='dt-published' datetime='"
      + alias4(((helper = (helper = lookupProperty(helpers,"dashDate") || (depth0 != null ? lookupProperty(depth0,"dashDate") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"dashDate","hash":{},"data":data,"loc":{"start":{"line":12,"column":133},"end":{"line":12,"column":145}}}) : helper)))
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"publishHumanDate") || (depth0 != null ? lookupProperty(depth0,"publishHumanDate") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"publishHumanDate","hash":{},"data":data,"loc":{"start":{"line":12,"column":147},"end":{"line":12,"column":167}}}) : helper)))
      + "</time></h2>\r\n  <dl>\r\n"
      + ((stack1 = lookupProperty(helpers,"unless").call(alias1,(depth0 != null ? lookupProperty(depth0,"isNoTrack") : depth0),{"name":"unless","hash":{},"fn":container.program(12, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":14,"column":4},"end":{"line":19,"column":15}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"edDraftURI") : depth0),{"name":"if","hash":{},"fn":container.program(17, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":20,"column":4},"end":{"line":23,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"testSuiteURI") : depth0),{"name":"if","hash":{},"fn":container.program(19, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":24,"column":4},"end":{"line":27,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"implementationReportURI") : depth0),{"name":"if","hash":{},"fn":container.program(21, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":28,"column":4},"end":{"line":31,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"bugTrackerHTML") : depth0),{"name":"if","hash":{},"fn":container.program(23, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":32,"column":4},"end":{"line":35,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isED") : depth0),{"name":"if","hash":{},"fn":container.program(25, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":36,"column":4},"end":{"line":41,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"showPreviousVersion") : depth0),{"name":"if","hash":{},"fn":container.program(28, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":42,"column":4},"end":{"line":45,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"prevRecURI") : depth0),{"name":"if","hash":{},"fn":container.program(31, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":46,"column":4},"end":{"line":54,"column":11}}})) != null ? stack1 : "")
      + "    <dt>"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"multipleEditors") : depth0),{"name":"if","hash":{},"fn":container.program(36, data, 0),"inverse":container.program(38, data, 0),"data":data,"loc":{"start":{"line":55,"column":8},"end":{"line":55,"column":77}}})) != null ? stack1 : "")
      + "</dt>\r\n    "
      + alias4((lookupProperty(helpers,"showPeople")||(depth0 && lookupProperty(depth0,"showPeople"))||alias2).call(alias1,"Editor",(depth0 != null ? lookupProperty(depth0,"editors") : depth0),{"name":"showPeople","hash":{},"data":data,"loc":{"start":{"line":56,"column":4},"end":{"line":56,"column":35}}}))
      + "\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"authors") : depth0),{"name":"if","hash":{},"fn":container.program(40, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":57,"column":4},"end":{"line":60,"column":11}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"otherLinks") : depth0),{"name":"if","hash":{},"fn":container.program(45, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":61,"column":4},"end":{"line":96,"column":11}}})) != null ? stack1 : "")
      + "  </dl>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"errata") : depth0),{"name":"if","hash":{},"fn":container.program(66, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":98,"column":2},"end":{"line":103,"column":9}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isRec") : depth0),{"name":"if","hash":{},"fn":container.program(68, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":104,"column":2},"end":{"line":109,"column":9}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"alternateFormats") : depth0),{"name":"if","hash":{},"fn":container.program(70, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":110,"column":2},"end":{"line":119,"column":9}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isUnofficial") : depth0),{"name":"if","hash":{},"fn":container.program(75, data, 0),"inverse":container.program(83, data, 0),"data":data,"loc":{"start":{"line":120,"column":2},"end":{"line":165,"column":9}}})) != null ? stack1 : "")
      + "  <hr title=\"Separator for header\">\r\n</div>\r\n";
  },"useData":true});
  templates['permalinks.css'] = template({"1":function(container,depth0,helpers,partials,data) {
      return "  section > *:hover > span.permalink { visibility: visible; }\r\n";
  },"3":function(container,depth0,helpers,partials,data) {
      return "  float: right;\r\n";
  },"5":function(container,depth0,helpers,partials,data) {
      return "  visibility: hidden;\r\n";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "/* --- PERMALINKS --- */\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"permalinkHide") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":0},"end":{"line":4,"column":7}}})) != null ? stack1 : "")
      + "\r\n.permalink {\r\n  width: 1px;\r\n  height: 1px;\r\n  overflow: visible;\r\n  font-size: 10pt;\r\n  font-style: normal;\r\n  vertical-align: middle;\r\n  margin-left: 4px;\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"permalinkEdge") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":14,"column":2},"end":{"line":16,"column":9}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"permalinkHide") : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":17,"column":2},"end":{"line":19,"column":9}}})) != null ? stack1 : "")
      + "}\r\n\r\n.permalink a, .permalink a:link, .permalink a:visited, .permalink a:hover, .permalink a:focus, .permalink a:active {\r\n  background:transparent !important;\r\n  text-decoration:none;\r\n  font-weight: bold;\r\n  color:#666 !important;\r\n}\r\n\r\n.permalink abbr {\r\n  border:0;\r\n}\r\n";
  },"useData":true});
  templates['sotd.html'] = template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "  <details class=\"annoying-warning\" open=\"\">\r\n    <summary>This is a preview</summary>\r\n    <p>\r\n      Do not attempt to implement this version of the specification. Do not reference this\r\n      version as authoritative in any way.\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"edDraftURI") : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":8,"column":6},"end":{"line":10,"column":13}}})) != null ? stack1 : "")
      + "    </p>\r\n  </details>\r\n";
  },"2":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "        Instead, see <a href=\""
      + alias4(((helper = (helper = lookupProperty(helpers,"edDraftURI") || (depth0 != null ? lookupProperty(depth0,"edDraftURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"edDraftURI","hash":{},"data":data,"loc":{"start":{"line":9,"column":30},"end":{"line":9,"column":44}}}) : helper)))
      + "\">"
      + alias4(((helper = (helper = lookupProperty(helpers,"edDraftURI") || (depth0 != null ? lookupProperty(depth0,"edDraftURI") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"edDraftURI","hash":{},"data":data,"loc":{"start":{"line":9,"column":46},"end":{"line":9,"column":60}}}) : helper)))
      + "</a> for the Editor's draft.\r\n";
  },"4":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "  <p>\r\n    This document is draft of a potential specification. It has no official standing of\r\n    any kind and does not represent the support or consensus of any standards organisation.\r\n  </p>\r\n  "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalContent") || (depth0 != null ? lookupProperty(depth0,"additionalContent") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"additionalContent","hash":{},"data":data,"loc":{"start":{"line":19,"column":2},"end":{"line":19,"column":25}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"6":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"isTagFinding") : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.program(9, data, 0),"data":data,"loc":{"start":{"line":21,"column":2},"end":{"line":192,"column":9}}})) != null ? stack1 : "");
  },"7":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "    "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalContent") || (depth0 != null ? lookupProperty(depth0,"additionalContent") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"additionalContent","hash":{},"data":data,"loc":{"start":{"line":22,"column":4},"end":{"line":22,"column":27}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"9":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"isNoTrack") : depth0),{"name":"if","hash":{},"fn":container.program(10, data, 0),"inverse":container.program(13, data, 0),"data":data,"loc":{"start":{"line":24,"column":4},"end":{"line":191,"column":11}}})) != null ? stack1 : "");
  },"10":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <p>\r\n        This document is merely a W3C-internal "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isMO") : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":26,"column":47},"end":{"line":26,"column":85}}})) != null ? stack1 : "")
      + " document. It\r\n        has no official standing of any kind and does not represent consensus of the W3C\r\n        Membership.\r\n      </p>\r\n      "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalContent") || (depth0 != null ? lookupProperty(depth0,"additionalContent") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"additionalContent","hash":{},"data":data,"loc":{"start":{"line":30,"column":6},"end":{"line":30,"column":29}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"11":function(container,depth0,helpers,partials,data) {
      return "member-confidential";
  },"13":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "      <p>\r\n        <em>"
      + ((stack1 = container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"status_at_publication") : stack1), depth0)) != null ? stack1 : "")
      + "</em>\r\n      </p>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"isSubmission") : depth0),{"name":"if","hash":{},"fn":container.program(14, data, 0),"inverse":container.program(23, data, 0),"data":data,"loc":{"start":{"line":35,"column":6},"end":{"line":190,"column":13}}})) != null ? stack1 : "");
  },"14":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "        "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalContent") || (depth0 != null ? lookupProperty(depth0,"additionalContent") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"additionalContent","hash":{},"data":data,"loc":{"start":{"line":36,"column":8},"end":{"line":36,"column":31}}}) : helper))) != null ? stack1 : "")
      + "\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isMemberSubmission") : depth0),{"name":"if","hash":{},"fn":container.program(15, data, 0),"inverse":container.program(17, data, 0),"data":data,"loc":{"start":{"line":37,"column":8},"end":{"line":64,"column":15}}})) != null ? stack1 : "");
  },"15":function(container,depth0,helpers,partials,data) {
      return "          <p>\r\n            By publishing this document, W3C acknowledges that\r\n            the <a href=\"https://www.w3.org/Submission/@@@submissiondoc@@@\">Submitting Members</a>\r\n            have made a formal Submission request to W3C for discussion. Publication of this document\r\n            by W3C indicates no endorsement of its content by W3C, nor that W3C has, is, or will be\r\n            allocating any resources to the issues addressed by it. This document is not the product\r\n            of a chartered W3C group, but is published as potential input to\r\n            the <a href=\"https://www.w3.org/Consortium/Process\">W3C Process</a>.\r\n            A <a href=\"https://www.w3.org/Submission/@@@teamcomment@@@\">W3C Team Comment</a> has been\r\n            published in conjunction with this Member Submission. Publication of acknowledged Member Submissions\r\n            at the W3C site is one of the benefits of <a href=\"https://www.w3.org/Consortium/Prospectus/Joining\">\r\n            W3C Membership</a>. Please consult the requirements associated with Member Submissions of\r\n            <a href=\"https://www.w3.org/Consortium/Patent-Policy/#sec-submissions\">section 3.3 of the\r\n            W3C Patent Policy</a>. Please consult the complete <a href=\"https://www.w3.org/Submission\">list\r\n            of acknowledged W3C Member Submissions</a>.\r\n          </p>\r\n";
  },"17":function(container,depth0,helpers,partials,data) {
      var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"isTeamSubmission") : depth0),{"name":"if","hash":{},"fn":container.program(18, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":55,"column":10},"end":{"line":63,"column":17}}})) != null ? stack1 : "");
  },"18":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "            <p>If you wish to make comments regarding this document, please send them to\r\n            <a href='mailto:"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":57,"column":28},"end":{"line":57,"column":44}}}) : helper)))
      + "@w3.org"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"subjectPrefix") : depth0),{"name":"if","hash":{},"fn":container.program(19, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":57,"column":51},"end":{"line":57,"column":108}}})) != null ? stack1 : "")
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":57,"column":110},"end":{"line":57,"column":126}}}) : helper)))
      + "@w3.org</a>\r\n            (<a href='mailto:"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":58,"column":29},"end":{"line":58,"column":45}}}) : helper)))
      + "-request@w3.org?subject=subscribe'>subscribe</a>,\r\n            <a\r\n              href='https://lists.w3.org/Archives/Public/"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":60,"column":57},"end":{"line":60,"column":73}}}) : helper)))
      + "/'>archives</a>)"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"subjectPrefix") : depth0),{"name":"if","hash":{},"fn":container.program(21, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":60,"column":89},"end":{"line":61,"column":93}}})) != null ? stack1 : "")
      + ".</p>\r\n            <p>Please consult the complete <a href=\"https://www.w3.org/TeamSubmission/\">list of Team Submissions</a>.</p>\r\n";
  },"19":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "?subject="
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"subjectPrefixEnc") || (depth0 != null ? lookupProperty(depth0,"subjectPrefixEnc") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"subjectPrefixEnc","hash":{},"data":data,"loc":{"start":{"line":57,"column":81},"end":{"line":57,"column":101}}}) : helper)));
  },"21":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "\r\n              with <code>"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"subjectPrefix") || (depth0 != null ? lookupProperty(depth0,"subjectPrefix") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"subjectPrefix","hash":{},"data":data,"loc":{"start":{"line":61,"column":25},"end":{"line":61,"column":42}}}) : helper)))
      + "</code> at the start of your email's subject";
  },"23":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"unless").call(alias1,(depth0 != null ? lookupProperty(depth0,"sotdAfterWGinfo") : depth0),{"name":"unless","hash":{},"fn":container.program(24, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":66,"column":8},"end":{"line":68,"column":19}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"unless").call(alias1,(depth0 != null ? lookupProperty(depth0,"overrideStatus") : depth0),{"name":"unless","hash":{},"fn":container.program(26, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":69,"column":8},"end":{"line":112,"column":19}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"implementationReportURI") : depth0),{"name":"if","hash":{},"fn":container.program(39, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":113,"column":8},"end":{"line":118,"column":15}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"sotdAfterWGinfo") : depth0),{"name":"if","hash":{},"fn":container.program(41, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":119,"column":8},"end":{"line":121,"column":15}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"notRec") : depth0),{"name":"if","hash":{},"fn":container.program(43, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":122,"column":8},"end":{"line":129,"column":15}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isRec") : depth0),{"name":"if","hash":{},"fn":container.program(45, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":130,"column":8},"end":{"line":139,"column":15}}})) != null ? stack1 : "")
      + "        <p"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isNote") : depth0),{"name":"if","hash":{},"fn":container.program(47, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":140,"column":10},"end":{"line":140,"column":57}}})) != null ? stack1 : "")
      + ">\r\n"
      + ((stack1 = lookupProperty(helpers,"unless").call(alias1,(depth0 != null ? lookupProperty(depth0,"isIGNote") : depth0),{"name":"unless","hash":{},"fn":container.program(49, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":141,"column":10},"end":{"line":150,"column":21}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"recNotExpected") : depth0),{"name":"if","hash":{},"fn":container.program(56, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":151,"column":10},"end":{"line":153,"column":17}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"unless").call(alias1,(depth0 != null ? lookupProperty(depth0,"isIGNote") : depth0),{"name":"unless","hash":{},"fn":container.program(58, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":154,"column":10},"end":{"line":173,"column":21}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isIGNote") : depth0),{"name":"if","hash":{},"fn":container.program(67, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":174,"column":10},"end":{"line":177,"column":17}}})) != null ? stack1 : "")
      + "        </p>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isNewProcess") : depth0),{"name":"if","hash":{},"fn":container.program(69, data, 0),"inverse":container.program(71, data, 0),"data":data,"loc":{"start":{"line":179,"column":8},"end":{"line":188,"column":15}}})) != null ? stack1 : "")
      + "        "
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"addPatentNote") : depth0),{"name":"if","hash":{},"fn":container.program(73, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":189,"column":8},"end":{"line":189,"column":62}}})) != null ? stack1 : "")
      + "\r\n";
  },"24":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "        "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalContent") || (depth0 != null ? lookupProperty(depth0,"additionalContent") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"additionalContent","hash":{},"data":data,"loc":{"start":{"line":67,"column":8},"end":{"line":67,"column":31}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"26":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "        <p>\r\n          This document was published by "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"wgHTML") || (depth0 != null ? lookupProperty(depth0,"wgHTML") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgHTML","hash":{},"data":data,"loc":{"start":{"line":71,"column":41},"end":{"line":71,"column":53}}}) : helper))) != null ? stack1 : "")
      + " as "
      + alias4(((helper = (helper = lookupProperty(helpers,"anOrA") || (depth0 != null ? lookupProperty(depth0,"anOrA") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"anOrA","hash":{},"data":data,"loc":{"start":{"line":71,"column":57},"end":{"line":71,"column":66}}}) : helper)))
      + " "
      + alias4(((helper = (helper = lookupProperty(helpers,"longStatus") || (depth0 != null ? lookupProperty(depth0,"longStatus") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"longStatus","hash":{},"data":data,"loc":{"start":{"line":71,"column":67},"end":{"line":71,"column":81}}}) : helper)))
      + ".\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"notYetRec") : depth0),{"name":"if","hash":{},"fn":container.program(27, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":72,"column":10},"end":{"line":74,"column":17}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0),{"name":"if","hash":{},"fn":container.program(29, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":75,"column":10},"end":{"line":82,"column":17}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isCR") : depth0),{"name":"if","hash":{},"fn":container.program(31, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":83,"column":10},"end":{"line":88,"column":17}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isPER") : depth0),{"name":"if","hash":{},"fn":container.program(33, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":89,"column":10},"end":{"line":98,"column":17}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isPR") : depth0),{"name":"if","hash":{},"fn":container.program(35, data, 0),"inverse":container.program(37, data, 0),"data":data,"loc":{"start":{"line":99,"column":10},"end":{"line":110,"column":17}}})) != null ? stack1 : "")
      + "        </p>\r\n";
  },"27":function(container,depth0,helpers,partials,data) {
      return "            This document is intended to become a W3C Recommendation.\r\n";
  },"29":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "            Comments regarding this document are welcome. Please send them to\r\n            <a href='mailto:"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":77,"column":28},"end":{"line":77,"column":44}}}) : helper)))
      + "@w3.org"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"subjectPrefix") : depth0),{"name":"if","hash":{},"fn":container.program(19, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":77,"column":51},"end":{"line":77,"column":108}}})) != null ? stack1 : "")
      + "'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":77,"column":110},"end":{"line":77,"column":126}}}) : helper)))
      + "@w3.org</a>\r\n            (<a href='mailto:"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":78,"column":29},"end":{"line":78,"column":45}}}) : helper)))
      + "-request@w3.org?subject=subscribe'>subscribe</a>,\r\n            <a\r\n              href='https://lists.w3.org/Archives/Public/"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":80,"column":57},"end":{"line":80,"column":73}}}) : helper)))
      + "/'>archives</a>)"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"subjectPrefix") : depth0),{"name":"if","hash":{},"fn":container.program(21, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":80,"column":89},"end":{"line":81,"column":93}}})) != null ? stack1 : "")
      + ".\r\n";
  },"31":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "            W3C publishes a Candidate Recommendation to indicate that the document is believed to be\r\n            stable and to encourage implementation by the developer community. This Candidate\r\n            Recommendation is expected to advance to Proposed Recommendation no earlier than\r\n            "
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"humanCREnd") || (depth0 != null ? lookupProperty(depth0,"humanCREnd") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"humanCREnd","hash":{},"data":data,"loc":{"start":{"line":87,"column":12},"end":{"line":87,"column":26}}}) : helper)))
      + ".\r\n";
  },"33":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "              W3C Advisory Committee Members are invited to\r\n              send formal review comments on this Proposed\r\n              Edited Recommendation to the W3C Team until\r\n              "
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"humanPEREnd") || (depth0 != null ? lookupProperty(depth0,"humanPEREnd") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"humanPEREnd","hash":{},"data":data,"loc":{"start":{"line":93,"column":14},"end":{"line":93,"column":29}}}) : helper)))
      + ".\r\n              Members of the Advisory Committee will find the\r\n              appropriate review form for this document by\r\n              consulting their list of current\r\n              <a href='https://www.w3.org/2002/09/wbs/myQuestionnaires'>WBS questionnaires</a>.\r\n";
  },"35":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "              The W3C Membership and other interested parties are invited to review the document and\r\n              send comments to\r\n              <a rel='discussion' href='mailto:"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":102,"column":47},"end":{"line":102,"column":63}}}) : helper)))
      + "@w3.org'>"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":102,"column":72},"end":{"line":102,"column":88}}}) : helper)))
      + "@w3.org</a>\r\n              (<a href='mailto:"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":103,"column":31},"end":{"line":103,"column":47}}}) : helper)))
      + "-request@w3.org?subject=subscribe'>subscribe</a>,\r\n              <a href='https://lists.w3.org/Archives/Public/"
      + alias4(((helper = (helper = lookupProperty(helpers,"wgPublicList") || (depth0 != null ? lookupProperty(depth0,"wgPublicList") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"wgPublicList","hash":{},"data":data,"loc":{"start":{"line":104,"column":60},"end":{"line":104,"column":76}}}) : helper)))
      + "/'>archives</a>)\r\n              through "
      + alias4(((helper = (helper = lookupProperty(helpers,"humanPREnd") || (depth0 != null ? lookupProperty(depth0,"humanPREnd") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"humanPREnd","hash":{},"data":data,"loc":{"start":{"line":105,"column":22},"end":{"line":105,"column":36}}}) : helper)))
      + ". Advisory Committee Representatives should consult their\r\n              <a href='https://www.w3.org/2002/09/wbs/myQuestionnaires'>WBS questionnaires</a>.\r\n              Note that substantive technical comments were expected during the Candidate Recommendation\r\n              review period that ended "
      + alias4(((helper = (helper = lookupProperty(helpers,"humanCREnd") || (depth0 != null ? lookupProperty(depth0,"humanCREnd") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"humanCREnd","hash":{},"data":data,"loc":{"start":{"line":108,"column":39},"end":{"line":108,"column":53}}}) : helper)))
      + ".\r\n";
  },"37":function(container,depth0,helpers,partials,data) {
      return "";
  },"39":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "          <p>\r\n            Please see the Working Group's  <a href='"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"implementationReportURI") || (depth0 != null ? lookupProperty(depth0,"implementationReportURI") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"implementationReportURI","hash":{},"data":data,"loc":{"start":{"line":115,"column":53},"end":{"line":115,"column":80}}}) : helper)))
      + "'>implementation\r\n            report</a>.\r\n          </p>\r\n";
  },"41":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "          "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalContent") || (depth0 != null ? lookupProperty(depth0,"additionalContent") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"additionalContent","hash":{},"data":data,"loc":{"start":{"line":120,"column":10},"end":{"line":120,"column":33}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"43":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "          <p>\r\n            Publication as "
      + alias4(((helper = (helper = lookupProperty(helpers,"anOrA") || (depth0 != null ? lookupProperty(depth0,"anOrA") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"anOrA","hash":{},"data":data,"loc":{"start":{"line":124,"column":27},"end":{"line":124,"column":36}}}) : helper)))
      + " "
      + alias4(((helper = (helper = lookupProperty(helpers,"textStatus") || (depth0 != null ? lookupProperty(depth0,"textStatus") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"textStatus","hash":{},"data":data,"loc":{"start":{"line":124,"column":37},"end":{"line":124,"column":51}}}) : helper)))
      + " does not imply endorsement by the W3C\r\n            Membership. This is a draft document and may be updated, replaced or obsoleted by other\r\n            documents at any time. It is inappropriate to cite this document as other than work in\r\n            progress.\r\n          </p>\r\n";
  },"45":function(container,depth0,helpers,partials,data) {
      return "          <p>\r\n            This document has been reviewed by W3C Members, by software developers, and by other W3C\r\n            groups and interested parties, and is endorsed by the Director as a W3C Recommendation.\r\n            It is a stable document and may be used as reference material or cited from another\r\n            document. W3C's role in making the Recommendation is to draw attention to the\r\n            specification and to promote its widespread deployment. This enhances the functionality\r\n            and interoperability of the Web.\r\n          </p>\r\n";
  },"47":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return " data-deliverer=\""
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"wgId") || (depth0 != null ? lookupProperty(depth0,"wgId") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"wgId","hash":{},"data":data,"loc":{"start":{"line":140,"column":41},"end":{"line":140,"column":49}}}) : helper)))
      + "\"";
  },"49":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "            This document was produced by\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"multipleWGs") : depth0),{"name":"if","hash":{},"fn":container.program(50, data, 0),"inverse":container.program(52, data, 0),"data":data,"loc":{"start":{"line":143,"column":12},"end":{"line":147,"column":19}}})) != null ? stack1 : "")
      + " operating under the\r\n            <a"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"doRDFa") : depth0),{"name":"if","hash":{},"fn":container.program(54, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":148,"column":14},"end":{"line":148,"column":79}}})) != null ? stack1 : "")
      + "\r\n            href='https://www.w3.org/Consortium/Patent-Policy/'>W3C Patent Policy</a>.\r\n";
  },"50":function(container,depth0,helpers,partials,data) {
      return "            groups\r\n";
  },"52":function(container,depth0,helpers,partials,data) {
      return "            a group\r\n            ";
  },"54":function(container,depth0,helpers,partials,data) {
      return " id=\"sotd_patent\" property='w3p:patentRules'";
  },"56":function(container,depth0,helpers,partials,data) {
      return "            The group does not expect this document to become a W3C Recommendation.\r\n";
  },"58":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"multipleWGs") : depth0),{"name":"if","hash":{},"fn":container.program(59, data, 0),"inverse":container.program(61, data, 0),"data":data,"loc":{"start":{"line":155,"column":12},"end":{"line":160,"column":19}}})) != null ? stack1 : "")
      + "            made in connection with the deliverables of\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"multipleWGs") : depth0),{"name":"if","hash":{},"fn":container.program(63, data, 0),"inverse":container.program(65, data, 0),"data":data,"loc":{"start":{"line":162,"column":12},"end":{"line":166,"column":19}}})) != null ? stack1 : "")
      + "            instructions for disclosing a patent. An individual who has actual knowledge of a patent\r\n            which the individual believes contains\r\n            <a href='https://www.w3.org/Consortium/Patent-Policy/#def-essential'>Essential\r\n            Claim(s)</a> must disclose the information in accordance with\r\n            <a href='https://www.w3.org/Consortium/Patent-Policy/#sec-Disclosure'>section\r\n            6 of the W3C Patent Policy</a>.\r\n";
  },"59":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "              W3C maintains "
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"wgPatentHTML") || (depth0 != null ? lookupProperty(depth0,"wgPatentHTML") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"wgPatentHTML","hash":{},"data":data,"loc":{"start":{"line":156,"column":28},"end":{"line":156,"column":46}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"61":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "              W3C maintains a <a href='"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"wgPatentURI") || (depth0 != null ? lookupProperty(depth0,"wgPatentURI") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"wgPatentURI","hash":{},"data":data,"loc":{"start":{"line":158,"column":39},"end":{"line":158,"column":54}}}) : helper)))
      + "' rel='disclosure'>public list of any patent\r\n              disclosures</a>\r\n";
  },"63":function(container,depth0,helpers,partials,data) {
      return "            each group; these pages also include\r\n";
  },"65":function(container,depth0,helpers,partials,data) {
      return "            the group; that page also includes\r\n";
  },"67":function(container,depth0,helpers,partials,data) {
      var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "            The disclosure obligations of the Participants of this group are described in the\r\n            <a href='"
      + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"charterDisclosureURI") || (depth0 != null ? lookupProperty(depth0,"charterDisclosureURI") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"charterDisclosureURI","hash":{},"data":data,"loc":{"start":{"line":176,"column":21},"end":{"line":176,"column":45}}}) : helper)))
      + "'>charter</a>.\r\n";
  },"69":function(container,depth0,helpers,partials,data) {
      return "          <p>This document is governed by the <a id=\"w3c_process_revision\"\r\n            href=\"https://www.w3.org/2017/Process-20170301/\">1 March 2017 W3C Process Document</a>.\r\n          </p>\r\n";
  },"71":function(container,depth0,helpers,partials,data) {
      return "          <p>\r\n            This document is governed by the  <a id=\"w3c_process_revision\"\r\n            href=\"https://www.w3.org/2005/10/Process-20051014/\">14 October 2005 W3C Process Document</a>.\r\n          </p>\r\n";
  },"73":function(container,depth0,helpers,partials,data) {
      var stack1, helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<p>"
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"addPatentNote") || (depth0 != null ? lookupProperty(depth0,"addPatentNote") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"addPatentNote","hash":{},"data":data,"loc":{"start":{"line":189,"column":32},"end":{"line":189,"column":51}}}) : helper))) != null ? stack1 : "")
      + "</p>";
  },"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
          }
          return undefined
      };

    return "<h2>"
      + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"l10n") : depth0)) != null ? lookupProperty(stack1,"sotd") : stack1), depth0))
      + "</h2>\r\n"
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isPreview") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":0},"end":{"line":13,"column":7}}})) != null ? stack1 : "")
      + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"isUnofficial") : depth0),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.program(6, data, 0),"data":data,"loc":{"start":{"line":14,"column":0},"end":{"line":193,"column":7}}})) != null ? stack1 : "")
      + ((stack1 = ((helper = (helper = lookupProperty(helpers,"additionalSections") || (depth0 != null ? lookupProperty(depth0,"additionalSections") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"additionalSections","hash":{},"data":data,"loc":{"start":{"line":194,"column":0},"end":{"line":194,"column":24}}}) : helper))) != null ? stack1 : "")
      + "\r\n";
  },"useData":true});
  })();

  var tmpls = hb.templates;

  /*jshint
      forin: false
  */
  /*global hb*/


  const name$t = "pcisig/headers";

  const headersTmpl = tmpls["pcisig-headers"];

  const PCISIGDate = new Intl.DateTimeFormat(["en-AU"], {
    timeZone: "UTC",
    year: "numeric",
    month: "long",
    day: "2-digit",
  });

  hb.registerHelper("showPeople", function (name, items = []) {
    // stuff to handle RDFa
    let re = "",
      rp = "",
      rm = "",
      rn = "",
      rwu = "",
      rpu = "",
      bn = "",
      editorid = "";
    if (this.doRDFa) {
      if (name === "Editor") {
        bn = "_:editor0";
        re = " property='bibo:editor' resource='" + bn + "'";
        rp = " property='rdf:first' typeof='foaf:Person'";
      } else if (name === "Author") {
        rp = " property='dc:contributor' typeof='foaf:Person'";
      }
      rn = " property='foaf:name'";
      rm = " property='foaf:mbox'";
      rwu = " property='foaf:workplaceHomepage'";
      rpu = " property='foaf:homepage'";
    }
    let ret = "";
    for (let i = 0, n = items.length; i < n; i++) {
      let p = items[i];
      if (p.pcisigid) {
        editorid = " data-editor-id='" + parseInt(p.pcisigid, 10) + "'";
      }
      if (this.doRDFa) {
        ret +=
          "<dd class='p-author h-card vcard' " +
          re +
          editorid +
          "><span" +
          rp +
          ">";
        if (name === "Editor") {
          // Update to next sequence in rdf:List
          bn = i < n - 1 ? "_:editor" + (i + 1) : "rdf:nil";
          re = " resource='" + bn + "'";
        }
      } else {
        ret += "<dd class='p-author h-card vcard'" + editorid + ">";
      }
      if (p.url) {
        if (this.doRDFa) {
          ret +=
            "<meta" +
            rn +
            " content='" +
            p.name +
            "'><a class='u-url url p-name fn' " +
            rpu +
            " href='" +
            p.url +
            "'>" +
            p.name +
            "</a>";
        } else
          ret +=
            "<a class='u-url url p-name fn' href='" +
            p.url +
            "'>" +
            p.name +
            "</a>";
      } else {
        ret += "<span" + rn + " class='p-name fn'>" + p.name + "</span>";
      }
      if (p.company) {
        ret += ", ";
        if (p.companyURL)
          ret +=
            "<a" +
            rwu +
            " class='p-org org h-org h-card' href='" +
            p.companyURL +
            "'>" +
            p.company +
            "</a>";
        else ret += p.company;
      }
      if (p.mailto) {
        ret +=
          ", <span class='ed_mailto'><a class='u-email email' " +
          rm +
          " href='mailto:" +
          p.mailto +
          "'>" +
          p.mailto +
          "</a></span>";
      }
      if (p.note) ret += " (" + p.note + ")";
      if (p.extras) {
        let self = this;
        let resultHTML = p.extras
        // Remove empty names
          .filter(function (extra) {
            return extra.name && extra.name.trim();
          })
          // Convert to HTML
          .map(function (extra) {
            let span = document.createElement("span");
            let textContainer = span;
            if (extra.class) {
              span.className = extra.class;
            }
            if (extra.href) {
              let a = document.createElement("a");
              span.appendChild(a);
              a.href = extra.href;
              textContainer = a;
              if (self.doRDFa) {
                a.setAttribute("property", "rdfs:seeAlso");
              }
            }
            textContainer.innerHTML = extra.name;
            return span.outerHTML;
          })
          .join(", ");
        ret += ", " + resultHTML;
      }
      if (this.doRDFa) {
        ret += "</span>\n";
        if (name === "Editor")
          ret += "<span property='rdf:rest' resource='" + bn + "'></span>\n";
      }
      ret += "</dd>\n";
    }
    return new hb.SafeString(ret);
  });

  function toLogo(obj) {
    const a = document.createElement("a");
    if (!obj.alt) {
      const msg = "Found spec logo without an `alt` attribute. See dev console.";
      a.classList.add("respec-offending-element");
      pub("warn", msg);
      console.warn("warn", msg, a);
    }
    a.href = obj.href ? obj.href : "";
    a.classList.add("logo");
    hyperHTML.bind(a)`
      <img
        id="${obj.id}"
        alt="${obj.alt}"
        width="${obj.width}"
        height="${obj.height}">
  `;
    // avoid triggering 404 requests from dynamically generated
    // hyperHTML attribute values
    a.querySelector("img").src = obj.src;
    return a;
  }

  hb.registerHelper("showLogos", logos => {
    const p = document.createElement("p");
    hyperHTML.bind(p)`${logos.map(toLogo)}`;
    return p.outerHTML;
  });

  const status2rdf = {
    "WG-NOTE": "pcisigp:NOTE",
    "WG-DRAFT-NOTE": "pcisigp:NOTE",
    "PUB-NOTE": "pcisigp:NOTE",
    "PUB-DRAFT-NOTE": "pcisigp:NOTE",
    WD: "pcisigp:WD",
    "WD-CWG": "pcisigp:WD",
    "WD-MEM": "pcisigp:WD",
    "WD-FINAL": "pcisigp:WD",
    RC: "pcisigp:RC",
    "RC-CWG": "pcisigp:RC",
    "RC-MEM": "pcisigp:RC",
    "RC-FINAL": "pcisigp:RC",
    PUB: "pcisigp:CWG",
    "PUB-CWG": "pcisigp:CWG",
    "PUB-MEM": "pcisigp:MEM",
    "PUB-FINAL": "pcisigp:FINAL",
    FINAL: "pcisigp:FINAL",

    RESCINDED: "pcisigp:RESCINDED",
    REPLACED: "pcisigp:REPLACED",
    PRIVATE: "pcisigp:PRIVATE"
  };
  const status2text = {
    "WG-DRAFT-NOTE": "Draft Working Group Note",
    "WG-NOTE": "Working Group Note",
    "PUB-DRAFT-NOTE": "Published Draft Note",
    "PUB-NOTE": "Published Note",
    "member-private": "Member Private Document",
    "member-submission": "Member Submission",
    "team-private": "Team Private Document",
    "team-submission": "Team Submission",

    WD: "Working Draft",
    "WD-CWG": "Working Draft",
    "WD-MEM": "Working Draft",
    "WD-FINAL": "Working Draft",

    RC: "Release Candidate",
    "RC-CWG": "Release Candidate",
    "RC-MEM": "Release Candidate",
    "RC-FINAL": "Release Candidate",

    PUB: "Draft Spec.",
    "PUB-CWG": "Draft Spec.",
    "PUB-MEM": "Draft Spec.",
    "PUB-FINAL": "Final Spec.",
    FINAL: "Final Spec.",

    RESCINDED: "Specification Rescinded",
    REPLACED: "Specification Replaced",
    PRIVATE: "Private Document",
    unofficial: "Unofficial Document",
    base: "Document",
  };
  const status2long = {
    WD: "Unpublished Working Draft",
    RC: "Unpublished Release Candidate",
    PUB: "Published Specification",
    "WD-CWG": "Unpublished Cross Workgroup Review Working Draft",
    "RC-CWG": "Unpublished Cross Workgroup Review Release Candidate",
    "PUB-CWG": "Published Cross Workgroup Review Draft",
    "WD-MEM": "Unpublished Member Review Working Draft",
    "RC-MEM": "Unpublished Member Review Release Candidate",
    "RC-FINAL": "Unpublished Final Release Candidate",
    "WD-FINAL": "Unpublished Final Working Draft",
    "PUB-MEM": "Published Member Review Draft",
    FINAL: "Published Final Specification"
  };
  const specTrackStatus = [
    "WD", "RC", "PUB", "FINAL",
    "WD-CWG", "RC-CWG", "PUB-CWG",
    "WD-MEM", "RC-MEM", "PUB-MEM",
    "WD-FINAL", "RC-FINAL", "PUB-FINAL"
  ];

  // Chapters are never published standalone. if conf.specChapter is present,
  // this map is used to convert "final" specStatus values to equivalent "RC" values.
  const specFinal2Draft = {
    "WD": "WD",
    "RC": "RC",
    "PUB": "RC",
    "FINAL": "RC",
    "WD-CWG": "WD-CWG",
    "RC-CWG": "RC-CWG",
    "PUB-CWG": "RC-CWG",
    "WD-MEM": "WD-MEM",
    "RC-MEM": "RC-MEM",
    "PUB-MEM": "RC-MEM",
    "WD-FINAL": "WD-FINAL",
    "RC-FINAL": "RC-FINAL",
    "PUB-FINAL": "RC-FINAL"
  };

  const noTrackStatus = [
    "unofficial",
    "private",
    "base",
    "note",
    "draft-note",
    "member-private",
    "member-submission",
    "team-private",
    "team-submission"
  ];
  const precededByAn = ["unofficial"];  // specStatus values that should grammatically be preceded by an instead of a.

  const licenses = {
    "pcisig-draft": {
      name: "PCISIG Specification License",
      short: "PCISIG Spec",
      url: "https://sglaser.github.io/respec/Spec/Legal/2017/copyright-draft-specification",
      click_through: false
    },
    "pcisig-draft-click-through": {
      name: "PCISIG Specification License",
      short: "PCISIG Spec",
      url: "https://sglaser.github.io/respec/Spec/Legal/2017/copyright-draft-specification",
      click_through: false
    },
    "pcisig-final": {
      name: "PCISIG Specification License",
      short: "PCISIG Spec",
      url: "https://sglaser.github.io/respec/Spec/Legal/2017/copyright-final-specification",
      click_through: false
    },
    "pcisig-final-click-through": {
      name: "PCISIG Click-Through Specification License",
      short: "PCISIG Spec (Click Through License)",
      url: "https://sglaser.github.io/respec/Spec/Legal/2017/copyright-final-click-through-specification",
      click_through: true
    },
    "pcisig-note": {
      name: "PCISIG Note, Whitepaper, or Presentation License",
      short: "PCISIG Spec",
      url: "https://sglaser.github.io/respec/Spec/Legal/2017/copyright-note",
      click_through: false
    },
    "nda": {
      name: "PCISIG Non-Disclosure Agreement",
      short: "PCISIG NDA",
      url: "https://sglaser.github.io/respec/Spec/Legal/2017/copyright-nda",
      click_through: false
    },
    cc0: {
      name: "Creative Commons 0 Public Domain Dedication",
      short: "CC0",
      url: "https://creativecommons.org/publicdomain/zero/1.0/",
      click_through: false
    }
  };

  const baseLogo = Object.freeze({
    id: "",
    alt: "",
    href: "",
    src: "",
    height: "48",
    width: "72",
  });

  function validateDateAndRecover(conf, prop, fallbackDate = new Date()) {
    const date = conf[prop] ? new Date(conf[prop]) : new Date(fallbackDate);
    // if date is valid
    if (Number.isFinite(date.valueOf())) {
      const formattedDate = ISODate.format(date);
      return new Date(formattedDate);
    }
    const msg =
      `[${prop}](https://github.com/pcisig/respec/wiki/${prop}) ` +
      `is not a valid date: "${conf[prop]}". Expected format 'YYYY-MM-DD'.`;
    pub("error", msg);
    return new Date(ISODate.format(new Date()));
  }

  function run$t(conf, doc, cb) {
    // TODO: move to pcisig defaults
    if (!conf.logos) {
      conf.logos = [];
    }
    if (conf.specStatus && conf.specChapter && specFinal2Draft.hasOwnProperty(conf.specStatus)){
      conf.specStatus = specFinal2Draft[conf.specStatus];
    }
    // Default include RDFa document metadata
    if (conf.doRDFa === undefined) conf.doRDFa = true;
    // validate configuration and derive new configuration values
    if (!conf.license) {
      conf.license = "nda";
    }
    if (["cc0"].includes(conf.license)) {
      let msg = `You cannot use license "${conf.license}" with PCISIG Specs. `;
      let non_cc0 = licenses.keys.remove("cc0").toString();
      msg += `Please set 'respecConfig.license:' to one of ${non_cc0} instead.`;
      pub("error", msg);
    }
    conf.licenseInfo = licenses[conf.license];
    conf.isClickThrough = conf.licenseInfo.click_through;
    if (["final"].includes(conf.license)) {
      if (conf.specChapter) {
        conf.license = conf.license.sub("final", "draft");
      }
    }
    conf.isBasic = conf.specStatus === "base";
    conf.isRegular = !conf.isBasic;
    if (!conf.specStatus) {
      pub("error", "Missing required configuration: `specStatus`");
    }

    if (conf.isRegular && !conf.shortName) {
      pub("error", "Missing required configuration: `shortName`");
    }
    conf.title = doc.title || "No Title";
    if (!conf.subtitle) conf.subtitle = "";
    conf.publishDate = validateDateAndRecover(
      conf,
      "publishDate",
      doc.lastModified
    );
    conf.publishYear = conf.publishDate.getUTCFullYear().toString();
    conf.publishHumanDate = PCISIGDate.format(conf.publishDate);
    conf.isNoTrack = noTrackStatus.includes(conf.specStatus) || conf.specChapter;
    conf.isSpecTrack = conf.noSpecTrack
      ? false
      : specTrackStatus.includes(conf.specStatus);
    if (conf.isSpecTrack && !conf.specRevision) {
      pub("error", "Missing required configuration: `specRevision`");
    }
    if (conf.isSpecTrack && !conf.specDraftLevel) {
      pub("error", "Missing required configuration: `specDraftLevel`");
    }
    conf.isMemberPrivate = conf.specStatus === "member-private";
    if (conf.isMemberPrivate) {
      const memPrivateLogo = {
        alt: "PCISIG Member Private",
        href: "https://sglaser.github.io/respec/Spec/MemberSubmission/Private/",
        src: "https://sglaser.github.io/respec/Spec/Icons/member_private.svg",
        width: "211",
      };
      conf.logos.push({...baseLogo, ...memPrivateLogo});
    }
    conf.isMemberSubmission = conf.specStatus === "member-submission";
    if (conf.isMemberSubmission) {
      const memSubmissionLogo = {
        alt: "PCISIG Member Submission",
        href: "https://sglaser.github.io/respec/Spec/MemberSubmission/",
        src: "https://sglaser.github.io/respec/Spec/Icons/member_submission.svg",
        width: "211",
      };
      conf.logos.push({...baseLogo, ...memSubmissionLogo});
    }
    conf.isTeamPrivate = conf.specStatus === "team-private";
    if (conf.isTeamPrivate) {
      const teamPrivateLogo = {
        alt: "PCISIG Team Private",
        href: "https://sglaser.github.io/respec/Spec/TeamSubmission/Private/",
        src: "https://sglaser.github.io/respec/Spec/Icons/team_private.svg",
        width: "211",
      };
      conf.logos.push({...baseLogo, ...teamPrivateLogo});
    }
    conf.isTeamSubmission = conf.specStatus === "team-submission";
    if (conf.isTeamSubmission) {
      const teamSubmissionLogo = {
        alt: "PCISIG Team Submission",
        href: "https://sglaser.github.io/respec/Spec/TeamSubmission/",
        src: "https://sglaser.github.io/respec/Spec/Icons/team_submmission.svg",
        width: "211",
      };
      conf.logos.push({...baseLogo, ...teamSubmissionLogo});
    }
    conf.isSubmission = conf.isMemberSubmission || conf.isTeamSubmission;
    conf.isPrivate = conf.isMemberPrivate || conf.isPrivate || conf.specStatus === "private";
    conf.anOrA = precededByAn.includes(conf.specStatus) ? "an" : "a";

    let temp = [];

    if (conf.specRevision) {
      temp.push(conf.specRevision);
    }
    if (conf.specDraftLevel) {
      temp.push(conf.specDraftLevel);
    }
    if (conf.specStatus) {
      temp.push(conf.specStatus);
    }
    if (conf.specChapter) {
      temp.push(conf.specChapter);
    }
    conf.maturity = temp.join("-");

    let publishSpace = "Spec/Published";
    if (conf.specStatus === "member-submission") publishSpace = "Spec/Submission";
    else if (conf.specStatus === "member-private") publishSpace = "Spec/Submission/Private";
    else if (conf.specStatus === "team-submission") publishSpace = "Spec/TeamSubmission";
    else if (conf.specStatus === "team-private") publishSpace = "Spec/TeamSubmission/Private";
    if (conf.isRegular)
      conf.thisVersion =
        "https://sglaser.github.io/respec/" +
        publishSpace +
        "/" +
        conf.publishDate.getUTCFullYear() +
        "/" +
        conf.shortName +
        "-" +
        conf.maturity +
        "-" +
        concatDate(conf.publishDate) +
        "/";
    if (conf.isRegular)
      conf.latestVersion =
        "https://sglaser.github.io/respec/" + publishSpace + "/" + conf.shortName + "/";

    if (conf.previousPublishDate) {
      if (!conf.previousStatus) {
        pub("error", "`previousPublishDate` is set, but not `previousStatus`.");
      }
      if (!conf.previousRevision) {
        pub("error", "`previousPublishDate` is set, but not `previousRevision`.");
      }
      if (!conf.previousDraftLevel) {
        pub("error", "`previousPublishDate` is set, but not `previousDraftLevel`.");
      }

      conf.previousPublishDate = validateDateAndRecover(
        conf,
        "previousPublishDate"
      );

      if (conf.previousRevision) {
        temp.push(conf.previousRevision);
      }
      if (conf.previousDraftLevel) {
        temp.push(conf.previousDraftLevel);
      }
      if (conf.previousStatus) {
        temp.push(conf.previousStatus);
      }
      let pmat = temp.join("-");

      if (conf.isBasic) {
        conf.prevVersion = "";
      } else {
        conf.prevVersion =
          "https://sglaser.github.io/respec/Spec/" +
          conf.previousPublishDate.getUTCFullYear() +
          "/" +
          conf.shortName +
          "-" +
          pmat +
          "-" +
          concatDate(conf.previousPublishDate) +
          "/";
      }
    } else {
      if (
        !(/NOTE$/.test(conf.specStatus)) &&
        !conf.prevStatus === "none" &&
        !conf.noSpecTrack &&
        !conf.isNoTrack &&
        !conf.isSubmission
      )
        pub(
          "error",
          "Document on specification track but has no previous version:" +
          " Add `previousStatus`, `previousRevision`, `previousDraftLevel`, and `previousPublishDate` to ReSpec's config."
        );
      if (!conf.prevVersion) conf.prevVersion = "";
    }
    if (!conf.wg) {
      if (!conf.editors || conf.editors.length === 0)
        pub("error", "At least one editor is required");
    }

    let peopCheck = function (it) {
      if (!it.name) pub("error", "All authors and editors must have a name.");
    };
    if (conf.editors) {
      conf.editors.forEach(peopCheck);
    }
    if (conf.authors) {
      conf.authors.forEach(peopCheck);
    }
    conf.multipleEditors = conf.editors && conf.editors.length > 1;
    conf.multipleAuthors = conf.authors && conf.authors.length > 1;

    $.each(conf.alternateFormats || [], function (i, it) {
      if (!it.uri || !it.label)
        pub("error", "All alternate formats must have a uri and a label.");
    });
    conf.multipleAlternates =
      conf.alternateFormats && conf.alternateFormats.length > 1;
    conf.alternatesHTML =
      conf.alternateFormats &&
      joinAnd(conf.alternateFormats, function (alt) {
        let optional = alt.hasOwnProperty("lang") && alt.lang
          ? " hreflang='" + alt.lang + "'"
          : "";
        optional += alt.hasOwnProperty("type") && alt.type
          ? " type='" + alt.type + "'"
          : "";
        return (
          "<a rel='alternate' href='" +
          alt.uri +
          "'" +
          optional +
          ">" +
          alt.label +
          "</a>"
        );
      });
    if (conf.bugTracker) {
      if (conf.bugTracker["new"] && conf.bugTracker.open) {
        conf.bugTrackerHTML =
          "<a href='" +
          conf.bugTracker["new"] +
          "'>" +
          conf.l10n.file_a_bug +
          "</a> " +
          conf.l10n.open_parens +
          "<a href='" +
          conf.bugTracker.open +
          "'>" +
          conf.l10n.open_bugs +
          "</a>" +
          conf.l10n.close_parens;
      } else if (conf.bugTracker.open) {
        conf.bugTrackerHTML =
          "<a href='" + conf.bugTracker.open + "'>open bugs</a>";
      } else if (conf.bugTracker["new"]) {
        conf.bugTrackerHTML =
          "<a href='" + conf.bugTracker["new"] + "'>file a bug</a>";
      }
    }
    if (conf.copyrightStart && conf.copyrightStart == conf.publishYear)
      conf.copyrightStart = "";
    for (let k in status2text) {
      if (status2long[k]) continue;
      status2long[k] = status2text[k];
    }
    conf.longStatus = status2long[conf.specStatus];
    conf.textStatus = status2text[conf.specStatus];
    if (status2rdf[conf.specStatus]) {
      conf.rdfStatus = status2rdf[conf.specStatus];
    }
    conf.showThisVersion = !conf.isNoTrack;
    conf.showPreviousVersion =
      !conf.previousStatus === "none" &&
      !conf.isNoTrack &&
      !conf.isSubmission;
    if (/NOTE$/.test(conf.specStatus) && !conf.prevVersion)
      conf.showPreviousVersion = false;
    conf.notYetFinal = conf.isSpecTrack && (conf.specStatus !== "FINAL" || conf.specStatus !== "PUB-FINAL");
    conf.isFinal = conf.isSpecTrack && (conf.specStatus === "FINAL" || conf.specStatus === "PUB-FINAL");
    if (conf.isFinal && !conf.errata)
      pub("error", "Recommendations must have an errata link.");
    conf.isUnofficial = conf.specStatus === "unofficial";
    conf.prependPCISIG = !conf.isUnofficial;
    conf.isWD = conf.specStatus === "WD" || conf.specStatus === "WD-CWG" || conf.specStatus === "WD-MEM" || conf.specStatus === "WD-FINAL";
    conf.isRC = conf.specStatus === "RC" || conf.specStatus === "RC-CWG" || conf.specStatus === "RC-MEM" || conf.specStatus === "RC-FINAL";
    conf.isPUB = conf.specStatus === "PUB" || conf.specStatus === "PUB-CWG" || conf.specStatus === "PUB-MEM";
    conf.dashDate = ISODate.format(conf.publishDate);
    conf.publishISODate = conf.publishDate.toISOString();
    conf.shortISODate = ISODate.format(conf.publishDate);

    // NOTE:
    if (Array.isArray(conf.wg)) {
      conf.multipleWGs = conf.wg.length > 1;
      conf.wgHTML = joinAnd(conf.wg);
    } else {
      conf.multipleWGs = false;
      conf.wgHTML = conf.wg;
    }

  // insert into document and mark with microformat
    let bp;
    bp = headersTmpl(conf);
    $("body", doc).prepend($(bp)).addClass("h-entry");

  // invent toc if not already present
    if (!document.body.querySelector("#toc")) {
      $("body", doc).prepend($("<nav id=\"toc\"><section class=\"introductory\"></section></nav>"));
    }

  // handle Revision History
    let revision_history =
      document.body.querySelector("#revision-history") || document.createElement("section");
    if ((!conf.isNoTrack) && !revision_history.id) {
      pub(
        "error",
        "A Revision History section is required for your type of document."
      );
    }
    revision_history.id = revision_history.id || "revision-history";
    revision_history.classList.add("introductory");

  // handle SotD
    let sotd =
      document.body.querySelector("#sotd") || document.createElement("section");
    if ((!conf.isNoTrack) && !sotd.id) {
      pub(
        "error",
        "A custom SotD paragraph is required for your type of document."
      );
    }
    sotd.id = sotd.id || "stod";
    sotd.classList.add("introductory");


    if (conf.specStatus === "PUB-CWG" && !conf.cwgReviewEnd) {
      pub(
        "error",
        `'specStatus' is "PUB-CWG" but no 'cwgReviewEnd' is specified (needed to indicate end of the Cross Workgroup Review).`
      );
    }
    conf.cwgReviewEnd = validateDateAndRecover(conf, "cwgReviewEnd");
    conf.humanCwgReviewEnd = PCISIGDate.format(conf.cwgReviewEnd);


    if (conf.specStatus === "PUB-MEM" && !conf.memReviewEnd) {
      pub(
        "error",
        `'specStatus' is "PUB-MEM", but no 'memReviewEnd' is specified (needed to indicate end of the Member Review).`
      );
    }
    conf.memReviewEnd = validateDateAndRecover(conf, "memReviewEnd");
    conf.humanMemReviewEnd = PCISIGDate.format(conf.memReviewEnd);

    sotd.innerHTML = populateSoTD(conf, sotd);

  // Requested by https://github.com/pcisig/respec/issues/504
  // Makes a record of a few auto-generated things.
    pub("amend-user-config", {
      publishISODate: conf.publishISODate,
      generatedSubtitle: `${conf.longStatus} ${conf.publishHumanDate}`,
    });
    cb();
  }

  function populateSoTD(conf, sotd) {
    const sotdClone = sotd.cloneNode(true);
    const additionalNodes = document.createDocumentFragment();
    const additionalContent = document.createElement("temp");
    // we collect everything until we hit a section,
    // that becomes the custom content.
    while (sotdClone.hasChildNodes()) {
      if (
        sotdClone.firstChild.nodeType !== Node.ELEMENT_NODE ||
        sotdClone.firstChild.localName !== "section"
      ) {
        additionalNodes.appendChild(sotdClone.firstChild);
        continue;
      }
      break;
    }
    additionalContent.appendChild(additionalNodes);
    conf.additionalContent = additionalContent.innerHTML;
    // Whatever sections are left, we throw at the end.
    conf.additionalSections = sotdClone.innerHTML;
    return tmpls["pcisig-sotd"](conf);
  }

  var pcisigHeaders = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$t,
    run: run$t
  });

  /*global define */


  const name$s = "pcisig/footnotes";

  function run$s(conf, doc, cb) {

    let $footnotes = $("span.footnote", doc);
    if ($footnotes.length) {
      $footnotes.each(function (index) {
        $(this).prepend("<span class='footnote-online'> [Footnote: </span>")
          .append("<span class='footnote-online'>] </span>");
        let id = "footnote-" + (index + 1);
        let span = "<span class='footnote-contents' id='" + id + "'></span>";
        let input = "<input type='checkbox' name='" + id + "' value='#" + id + "'></input>";
        $(this).wrapInner(span)
          .prepend(input);
      });
    }
    cb();
  }

  var footnotes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$s,
    run: run$s
  });

  // Module pcisig/conformance
  // Handle the conformance section properly.

  const name$r = "pcisig/conformance";
  const confoTmpl = tmpls["pcisig-conformance"];

  function run$r(conf, doc, cb) {
    var $confo = $("#conformance");
    if ($confo.length) $confo.prepend(confoTmpl(conf));
    // Added message for legacy compat with Aria specs
    // See https://github.com/w3c/respec/issues/793
    pub("end", "pcisig/conformance");
    cb();
  }

  var pcisigConformance = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$r,
    run: run$r
  });

  // @ts-check
  // Module core/data-transform
  // Support for the data-transform attribute
  // Any element in the tree that has a data-transform attribute is processed here.
  // The data-transform attribute can contain a white space separated list of functions
  // to call (these must have been defined globally). Each is called with a reference to
  // the core/utils plugin and the innerHTML of the element. The output of each is fed
  // as the input to the next, and the output of the last one replaces the HTML content
  // of the element.
  // IMPORTANT:
  //  It is unlikely that you should use this module. The odds are that unless you really
  //  know what you are doing, you should be using a dedicated module instead. This feature
  //  is not actively supported and support for it may be dropped. It is not accounted for
  //  in the test suite, and therefore could easily break.

  const name$q = "core/data-transform";

  function run$q() {
    /** @type {NodeListOf<HTMLElement>} */
    const transformables = document.querySelectorAll("[data-transform]");
    transformables.forEach(el => {
      el.innerHTML = runTransforms(el.innerHTML, el.dataset.transform);
      el.removeAttribute("data-transform");
    });
  }

  var dataTransform = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$q,
    run: run$q
  });

  // @ts-check
  // Parses an inline IDL string (`{{ idl string }}`)
  //  and renders its components as HTML

  const idlPrimitiveRegex = /^[a-z]+(\s+[a-z]+)+\??$/; // {{unrestricted double?}} {{ double }}
  const exceptionRegex = /\B"([^"]*)"\B/; // {{ "SomeException" }}

  /**
   * Matches following patterns:
   * - `identifier(arg1, moreArgs)`
   * - `identifier()`
   * - `identifier(arg1, moreArgs)|text`
   * - `identifier(arg1, moreArgs)|text()`
   * - `identifier(arg1, moreArgs)|text(argA, moreArgs)`
   *
   * Groups: identifier, args, [text, [textArgs]]
   */
  const methodRegex = /^(\w+)\(([^\\)]*)\)(?:\|(\w+)(?:\((?:([^\\)]*))\))?)?$/;

  const slotRegex = /\[\[(\w+(?: +\w+)*)\]\](\([^)]*\))?$/;
  // matches: `value` or `[[value]]`
  // NOTE: [[value]] is actually a slot, but database has this as type="attribute"
  const attributeRegex = /^((?:\[\[)?(?:\w+(?: +\w+)*)(?:\]\])?)$/;
  const baseRegex = /^(?:\w+)\??$/;
  const enumRegex = /^(\w+)\["([\w- ]*)"\]$/;
  // TODO: const splitRegex = /(?<=\]\]|\b)\./
  // https://github.com/speced/respec/pull/1848/files#r225087385
  const methodSplitRegex = /\.?(\w+\(.*\)$)/;
  const slotSplitRegex = /\/(.+)/;
  const isProbablySlotRegex = /\[\[.+\]\]/;
  /**
   * @typedef {object} IdlBase
   * @property {"base"} type
   * @property {string} identifier
   * @property {boolean} renderParent
   * @property {boolean} nullable
   * @property {InlineIdl | null} [parent]
   *
   * @typedef {object} IdlAttribute
   * @property {"attribute"} type
   * @property {string} identifier
   * @property {boolean} renderParent
   * @property {InlineIdl | null} [parent]
   *
   * @typedef {object} IdlInternalSlot
   * @property {"internal-slot"} type
   * @property {string} identifier
   * @property {string[]} [args]
   * @property {boolean} renderParent
   * @property {InlineIdl | null} [parent]
   * @property {"attribute"|"method"} slotType
   *
   * @typedef {object} IdlMethod
   * @property {"method"} type
   * @property {string} identifier
   * @property {string[]} args
   * @property {string | undefined} renderText
   * @property {string[] | undefined} renderArgs
   * @property {boolean} renderParent
   * @property {InlineIdl | null} [parent]
   *
   * @typedef {object} IdlEnum
   * @property {"enum"} type
   * @property {string} [identifier]
   * @property {string} enumValue
   * @property {boolean} renderParent
   * @property {InlineIdl | null} [parent]
   *
   * @typedef {object} IdlException
   * @property {"exception"} type
   * @property {string} identifier
   * @property {InlineIdl | null} [parent]
   *
   * @typedef {object} IdlPrimitive
   * @property {"idl-primitive"} type
   * @property {boolean} nullable
   * @property {string} identifier
   * @property {boolean} renderParent
   * @property {InlineIdl | null} [parent]
   *
   * @typedef {IdlBase | IdlAttribute | IdlInternalSlot | IdlMethod | IdlEnum | IdlException | IdlPrimitive} InlineIdl
   */

  /**
   * @param {string} str
   * @returns {InlineIdl[]}
   */
  function parseInlineIDL(str) {
    // If it's got [[ string ]], then split as an internal slot
    const isSlot = isProbablySlotRegex.test(str);
    const splitter = isSlot ? slotSplitRegex : methodSplitRegex;
    const [forPart, childString] = str.split(splitter);
    if (isSlot && forPart && !childString) {
      throw new SyntaxError(
        `Internal slot missing "for" part. Expected \`{{ InterfaceName/${forPart}}}\` }.`
      );
    }
    const tokens = forPart
      .split(/[./]/)
      .concat(childString)
      .filter(s => s && s.trim())
      .map(s => s.trim());
    const renderParent = !str.includes("/");
    /** @type {InlineIdl[]} */
    const results = [];
    while (tokens.length) {
      const value = tokens.pop();
      // Method
      if (methodRegex.test(value)) {
        const [, identifier, allArgs, altText, altArgs] =
          value.match(methodRegex);
        const args = allArgs.split(/,\s*/).filter(arg => arg);
        const renderText = altText?.trim();
        const renderArgs = altArgs?.split(/,\s*/).filter(arg => arg);
        results.push({
          type: "method",
          identifier,
          args,
          renderParent,
          renderText,
          renderArgs,
        });
        continue;
      }
      // Enum["enum value"]
      if (enumRegex.test(value)) {
        const [, identifier, enumValue] = value.match(enumRegex);
        results.push({ type: "enum", identifier, enumValue, renderParent });
        continue;
      }
      // Exception - "NotAllowedError"
      // Or alternate enum syntax: {{ EnumContainer / "some enum value" }}
      if (exceptionRegex.test(value)) {
        const [, identifier] = value.match(exceptionRegex);
        if (renderParent) {
          results.push({ type: "exception", identifier });
        } else {
          results.push({ type: "enum", enumValue: identifier, renderParent });
        }
        continue;
      }
      // internal slot
      if (slotRegex.test(value)) {
        const [, identifier, allArgs] = value.match(slotRegex);
        const slotType = allArgs ? "method" : "attribute";
        const args = allArgs
          ?.slice(1, -1)
          .split(/,\s*/)
          .filter(arg => arg);
        results.push({
          type: "internal-slot",
          slotType,
          identifier,
          args,
          renderParent,
        });
        continue;
      }
      // attribute
      if (attributeRegex.test(value) && tokens.length) {
        const [, identifier] = value.match(attributeRegex);
        results.push({ type: "attribute", identifier, renderParent });
        continue;
      }
      if (idlPrimitiveRegex.test(value)) {
        const nullable = value.endsWith("?");
        const identifier = nullable ? value.slice(0, -1) : value;
        results.push({
          type: "idl-primitive",
          identifier,
          renderParent,
          nullable,
        });
        continue;
      }
      // base, always final token
      if (baseRegex.test(value) && tokens.length === 0) {
        const nullable = value.endsWith("?");
        const identifier = nullable ? value.slice(0, -1) : value;
        results.push({ type: "base", identifier, renderParent, nullable });
        continue;
      }
      throw new SyntaxError(`IDL micro-syntax parsing error in \`{{ ${str} }}\``);
    }
    // link the list
    results.forEach((item, i, list) => {
      item.parent = list[i + 1] || null;
    });
    // return them in the order we found them...
    return results.reverse();
  }

  /**
   * @param {IdlBase} details
   */
  function renderBase(details) {
    // Check if base is a local variable in a section
    const { identifier, renderParent, nullable } = details;
    if (renderParent) {
      return html`<a
      data-xref-type="_IDL_"
      data-link-type="idl"
      data-lt="${identifier}"
      ><code>${identifier + (nullable ? "?" : "")}</code></a
    >`;
    }
  }

  /**
   * Internal slot: .[[identifier]] or [[identifier]]
   * @param {IdlInternalSlot} details
   */
  function renderInternalSlot(details) {
    const { identifier, parent, slotType, renderParent, args } = details;
    const { identifier: linkFor } = parent || {};
    const isMethod = slotType === "method";
    const argsHtml = isMethod
      ? html`(${htmlJoinComma(args, htmlArgMapper)})`
      : null;
    const textArgs = isMethod ? `(${args.join(", ")})` : "";
    const lt = `[[${identifier}]]${textArgs}`;
    const element = html`${parent && renderParent ? "." : ""}<a
      data-xref-type="${slotType}"
      data-link-type="${slotType}"
      data-link-for="${linkFor}"
      data-xref-for="${linkFor}"
      data-lt="${lt}"
      ><code>[[${identifier}]]${argsHtml}</code></a
    >`;
    return element;
  }

  function htmlArgMapper(str, i, array) {
    if (i < array.length - 1) return html`<var>${str}</var>`;
    // only the last argument can be variadic
    const parts = str.split(/(^\.{3})(.+)/);
    const isVariadic = parts.length > 1;
    const arg = isVariadic ? parts[2] : parts[0];
    return html`${isVariadic ? "..." : null}<var>${arg}</var>`;
  }
  /**
   * Attribute: .identifier
   * @param {IdlAttribute} details
   */
  function renderAttribute(details) {
    const { parent, identifier, renderParent } = details;
    const { identifier: linkFor } = parent || {};
    const element = html`${renderParent ? "." : ""}<a
      data-link-type="idl"
      data-xref-type="attribute|dict-member|const"
      data-link-for="${linkFor}"
      data-xref-for="${linkFor}"
      ><code>${identifier}</code></a
    >`;
    return element;
  }

  /**
   * Method: .identifier(arg1, arg2, ...), identifier(arg1, arg2, ...)
   * @param {IdlMethod} details
   */
  function renderMethod(details) {
    const { args, identifier, type, parent, renderParent } = details;
    const { renderText: text, renderArgs: textArgs } = details;
    const { identifier: linkFor } = parent || {};
    const argsText = htmlJoinComma(textArgs || args, htmlArgMapper);
    const searchText = `${identifier}(${args.join(", ")})`;
    const element = html`${parent && renderParent ? "." : ""}<a
      data-link-type="idl"
      data-xref-type="${type}"
      data-link-for="${linkFor}"
      data-xref-for="${linkFor}"
      data-lt="${searchText}"
      ><code>${text || identifier}</code></a
    >${!text || textArgs ? html`<code>(${argsText})</code>` : ""}`;
    return element;
  }

  /**
   * Enum:
   * Identifier["enum value"]
   * Identifer / "enum value"
   * @param {IdlEnum} details
   */
  function renderEnum(details) {
    const { identifier, enumValue, parent } = details;
    const forContext = parent ? parent.identifier : identifier;
    const element = html`"<a
      data-link-type="idl"
      data-xref-type="enum-value"
      data-link-for="${forContext}"
      data-xref-for="${forContext}"
      data-lt="${!enumValue ? "the-empty-string" : null}"
      ><code>${enumValue}</code></a
    >"`;
    return element;
  }

  /**
   * Exception value: "NotAllowedError"
   * Only the WebIDL spec can define exceptions
   * @param {IdlException} details
   */
  function renderException(details) {
    const { identifier } = details;
    const element = html`"<a
      data-link-type="idl"
      data-cite="webidl"
      data-xref-type="exception"
      ><code>${identifier}</code></a
    >"`;
    return element;
  }

  /**
   * Interface types: {{ unrestricted double }} {{long long}}
   * Only the WebIDL spec defines these types.
   * @param {IdlPrimitive} details
   */
  function renderIdlPrimitiveType(details) {
    const { identifier, nullable } = details;
    const element = html`<a
    data-link-type="idl"
    data-cite="webidl"
    data-xref-type="interface"
    data-lt="${identifier}"
    ><code>${identifier + (nullable ? "?" : "")}</code></a
  >`;
    return element;
  }

  /**
   * Generates HTML by parsing an IDL string
   * @param {String} str IDL string
   * @return {Node} html output
   */
  function idlStringToHtml(str) {
    let results;
    try {
      results = parseInlineIDL(str);
    } catch (error) {
      const el = html`<span>{{ ${str} }}</span>`;
      const title = "Error: Invalid inline IDL string.";
      showError(error.message, "core/inlines", { title, elements: [el] });
      return el;
    }
    const render = html(document.createDocumentFragment());
    const output = [];
    for (const details of results) {
      switch (details.type) {
        case "base": {
          const base = renderBase(details);
          if (base) output.push(base);
          break;
        }
        case "attribute":
          output.push(renderAttribute(details));
          break;
        case "internal-slot":
          output.push(renderInternalSlot(details));
          break;
        case "method":
          output.push(renderMethod(details));
          break;
        case "enum":
          output.push(renderEnum(details));
          break;
        case "exception":
          output.push(renderException(details));
          break;
        case "idl-primitive":
          output.push(renderIdlPrimitiveType(details));
          break;
        default:
          throw new Error("Unknown type.");
      }
    }
    const result = render`${output}`;
    return result;
  }

  // @ts-check
  /**
   * Module core/biblio-db
   *
   * Wraps IndexedDB, allowing the storage of references and aliases on the
   * client.
   *
   * It's a standalone module that can be imported into other modules.
   *
   */

  /**
   * @typedef {keyof BiblioDb} AllowedType
   * @type {Set<AllowedType>}
   */
  const ALLOWED_TYPES = new Set(["alias", "reference"]);
  /* Database initialization tracker */
  const readyPromise = openIdb();

  /**
   * @typedef {object} BiblioDb
   *
   * @property {object} alias Object store for alias objects
   * @property {string} alias.key
   * @property {object} alias.value
   * @property {object} alias.indexes
   * @property {string} alias.aliasOf
   *
   * @property {object} reference Object store for reference objects
   * @property {string} reference.key
   * @property {object} reference.value
   *
   * @returns {Promise<import("idb").IDBPDatabase<BiblioDb>>}
   */
  async function openIdb() {
    /** @type {import("idb").IDBPDatabase<BiblioDb>} */
    const db = await idb.openDB("respec-biblio2", 12, {
      upgrade(db) {
        Array.from(db.objectStoreNames).map(storeName =>
          db.deleteObjectStore(storeName)
        );
        const store = db.createObjectStore("alias", { keyPath: "id" });
        store.createIndex("aliasOf", "aliasOf", { unique: false });
        db.createObjectStore("reference", { keyPath: "id" });
      },
    });
    // Clean the database of expired biblio entries.
    const now = Date.now();
    for (const storeName of [...ALLOWED_TYPES]) {
      const store = db.transaction(storeName, "readwrite").store;
      const range = IDBKeyRange.lowerBound(now);
      let result = await store.openCursor(range);
      while (result?.value) {
        /** @type {BiblioData} */
        const entry = result.value;
        if (entry.expires === undefined || entry.expires < now) {
          await store.delete(entry.id);
        }
        result = await result.continue();
      }
    }

    return db;
  }

  const biblioDB = {
    get ready() {
      return readyPromise;
    },
    /**
     * Finds either a reference or an alias.
     * If it's an alias, it resolves it.
     *
     * @param {String} id The reference or alias to look for.
     * @return {Promise<BiblioData?>} The reference or null.
     */
    async find(id) {
      if (await this.isAlias(id)) {
        id = await this.resolveAlias(id);
      }
      return await this.get("reference", id);
    },
    /**
     * Checks if the database has an id for a given type.
     *
     * @param {AllowedType} type One of the ALLOWED_TYPES.
     * @param {String} id The reference to find.
     * @return {Promise<Boolean>} True if it has it, false otherwise.
     */
    async has(type, id) {
      if (!ALLOWED_TYPES.has(type)) {
        throw new TypeError(`Invalid type: ${type}`);
      }
      if (!id) {
        throw new TypeError("id is required");
      }
      const db = await this.ready;
      const objectStore = db.transaction(type, "readonly").store;
      const range = IDBKeyRange.only(id);
      const result = await objectStore.openCursor(range);
      return !!result;
    },
    /**
     * Checks if a given id is an alias.
     *
     * @param {String} id The reference to check.
     * @return {Promise<Boolean>} Resolves with true if found.
     */
    async isAlias(id) {
      return await this.has("alias", id);
    },
    /**
     * Resolves an alias to its corresponding reference id.
     *
     * @param {String} id The id of the alias to look up.
     * @return {Promise<String>} The id of the resolved reference.
     */
    async resolveAlias(id) {
      if (!id) {
        throw new TypeError("id is required");
      }
      const db = await this.ready;

      const objectStore = db.transaction("alias", "readonly").store;
      const range = IDBKeyRange.only(id);
      const result = await objectStore.openCursor(range);
      return result ? result.value.aliasOf : null;
    },
    /**
     * Get a reference or alias out of the database.
     *
     * @param {AllowedType} type The type as per ALLOWED_TYPES.
     * @param {string} id The id for what to look up.
     * @return {Promise<BiblioData?>} Resolves with the retrieved object, or null.
     */
    async get(type, id) {
      if (!ALLOWED_TYPES.has(type)) {
        throw new TypeError(`Invalid type: ${type}`);
      }
      if (!id) {
        throw new TypeError("id is required");
      }
      const db = await this.ready;
      const objectStore = db.transaction(type, "readonly").store;
      const range = IDBKeyRange.only(id);
      const result = await objectStore.openCursor(range);
      return result ? result.value : null;
    },
    /**
     * Adds references and aliases to database. This is usually the data from
     * Specref's output (parsed JSON).
     *
     * @param {BibliographyMap} data An object that contains references and aliases.
     * @param {number} expires The date/time when the data expires.
     */
    async addAll(data, expires) {
      if (!data) {
        return;
      }
      const aliasesAndRefs = { alias: [], reference: [] };
      for (const id of Object.keys(data)) {
        /** @type {BiblioData} */
        const obj = { id, ...data[id], expires };
        if (obj.aliasOf) {
          aliasesAndRefs.alias.push(obj);
        } else {
          aliasesAndRefs.reference.push(obj);
        }
      }
      const promisesToAdd = [...ALLOWED_TYPES].flatMap(type => {
        return aliasesAndRefs[type].map(details => this.add(type, details));
      });
      await Promise.all(promisesToAdd);
    },
    /**
     * Adds a reference or alias to the database.
     *
     * @param {AllowedType} type The type as per ALLOWED_TYPES.
     * @param {BiblioData} details The object to store.
     */
    async add(type, details) {
      if (!ALLOWED_TYPES.has(type)) {
        throw new TypeError(`Invalid type: ${type}`);
      }
      if (typeof details !== "object") {
        throw new TypeError("details should be an object");
      }
      if (type === "alias" && !details.hasOwnProperty("aliasOf")) {
        throw new TypeError("Invalid alias object.");
      }
      const db = await this.ready;
      let isInDB = await this.has(type, details.id);
      // update or add, depending of already having it in db
      // or if it's expired
      if (isInDB) {
        const entry = await this.get(type, details.id);
        if (entry?.expires < Date.now()) {
          const { store } = db.transaction(type, "readwrite");
          await store.delete(details.id);
          isInDB = false;
        }
      }
      const { store } = db.transaction(type, "readwrite");
      return isInDB ? await store.put(details) : await store.add(details);
    },
    /**
     * Closes the underlying database.
     *
     * @return {Promise<void>} Resolves after database closes.
     */
    async close() {
      const db = await this.ready;
      db.close();
    },

    /**
     * Clears the underlying database
     */
    async clear() {
      const db = await this.ready;
      const storeNames = [...ALLOWED_TYPES];
      const stores = db.transaction(storeNames, "readwrite");
      const clearStorePromises = storeNames.map(name => {
        return stores.objectStore(name).clear();
      });
      await Promise.all(clearStorePromises);
    },
  };

  // @ts-check
  // Module core/biblio
  // Pre-processes bibliographic references
  // Configuration:
  //  - localBiblio: override or supplement the official biblio with your own.


  /** @type {Conf['biblio']} */
  const biblio = {};

  const bibrefsURL = new URL("https://api.specref.org/bibrefs?refs=");

  // Opportunistically dns-prefetch to bibref server, as we don't know yet
  // if we will actually need to download references yet.
  const link = createResourceHint({
    hint: "dns-prefetch",
    href: bibrefsURL.origin,
  });
  document.head.appendChild(link);

  /** @type {Promise<Conf['biblio']>} */
  const done = new Promise(resolve => {
  });

  async function updateFromNetwork(
    refs,
    options = { forceUpdate: false }
  ) {
    const refsToFetch = [...new Set(refs)].filter(ref => ref.trim());
    // Update database if needed, if we are online
    if (!refsToFetch.length || navigator.onLine === false) {
      return null;
    }
    let response;
    try {
      response = await fetch(bibrefsURL.href + refsToFetch.join(","));
    } catch (err) {
      console.error(err);
      return null;
    }
    if ((!options.forceUpdate && !response.ok) || response.status !== 200) {
      return null;
    }
    /** @type {Conf['biblio']} */
    const data = await response.json();
    // SpecRef updates every hour, so we should follow suit
    // https://github.com/tobie/specref#hourly-auto-updating
    const oneHourFromNow = Date.now() + 1000 * 60 * 60 * 1;
    try {
      const expires = response.headers.has("Expires")
        ? Math.min(Date.parse(response.headers.get("Expires")), oneHourFromNow)
        : oneHourFromNow;
      await biblioDB.addAll(data, expires);
    } catch (err) {
      console.error(err);
    }
    return data;
  }

  /**
   * @param {string} key
   * @returns {Promise<BiblioData>}
   */
  async function resolveRef(key) {
    const biblio = await done;
    if (!biblio.hasOwnProperty(key)) {
      return null;
    }
    const entry = biblio[key];
    if (entry.aliasOf) {
      return await resolveRef(entry.aliasOf);
    }
    return entry;
  }

  // @ts-check
  // Module core/render-biblio
  // renders the biblio data pre-processed in core/biblio


  const localizationStrings$b = {
    en: {
      info_references: "Informative references",
      norm_references: "Normative references",
      references: "References",
      reference_not_found: "Reference not found.",
    },
    ko: {
      references: "ì°¸ì¡°",
    },
    nl: {
      info_references: "Informatieve referenties",
      norm_references: "Normatieve referenties",
      references: "Referenties",
    },
    es: {
      info_references: "Referencias informativas",
      norm_references: "Referencias normativas",
      references: "Referencias",
      reference_not_found: "Referencia no encontrada.",
    },
    ja: {
      info_references: "åç§ç¨åèæç®",
      norm_references: "è¦ç¯çåèæç®",
      references: "åèæç®",
    },
    de: {
      info_references: "WeiterfÃ¼hrende Informationen",
      norm_references: "Normen und Spezifikationen",
      references: "Referenzen",
    },
    zh: {
      info_references: "éè§èæ§å¼ç¨",
      norm_references: "è§èæ§å¼ç¨",
      references: "åèæç®",
    },
    cs: {
      info_references: "InformativnÃ­ odkazy",
      norm_references: "NormativnÃ­ odkazy",
      references: "Odkazy",
      reference_not_found: "Odkaz nebyl nalezen.",
    },
  };

  getIntlData(localizationStrings$b);

  /**
   * Render an inline citation
   *
   * @param {String} ref the inline reference.
   * @param {String} [linkText] custom link text
   * @returns HTMLElement
   */
  function renderInlineCitation(ref, linkText) {
    const key = ref.replace(/^(!|\?)/, "");
    const href = `#bib-${key.toLowerCase()}`;
    const text = linkText || key;
    const elem = html`<cite
    ><a class="bibref" href="${href}" data-link-type="biblio">${text}</a></cite
  >`;
    return linkText ? elem : html`[${elem}]`;
  }

  // @ts-check
  // Module core/inlines
  // Process all manners of inline information. These are done together despite it being
  // seemingly a better idea to orthogonalise them. The issue is that processing text nodes
  // is harder to orthogonalise, and in some browsers can also be particularly slow.
  // Things that are recognised are <abbr>/<acronym> which when used once are applied
  // throughout the document, [[REFERENCES]]/[[!REFERENCES]], {{ IDL }} and RFC2119 keywords.


  const name$p = "core/inlines";
  const rfc2119Usage = {};

  /** @param {RegExp[]} regexes */
  const joinRegex = regexes => new RegExp(regexes.map(re => re.source).join("|"));

  const localizationStrings$a = {
    en: {
      rfc2119Keywords() {
        return joinRegex([
          /\bMUST(?:\s+NOT)?\b/,
          /\bSHOULD(?:\s+NOT)?\b/,
          /\bSHALL(?:\s+NOT)?\b/,
          /\bMAY\b/,
          /\b(?:NOT\s+)?REQUIRED\b/,
          /\b(?:NOT\s+)?RECOMMENDED\b/,
          /\bOPTIONAL\b/,
        ]);
      },
    },
    de: {
      rfc2119Keywords() {
        return joinRegex([
          /\bMUSS\b/,
          /\bMÃSSEN\b/,
          /\bERFORDERLICH\b/,
          /\b(?:NICHT\s+)?NÃTIG\b/,
          /\bDARF(?:\s+NICHT)?\b/,
          /\bDÃRFEN(?:\s+NICHT)?\b/,
          /\bVERBOTEN\b/,
          /\bSOLL(?:\s+NICHT)?\b/,
          /\bSOLLEN(?:\s+NICHT)?\b/,
          /\b(?:NICHT\s+)?EMPFOHLEN\b/,
          /\bKANN\b/,
          /\bKÃNNEN\b/,
          /\bOPTIONAL\b/,
        ]);
      },
    },
  };
  const l10n$a = getIntlData(localizationStrings$a);

  // Inline `code`
  // TODO: Replace (?!`) at the end with (?:<!`) at the start when Firefox + Safari
  // add support.
  const inlineCodeRegExp = /(?:`[^`]+`)(?!`)/; // `code`
  const inlineIdlReference = /(?:{{[^}]+\?*}})/; // {{ WebIDLThing }}, {{ WebIDLThing? }}
  const inlineVariable = /\B\|\w[\w\s]*(?:\s*:[\w\s&;"?<>]+\??)?\|\B/; // |var : Type?|
  const inlineCitation = /(?:\[\[(?:!|\\|\?)?[\w.-]+(?:|[^\]]+)?\]\])/; // [[citation]]
  const inlineExpansion = /(?:\[\[\[(?:!|\\|\?)?#?[\w-.]+\]\]\])/; // [[[expand]]]
  const inlineAnchor = /(?:\[=[^=]+=\])/; // Inline [= For/link =]
  const inlineElement = /(?:\[\^[^^]+\^\])/; // Inline [^element^]

  /**
   * @example [^iframe^] // [^element^]
   * @example [^iframe/allow^] // [^element/element-attr^]
   * @param {string} matched
   * @return {HTMLElement}
   */
  function inlineElementMatches(matched) {
    const value = matched.slice(2, -2).trim();
    const [forPart, attribute, attrValue] = value
      .split("/", 3)
      .map(s => s && s.trim())
      .filter(s => !!s);

    const [xrefType, xrefFor, textContent] = (() => {
      // [^ /role ^], for example
      const isGlobalAttr = value.startsWith("/");
      if (isGlobalAttr) {
        return ["element-attr", null, forPart];
      } else if (attrValue) {
        return ["attr-value", `${forPart}/${attribute}`, attrValue];
      } else if (attribute) {
        return ["element-attr", forPart, attribute];
      } else {
        return ["element", null, forPart];
      }
    })();
    return html`<code
    ><a
      data-xref-type="${xrefType}"
      data-xref-for="${xrefFor}"
      data-link-type="${xrefType}"
      data-link-for="${xrefFor}"
      >${textContent}</a
    ></code
  >`;
  }

  /**
   * @param {string} matched
   * @return {HTMLElement}
   */
  function inlineRFC2119Matches(matched) {
    const value = norm(matched);
    const nodeElement = html`<em class="rfc2119">${value}</em>`;
    // remember which ones were used
    rfc2119Usage[value] = true;
    return nodeElement;
  }

  /**
   * @param {string} matched
   * @return {HTMLElement}
   */
  function inlineRefMatches(matched) {
    // slices "[[[" at the beginning and "]]]" at the end
    const ref = matched.slice(3, -3).trim();
    if (!ref.startsWith("#")) {
      return html`<a data-cite="${ref}" data-matched-text="${matched}"></a>`;
    }
    return html`<a href="${ref}" data-matched-text="${matched}"></a>`;
  }

  /**
   * @param {string} matched
   * @param {Text} text
   */
  function inlineXrefMatches(matched, text) {
    // slices "{{" at the beginning and "}}" at the end
    const ref = norm(matched.slice(2, -2));
    if (ref.startsWith("\\")) {
      return matched.replace("\\", "");
    }

    const node = idlStringToHtml(ref);
    // If it's inside a dfn or a `a`, it should just be coded, not linked.
    // This is because dfn elements are treated as links by ReSpec via role=link.
    const renderAsCode = !!text.parentElement.closest("dfn,a");
    return renderAsCode ? inlineCodeMatches(`\`${node.textContent}\``) : node;
  }

  /**
   * @param {string} matched
   * @param {Text} txt
   * @param {Object} conf
   * @return {Iterable<string | Node>}
   */
  function inlineBibrefMatches(matched, txt, conf) {
    // slices "[[" at the start and "]]" at the end
    const ref = matched.slice(2, -2);
    if (ref.startsWith("\\")) {
      return [`[[${ref.slice(1)}]]`];
    }

    const [spec, linkText] = ref.split("|").map(norm);
    const { type, illegal } = refTypeFromContext(spec, txt.parentElement);
    const cite = renderInlineCitation(spec, linkText);
    const cleanRef = spec.replace(/^(!|\?)/, "");
    if (illegal && !conf.normativeReferences.has(cleanRef)) {
      const citeElem = cite.childNodes[1] || cite;
      const msg = `Normative references in informative sections are not allowed. `;
      const hint = `Remove '!' from the start of the reference \`[[${ref}]]\``;
      showWarning(msg, name$p, { elements: [citeElem], hint });
    }

    if (type === "informative" && !illegal) {
      conf.informativeReferences.add(cleanRef);
    } else {
      conf.normativeReferences.add(cleanRef);
    }
    return cite.childNodes[1] ? cite.childNodes : [cite];
  }

  /**
   * @param {string} matched
   * @param {Text} txt
   * @param {Map<string, string>} abbrMap
   */
  function inlineAbbrMatches(matched, txt, abbrMap) {
    return txt.parentElement.tagName === "ABBR"
      ? matched
      : html`<abbr title="${abbrMap.get(matched)}">${matched}</abbr>`;
  }

  /**
   * @example |varName: type| => <var data-type="type">varName</var>
   * @example |varName| => <var>varName</var>
   * @param {string} matched
   */
  function inlineVariableMatches(matched) {
    // remove "|" at the beginning and at the end, then split at an optional `:`
    const matches = matched.slice(1, -1).split(":", 2);
    const [varName, type] = matches.map(s => s.trim());
    return html`<var data-type="${type}">${varName}</var>`;
  }

  /**
   * @example [= foo =] => <a>foo</a>
   * @example [= bar/foo =] => <a data-link-for="bar" data-xref-for="bar">foo</a>
   * @example [= `foo` =] => <a><code>foo</code></a>
   * @example [= foo|bar =] => <a data-lt="foo">bar</a>
   * @param {string} matched
   */
  function inlineAnchorMatches(matched) {
    matched = matched.slice(2, -2); // Chop [= =]
    const parts = splitByFor(matched);
    const [isFor, content] = parts.length === 2 ? parts : [null, parts[0]];
    const [linkingText, text] = content.includes("|")
      ? content.split("|", 2).map(s => s.trim())
      : [null, content];
    const processedContent = processInlineContent(text);
    const forContext = isFor ? norm(isFor) : null;
    return html`<a
    data-link-type="dfn|abstract-op"
    data-link-for="${forContext}"
    data-xref-for="${forContext}"
    data-lt="${linkingText}"
    >${processedContent}</a
  >`;
  }

  function inlineCodeMatches(matched) {
    const clean = matched.slice(1, -1); // Chop ` and `
    return html`<code>${clean}</code>`;
  }

  function processInlineContent(text) {
    if (inlineCodeRegExp.test(text)) {
      // We use a capture group to split, so we can process all the parts.
      return text.split(/(`[^`]+`)(?!`)/).map(part => {
        return part.startsWith("`")
          ? inlineCodeMatches(part)
          : processInlineContent(part);
      });
    }
    return document.createTextNode(text);
  }

  function run$p(conf) {
    const abbrMap = new Map();
    document.normalize();
    if (!document.querySelector("section#conformance")) {
      // make the document informative
      document.body.classList.add("informative");
    }
    conf.normativeReferences = new InsensitiveStringSet();
    conf.informativeReferences = new InsensitiveStringSet();

    if (!conf.respecRFC2119) conf.respecRFC2119 = rfc2119Usage;

    // PRE-PROCESSING
    /** @type {NodeListOf<HTMLElement>} */
    const abbrElements = document.querySelectorAll("abbr[title]:not(.exclude)");
    for (const { textContent, title } of abbrElements) {
      const key = norm(textContent);
      const value = norm(title);
      abbrMap.set(key, value);
    }
    const abbrRx = abbrMap.size
      ? new RegExp(`(?:\\b${[...abbrMap.keys()].join("\\b)|(?:\\b")}\\b)`)
      : null;

    // PROCESSING
    // Don't gather text nodes for these:
    const exclusions = ["#respec-ui", ".head", "pre", "svg", "script", "style"];
    const txts = getTextNodes(document.body, exclusions, {
      wsNodes: false, // we don't want nodes with just whitespace
    });
    const keywords = l10n$a.rfc2119Keywords();

    const inlinesRegex = new RegExp(
      `(${
      joinRegex([
        keywords,
        inlineIdlReference,
        inlineVariable,
        inlineCitation,
        inlineExpansion,
        inlineAnchor,
        inlineCodeRegExp,
        inlineElement,
        ...(abbrRx ? [abbrRx] : []),
      ]).source
    })`
    );
    for (const txt of txts) {
      const subtxt = txt.data.split(inlinesRegex);
      if (subtxt.length === 1) continue;
      const df = document.createDocumentFragment();
      let matched = true;
      for (const t of subtxt) {
        matched = !matched;
        if (!matched) {
          df.append(t);
          continue;
        }
        switch (true) {
          case t.startsWith("{{"):
            df.append(inlineXrefMatches(t, txt));
            break;
          case t.startsWith("[[["):
            df.append(inlineRefMatches(t));
            break;
          case t.startsWith("[["):
            df.append(...inlineBibrefMatches(t, txt, conf));
            break;
          case t.startsWith("|"):
            df.append(inlineVariableMatches(t));
            break;
          case t.startsWith("[="):
            df.append(inlineAnchorMatches(t));
            break;
          case t.startsWith("`"):
            df.append(inlineCodeMatches(t));
            break;
          case t.startsWith("[^"):
            df.append(inlineElementMatches(t));
            break;
          case abbrMap.has(t):
            df.append(inlineAbbrMatches(t, txt, abbrMap));
            break;
          case keywords.test(t):
            df.append(inlineRFC2119Matches(t));
            break;
        }
      }
      txt.replaceWith(df);
    }
  }

  /**
   * Linking strings are always composed of:
   *
   *   (for-part /)+ linking-text
   *
   * E.g., " ReadableStream / set up / pullAlgorithm ".
   * Where "ReadableStream/set up/" is for-part, and "pullAlgorithm" is
   * the linking-text.
   *
   * The for part is optional, but when present can be two or three levels deep.
   *
   * @param {string} str
   *
   */
  function splitByFor(str) {
    /** @param {string} str */
    const cleanUp = str => str.replace("%%", "/").split("/").map(norm).join("/");
    const safeStr = str.replace("\\/", "%%");
    const lastSlashIdx = safeStr.lastIndexOf("/");
    if (lastSlashIdx === -1) {
      return [cleanUp(safeStr)];
    }
    const forPart = safeStr.substring(0, lastSlashIdx);
    const linkingText = safeStr.substring(lastSlashIdx + 1, safeStr.length);
    return [cleanUp(forPart), cleanUp(linkingText)];
  }

  var inlines = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$p,
    rfc2119Usage: rfc2119Usage,
    run: run$p
  });

  /* --- EXAMPLES --- */
  const css$4 = String.raw;

  // Prettier ignore only to keep code indented from level 0.
  // prettier-ignore
  var css$5 = css$4`
span.example-title {
  text-transform: none;
}

:is(aside,div).example,
div.illegal-example {
  padding: 0.5em;
  margin: 1em 0;
  position: relative;
  clear: both;
}

div.illegal-example {
  color: red;
}

div.illegal-example p {
  color: black;
}

aside.example div.example {
  border-left-width: 0.1em;
  border-color: #999;
  background: #fff;
}
`;

  // @ts-check
  // Module core/examples
  // Manages examples, including marking them up, numbering, inserting the title,
  // and reindenting.
  // Examples are any pre element with class "example" or "illegal-example".
  // When an example is found, it is reported using the "example" event. This can
  // be used by a containing shell to extract all examples.


  const name$o = "core/examples";

  const localizationStrings$9 = {
    en: {
      example: "Example",
    },
    nl: {
      example: "Voorbeeld",
    },
    es: {
      example: "Ejemplo",
    },
    ko: {
      example: "ìì",
    },
    ja: {
      example: "ä¾",
    },
    de: {
      example: "Beispiel",
    },
    zh: {
      example: "ä¾",
    },
    cs: {
      example: "PÅÃ­klad",
    },
  };

  const l10n$9 = getIntlData(localizationStrings$9);

  /**
   * @typedef {object} Report
   * @property {number} number
   * @property {boolean} illegal
   * @property {string} [title]
   * @property {string} [content]
   *
   * @param {HTMLElement} elem
   * @param {number} num
   * @param {Report} report
   */
  function makeTitle(elem, num, report) {
    report.title = elem.title;
    if (report.title) elem.removeAttribute("title");
    const number = num > 0 ? ` ${num}` : "";
    const title = report.title
      ? html`<span class="example-title">: ${report.title}</span>`
      : "";
    return html`<div class="marker">
    <a class="self-link">${l10n$9.example}<bdi>${number}</bdi></a
    >${title}
  </div>`;
  }

  function run$o() {
    /** @type {NodeListOf<HTMLElement>} */
    const examples = document.querySelectorAll(
      "pre.example, pre.illegal-example, aside.example"
    );
    if (!examples.length) return;

    document.head.insertBefore(
      html`<style>
      ${css$5}
    </style>`,
      document.querySelector("link")
    );

    let number = 0;
    examples.forEach(example => {
      example.classList.contains("illegal-example");
      /** @type {Report} */
      const report = {
        };
      const { title } = example;
      if (example.localName === "aside") {
        ++number;
        const div = makeTitle(example, number, report);
        example.prepend(div);
        const id = addId(example, "example", title || String(number));
        const selfLink = div.querySelector("a.self-link");
        selfLink.href = `#${id}`;
      } else {
        const inAside = !!example.closest("aside");
        if (!inAside) ++number;

        report.content = example.innerHTML;

        // wrap
        example.classList.remove("example", "illegal-example");
        // relocate the id to the div
        const id = example.id ? example.id : null;
        if (id) example.removeAttribute("id");
        const exampleTitle = makeTitle(example, inAside ? 0 : number, report);
        const div = html`<div class="example" id="${id}">
        ${exampleTitle} ${example.cloneNode(true)}
      </div>`;
        addId(div, "example", title || String(number));
        const selfLink = div.querySelector("a.self-link");
        selfLink.href = `#${div.id}`;
        example.replaceWith(div);
      }
    });
  }

  var examples = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$o,
    run: run$o
  });

  /* --- ISSUES/NOTES --- */
  const css$2 = String.raw;

  // Prettier ignore only to keep code indented from level 0.
  // prettier-ignore
  var css$3 = css$2`
.issue-label {
  text-transform: initial;
}

.warning > p:first-child {
  margin-top: 0;
}
.warning {
  padding: 0.5em;
  border-left-width: 0.5em;
  border-left-style: solid;
}
span.warning {
  padding: 0.1em 0.5em 0.15em;
}

.issue.closed span.issue-number {
  text-decoration: line-through;
}

.issue.closed span.issue-number::after {
  content: " (Closed)";
  font-size: smaller;
}

.warning {
  border-color: #f11;
  border-color: var(--warning-border, #f11);
  border-width: 0.2em;
  border-style: solid;
  background: #fbe9e9;
  background: var(--warning-bg, #fbe9e9);
  color: black;
  color: var(--text, black);
}

.warning-title:before {
  content: "â "; /*U+26A0 WARNING SIGN*/
  font-size: 1.3em;
  float: left;
  padding-right: 0.3em;
  margin-top: -0.3em;
}

li.task-list-item {
  list-style: none;
}

input.task-list-item-checkbox {
  margin: 0 0.35em 0.25em -1.6em;
  vertical-align: middle;
}

.issue a.respec-gh-label {
  padding: 5px;
  margin: 0 2px 0 2px;
  font-size: 10px;
  text-transform: none;
  text-decoration: none;
  font-weight: bold;
  border-radius: 4px;
  position: relative;
  bottom: 2px;
  border: none;
  display: inline-block;
}
`;

  // @ts-check
  // Module core/issues-notes
  // Manages issues and notes, including marking them up, numbering, inserting the title,
  // and injecting the style sheet.
  // These are elements with classes "issue" or "note".
  // When an issue or note is found, it is reported using the "issue" or "note" event. This can
  // be used by a containing shell to extract all of these.
  // Issues are automatically numbered by default, but you can assign them specific numbers (or,
  // despite the name, any arbitrary identifier) using the data-number attribute. Note that as
  // soon as you use one data-number on any issue all the other issues stop being automatically
  // numbered to avoid involuntary clashes.
  // If the configuration has issueBase set to a non-empty string, and issues are
  // manually numbered, a link to the issue is created using issueBase and the issue number
  const name$n = "core/issues-notes";

  const localizationStrings$8 = {
    en: {
      editors_note: "Editor's note",
      feature_at_risk: "(Feature at Risk) Issue",
      issue: "Issue",
      issue_summary: "Issue summary",
      no_issues_in_spec: "There are no issues listed in this specification.",
      note: "Note",
      warning: "Warning",
    },
    ja: {
      note: "æ³¨",
      editors_note: "ç·¨èæ³¨",
      feature_at_risk: "(å¤æ´ã®å¯è½æ§ã®ããæ©è½) Issue",
      issue: "Issue",
      issue_summary: "Issue ã®è¦ç´",
      no_issues_in_spec: "ãã®ä»æ§ã«ã¯æªè§£æ±ºã® issues ã¯å«ã¾ãã¦ãã¾ããï¼",
      warning: "è­¦å",
    },
    nl: {
      editors_note: "Redactionele noot",
      issue_summary: "Lijst met issues",
      no_issues_in_spec: "Er zijn geen problemen vermeld in deze specificatie.",
      note: "Noot",
      warning: "Waarschuwing",
    },
    es: {
      editors_note: "Nota de editor",
      issue: "CuestiÃ³n",
      issue_summary: "Resumen de la cuestiÃ³n",
      note: "Nota",
      no_issues_in_spec: "No hay problemas enumerados en esta especificaciÃ³n.",
      warning: "Aviso",
    },
    de: {
      editors_note: "Redaktioneller Hinweis",
      issue: "Frage",
      issue_summary: "Offene Fragen",
      no_issues_in_spec: "Diese Spezifikation enthÃ¤lt keine offenen Fragen.",
      note: "Hinweis",
      warning: "Warnung",
    },
    zh: {
      editors_note: "ç¼èæ³¨",
      feature_at_risk: "ï¼æå¯è½åå¨çç¹æ§ï¼Issue",
      issue: "Issue",
      issue_summary: "Issue æ»ç»",
      no_issues_in_spec: "æ¬è§èä¸­æªååºä»»ä½ issueã",
      note: "æ³¨",
      warning: "è­¦å",
    },
    cs: {
      editors_note: "PoznÃ¡mka editora",
      feature_at_risk: "(Funkce v ohroÅ¾enÃ­) ProblÃ©m",
      issue: "ProblÃ©m",
      issue_summary: "Souhrn problÃ©mÅ¯",
      no_issues_in_spec: "V tÃ©to specifikaci nejsou uvedeny Å¾Ã¡dnÃ© problÃ©my.",
      note: "PoznÃ¡mka",
      warning: "VarovÃ¡nÃ­",
    },
  };

  const l10n$8 = getIntlData(localizationStrings$8);

  /**
   * @typedef {object} Report
   * @property {string} type
   * @property {boolean} inline
   * @property {number} number
   * @property {string} title

   * @typedef {object} GitHubLabel
   * @property {string} color
   * @property {string} name
   *
   * @typedef {object} GitHubIssue
   * @property {string} title
   * @property {string} state
   * @property {string} bodyHTML
   * @property {GitHubLabel[]} labels

   * @param {HTMLElement[]} ins
   * @param {Map<string, GitHubIssue>} ghIssues
   * @param {*} conf
   */
  function handleIssues(ins, ghIssues, conf) {
    const getIssueNumber = createIssueNumberGetter();
    const issueList = document.createElement("ul");
    ins.forEach(inno => {
      const { type, displayType, isFeatureAtRisk } = getIssueType(inno);
      const isIssue = type === "issue";
      const isInline = inno.localName === "span";
      const { number: dataNum } = inno.dataset;
      const report = {
        title: inno.title,
        number: getIssueNumber(inno),
      };
      // wrap
      if (!isInline) {
        const cssClass = isFeatureAtRisk ? `${type} atrisk` : type;
        const ariaRole = type === "note" ? "note" : null;
        const div = html`<div class="${cssClass}" role="${ariaRole}"></div>`;
        const title = document.createElement("span");
        const className = `${type}-title marker`;
        // prettier-ignore
        const titleParent = html`<div role="heading" class="${className}">${title}</div>`;
        addId(titleParent, "h", type);
        let text = displayType;
        if (inno.id) {
          div.id = inno.id;
          inno.removeAttribute("id");
        } else {
          addId(
            div,
            "issue-container",
            report.number ? `number-${report.number}` : ""
          );
        }
        /** @type {GitHubIssue} */
        let ghIssue;
        if (isIssue) {
          if (report.number !== undefined) {
            text += ` ${report.number}`;
          }
          if (inno.dataset.hasOwnProperty("number")) {
            const link = linkToIssueTracker(dataNum, conf, { isFeatureAtRisk });
            if (link) {
              title.before(link);
              link.append(title);
            }
            title.classList.add("issue-number");
            ghIssue = ghIssues.get(dataNum);
            if (!ghIssue) {
              const msg = `Failed to fetch issue number ${dataNum}.`;
              showWarning(msg, name$n);
            }
            if (ghIssue && !report.title) {
              report.title = ghIssue.title;
            }
          }
          issueList.append(createIssueSummaryEntry(l10n$8.issue, report, div.id));
        }
        title.textContent = text;
        if (report.title) {
          inno.removeAttribute("title");
          const { repoURL = "" } = conf.github || {};
          const labels = ghIssue ? ghIssue.labels : [];
          if (ghIssue && ghIssue.state === "CLOSED") {
            div.classList.add("closed");
          }
          titleParent.append(createLabelsGroup(labels, report.title, repoURL));
        }
        /** @type {HTMLElement | DocumentFragment} */
        let body = inno;
        inno.replaceWith(div);
        body.classList.remove(type);
        body.removeAttribute("data-number");
        if (ghIssue && !body.innerHTML.trim()) {
          body = document
            .createRange()
            .createContextualFragment(ghIssue.bodyHTML);
        }
        div.append(titleParent, body);
        const level = parents(titleParent, "section").length + 2;
        titleParent.setAttribute("aria-level", level);
      }
    });
    makeIssueSectionSummary(issueList);
  }

  function createIssueNumberGetter() {
    if (document.querySelector(".issue[data-number]")) {
      return element => {
        if (element.dataset.number) {
          return Number(element.dataset.number);
        }
      };
    }

    let issueNumber = 0;
    return element => {
      if (element.classList.contains("issue") && element.localName !== "span") {
        return ++issueNumber;
      }
    };
  }

  /**
   * @typedef {object} IssueType
   * @property {string} type
   * @property {string} displayType
   * @property {boolean} isFeatureAtRisk
   *
   * @param {HTMLElement} inno
   * @return {IssueType}
   */
  function getIssueType(inno) {
    const isIssue = inno.classList.contains("issue");
    const isWarning = inno.classList.contains("warning");
    const isEdNote = inno.classList.contains("ednote");
    const isFeatureAtRisk = inno.classList.contains("atrisk");
    const type = isIssue
      ? "issue"
      : isWarning
        ? "warning"
        : isEdNote
          ? "ednote"
          : "note";
    const displayType = isIssue
      ? isFeatureAtRisk
        ? l10n$8.feature_at_risk
        : l10n$8.issue
      : isWarning
        ? l10n$8.warning
        : isEdNote
          ? l10n$8.editors_note
          : l10n$8.note;
    return { type, displayType, isFeatureAtRisk };
  }

  /**
   * @param {string} dataNum
   * @param {*} conf
   */
  function linkToIssueTracker(dataNum, conf, { isFeatureAtRisk = false } = {}) {
    // Set issueBase to cause issue to be linked to the external issue tracker
    if (!isFeatureAtRisk && conf.issueBase) {
      return html`<a href="${conf.issueBase + dataNum}" />`;
    } else if (isFeatureAtRisk && conf.atRiskBase) {
      return html`<a href="${conf.atRiskBase + dataNum}" />`;
    }
  }

  /**
   * @param {string} l10nIssue
   * @param {Report} report
   */
  function createIssueSummaryEntry(l10nIssue, report, id) {
    const issueNumberText = `${l10nIssue}${
    report.number ? ` ${report.number}` : ""
  }`;
    const title = report.title
      ? html`<span style="text-transform: none">: ${report.title}</span>`
      : "";
    return html`<li><a href="${`#${id}`}">${issueNumberText}</a>${title}</li>`;
  }

  /**
   *
   * @param {HTMLUListElement} issueList
   */
  function makeIssueSectionSummary(issueList) {
    const issueSummaryElement = document.getElementById("issue-summary");
    if (!issueSummaryElement) return;
    const heading = issueSummaryElement.querySelector("h2, h3, h4, h5, h6");

    issueList.hasChildNodes()
      ? issueSummaryElement.append(issueList)
      : issueSummaryElement.append(html`<p>${l10n$8.no_issues_in_spec}</p>`);
    if (
      !heading ||
      (heading && heading !== issueSummaryElement.firstElementChild)
    ) {
      issueSummaryElement.insertAdjacentHTML(
        "afterbegin",
        `<h1>${l10n$8.issue_summary}</h1>`
      );
    }
  }

  /**
   * @param {GitHubLabel[]} labels
   * @param {string} title
   * @param {string} repoURL
   */
  function createLabelsGroup(labels, title, repoURL) {
    const labelsGroup = labels.map(label => createLabel(label, repoURL));
    if (labelsGroup.length) {
      labelsGroup.unshift(document.createTextNode(" "));
    }
    return html`<span class="issue-label">: ${title}${labelsGroup}</span>`;
  }

  /**
   * Based on https://stackoverflow.com/a/3943023
   * See https://www.w3.org/WAI/WCAG21/Techniques/general/G18.html#tests
   * @param {string} bg background color as a hex value without '#'
   */
  function textColorFromBgColor(bg) {
    const [r, g, b] = [bg.slice(0, 2), bg.slice(2, 4), bg.slice(4, 6)];
    const [R, G, B] = [r, g, b]
      .map(c => parseInt(c, 16) / 255)
      .map(c => (c <= 0.04045 ? c / 12.92 : ((c + 0.055) / 1.055) ** 2.4));
    const L = 0.2126 * R + 0.7152 * G + 0.0722 * B;
    return L > 0.179 ? "#000" : "#fff";
  }

  /**
   * @param {GitHubLabel} label
   * @param {string} repoURL
   */
  function createLabel(label, repoURL) {
    const { color: bgColor, name } = label;
    const issuesURL = new URL("./issues/", repoURL);
    issuesURL.searchParams.set("q", `is:issue is:open label:"${label.name}"`);
    const color = textColorFromBgColor(bgColor);
    const style = `background-color: #${bgColor}; color: ${color}`;
    const ariaLabel = `GitHub label: ${name}`;
    return html` <a
    class="respec-gh-label"
    style="${style}"
    href="${issuesURL.href}"
    aria-label="${ariaLabel}"
    >${name}</a
  >`;
  }

  /**
   * @returns {Promise<Map<string, GitHubIssue>>}
   */
  async function fetchAndStoreGithubIssues(github) {
    if (!github || !github.apiBase) {
      return new Map();
    }

    /** @type {NodeListOf<HTMLElement>} */
    const specIssues = document.querySelectorAll(".issue[data-number]");
    const issueNumbers = [...specIssues]
      .map(elem => Number.parseInt(elem.dataset.number, 10))
      .filter(issueNumber => issueNumber);

    if (!issueNumbers.length) {
      return new Map();
    }

    const url = new URL("issues", `${github.apiBase}/${github.fullName}/`);
    url.searchParams.set("issues", issueNumbers.join(","));

    const response = await fetch(url.href);
    if (!response.ok) {
      const msg = `Error fetching issues from GitHub. (HTTP Status ${response.status}).`;
      showError(msg, name$n);
      return new Map();
    }

    /** @type {{ [issueNumber: string]: GitHubIssue }} */
    const issues = await response.json();
    return new Map(Object.entries(issues));
  }

  async function run$n(conf) {
    const query = ".issue, .note, .warning, .ednote";
    /** @type {NodeListOf<HTMLElement>} */
    const allEls = document.querySelectorAll(query);

    const issuesAndNotes = Array.from(allEls).filter(itm => {
      // Removes any elements that are not HTML Elements (e.g., SVG nodes)
      return itm instanceof HTMLElement;
    });

    if (!issuesAndNotes.length) {
      return; // nothing to do.
    }
    const ghIssues = await fetchAndStoreGithubIssues(conf.github);
    const { head: headElem } = document;
    headElem.insertBefore(
      html`<style>
      ${css$3}
    </style>`,
      headElem.querySelector("link")
    );
    handleIssues(issuesAndNotes, ghIssues, conf);
    const ednotes = document.querySelectorAll(".ednote");
    ednotes.forEach(ednote => {
      ednote.classList.remove("ednote");
      ednote.classList.add("note");
    });
  }

  var issuesNotes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$n,
    run: run$n
  });

  var css$1 = `div.impnote-title {
    padding-right:  1em;
    min-width: 7.5em;
    color: #0060A9;
}
div.impnote-title span {
    text-transform: uppercase;
}
div.impnote {
    margin-top: 1em;
    margin-bottom: 1em;
}
.impnote > p:first-child { margin-top: 0 }
.impnote {
    padding: .5em;
    border-left-width: .5em;
    border-left-style: solid;
}
div.impnote {
    padding: 1em 1.2em 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
}
span.impnote { padding: .1em .5em .15em; }

.impnote {
  border-color: #0060A9;
  background: #E5F4FF;
}`;

  // Module core/impnote
  // Manages PCISIG Implementation Notes, including marking them up, numbering, inserting the title,
  // and injecting the style sheet.
  // These are elements with class "impnote".

  //import { fetch as ghFetch, fetchIndex } from "core/github";
  const name$m = "pcisig/impnote";

  function run$m(conf, doc, cb) {
    function handleIssues($ins) {
      $(doc).find("head link").first().before($("<style/>").text(css$1));
      $ins.each(function (i, inno) {
        var $inno = $(inno);
          $inno.hasClass("impnote");
          var isFeatureAtRisk = $inno.hasClass("atrisk"),
          isInline = $inno.css("display") !== "block",
          report = {
            inline: isInline,
            content: $inno.html(),
          };
        report.type = "impnote";
        var impnoteid = $inno.makeID("impnote", $inno.attr("title"));
        // wrap
        if (!isInline) {
          var $div = $(
            "<div class='" +
            report.type +
            (isFeatureAtRisk ? " atrisk" : "") +
            "' id='" + impnoteid +
            "'></div>"
            ),
            $tit = $(
              "<div class='" + report.type + "-title'><span></span></div>"
            ),
            text = conf.l10n.impnote;
          report.title = $inno.attr("title");
          $tit.find("span").text(text);
          if (report.title) {
            $tit.append(
              $(
                "<span style='text-transform: none'>: " + report.title + "</span>"
              )
            );
            $inno.removeAttr("title");
          }
          $tit.addClass("marker");
          $div.append($tit);
          $inno.removeAttr("id");
          $inno.replaceWith($div);
          var body = $inno.removeClass(report.type);
          $div.append(body);
        }
        pub(report.type, report);
      });
    }

    var $ins = $(".impnote");
    if ($ins.length) {
      handleIssues($ins);
      cb();
    } else {
      cb();
    }
  }

  var impnote = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$m,
    run: run$m
  });

  // @ts-check
  // Module core/requirements
  // This module does two things:
  //
  // 1.  It finds and marks all requirements. These are elements with class "req".
  //     When a requirement is found, it is reported using the "req" event. This
  //     can be used by a containing shell to extract them.
  //     Requirements are automatically numbered.
  //
  // 2.  It allows referencing requirements by their ID simply using an empty <a>
  //     element with its href pointing to the requirement it should be referencing
  //     and a class of "reqRef".

  const name$l = "core/requirements";

  function run$l() {
    document.querySelectorAll(".req").forEach((req, i) => {
      const frag = `#${req.getAttribute("id")}`;
      const el = html`<a href="${frag}">Req. ${i + 1}</a>`;
      req.prepend(el, ": ");
    });

    document.querySelectorAll("a.reqRef[href]").forEach(ref => {
      const href = ref.getAttribute("href");
      const id = href.substring(1); // href looks like `#id`
      const req = document.getElementById(id);
      let txt;
      if (req) {
        txt = req.querySelector("a:first-child").textContent;
      } else {
        txt = `Req. not found '${id}'`;
        const msg = `Requirement not found in element \`a.reqRef\`: ${id}`;
        showError(msg, name$l);
        console.warn(msg, ref);
      }
      ref.textContent = txt;
    });
  }

  var requirements = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$l,
    run: run$l
  });

  // @ts-check
  // Module core/best-practices
  // Handles the marking up of best practices, and can generate a summary of all of them.
  // The summary is generated if there is a section in the document with ID bp-summary.
  // Best practices are marked up with span.practicelab.

  const name$k = "core/best-practices";

  const localizationStrings$7 = {
    en: {
      best_practice: "Best Practice ",
    },
    ja: {
      best_practice: "æè¯å®æ½ä¾ ",
    },
    de: {
      best_practice: "Musterbeispiel ",
    },
    zh: {
      best_practice: "æä½³å®è·µ ",
    },
  };
  const l10n$7 = getIntlData(localizationStrings$7);
  const lang = lang$1 in localizationStrings$7 ? lang$1 : "en";

  function run$k() {
    /** @type {NodeListOf<HTMLElement>} */
    const bps = document.querySelectorAll(".practicelab");
    const bpSummary = document.getElementById("bp-summary");
    const summaryItems = bpSummary ? document.createElement("ul") : null;
    [...bps].forEach((bp, num) => {
      const id = addId(bp, "bp");
      const localizedBpName = html`<a class="marker self-link" href="${`#${id}`}"
      ><bdi lang="${lang}">${l10n$7.best_practice}${num + 1}</bdi></a
    >`;

      // Make the summary items, if we have a summary
      if (summaryItems) {
        const li = html`<li>${localizedBpName}: ${makeSafeCopy(bp)}</li>`;
        summaryItems.appendChild(li);
      }

      const container = bp.closest("div");
      if (!container) {
        // This is just an inline best practice...
        bp.classList.add("advisement");
        return;
      }

      // Make the advisement box
      container.classList.add("advisement");
      const title = html`${localizedBpName.cloneNode(true)}: ${bp}`;
      container.prepend(...title.childNodes);
    });
    if (bps.length) {
      if (bpSummary) {
        bpSummary.appendChild(html`<h1>Best Practices Summary</h1>`);
        bpSummary.appendChild(summaryItems);
      }
    } else if (bpSummary) {
      const msg = `Using best practices summary (#bp-summary) but no best practices found.`;
      showWarning(msg, name$k);
      bpSummary.remove();
    }
  }

  var bestPractices = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$k,
    run: run$k
  });

  /*!
   * jQuery JavaScript Library v3.7.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-deprecated/ajax-event-alias,-effects,-effects/animatedSelector,-effects/Tween
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   */
  ( function( global, factory ) {

  	if ( typeof module === "object" && typeof module.exports === "object" ) {

  		// For CommonJS and CommonJS-like environments where a proper `window`
  		// is present, execute the factory and get jQuery.
  		// For environments that do not have a `window` with a `document`
  		// (such as Node.js), expose a factory as module.exports.
  		// This accentuates the need for the creation of a real `window`.
  		// e.g. var jQuery = require("jquery")(window);
  		// See ticket trac-14549 for more info.
  		module.exports = global.document ?
  			factory( global, true ) :
  			function( w ) {
  				if ( !w.document ) {
  					throw new Error( "jQuery requires a window with a document" );
  				}
  				return factory( w );
  			};
  	} else {
  		factory( global );
  	}

  // Pass this if window is not defined yet
  } )( typeof window !== "undefined" ? window : undefined, function( window, noGlobal ) {

  var arr = [];

  var getProto = Object.getPrototypeOf;

  var slice = arr.slice;

  var flat = arr.flat ? function( array ) {
  	return arr.flat.call( array );
  } : function( array ) {
  	return arr.concat.apply( [], array );
  };


  var push = arr.push;

  var indexOf = arr.indexOf;

  var class2type = {};

  var toString = class2type.toString;

  var hasOwn = class2type.hasOwnProperty;

  var fnToString = hasOwn.toString;

  var ObjectFunctionString = fnToString.call( Object );

  var support = {};

  var isFunction = function isFunction( obj ) {

  		// Support: Chrome <=57, Firefox <=52
  		// In some browsers, typeof returns "function" for HTML <object> elements
  		// (i.e., `typeof document.createElement( "object" ) === "function"`).
  		// We don't want to classify *any* DOM node as a function.
  		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
  		// Plus for old WebKit, typeof returns "function" for HTML collections
  		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
  		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
  			typeof obj.item !== "function";
  	};


  var isWindow = function isWindow( obj ) {
  		return obj != null && obj === obj.window;
  	};


  var document = window.document;



  	var preservedScriptAttributes = {
  		type: true,
  		src: true,
  		nonce: true,
  		noModule: true
  	};

  	function DOMEval( code, node, doc ) {
  		doc = doc || document;

  		var i, val,
  			script = doc.createElement( "script" );

  		script.text = code;
  		if ( node ) {
  			for ( i in preservedScriptAttributes ) {

  				// Support: Firefox 64+, Edge 18+
  				// Some browsers don't support the "nonce" property on scripts.
  				// On the other hand, just using `getAttribute` is not enough as
  				// the `nonce` attribute is reset to an empty string whenever it
  				// becomes browsing-context connected.
  				// See https://github.com/whatwg/html/issues/2369
  				// See https://html.spec.whatwg.org/#nonce-attributes
  				// The `node.getAttribute` check was added for the sake of
  				// `jQuery.globalEval` so that it can fake a nonce-containing node
  				// via an object.
  				val = node[ i ] || node.getAttribute && node.getAttribute( i );
  				if ( val ) {
  					script.setAttribute( i, val );
  				}
  			}
  		}
  		doc.head.appendChild( script ).parentNode.removeChild( script );
  	}


  function toType( obj ) {
  	if ( obj == null ) {
  		return obj + "";
  	}

  	// Support: Android <=2.3 only (functionish RegExp)
  	return typeof obj === "object" || typeof obj === "function" ?
  		class2type[ toString.call( obj ) ] || "object" :
  		typeof obj;
  }
  /* global Symbol */
  // Defining this global in .eslintrc.json would create a danger of using the global
  // unguarded in another place, it seems safer to define global only for this module



  var version = "3.7.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-deprecated/ajax-event-alias,-effects,-effects/animatedSelector,-effects/Tween",

  	rhtmlSuffix = /HTML$/i,

  	// Define a local copy of jQuery
  	jQuery = function( selector, context ) {

  		// The jQuery object is actually just the init constructor 'enhanced'
  		// Need init if jQuery is called (just allow error to be thrown if not included)
  		return new jQuery.fn.init( selector, context );
  	};

  jQuery.fn = jQuery.prototype = {

  	// The current version of jQuery being used
  	jquery: version,

  	constructor: jQuery,

  	// The default length of a jQuery object is 0
  	length: 0,

  	toArray: function() {
  		return slice.call( this );
  	},

  	// Get the Nth element in the matched element set OR
  	// Get the whole matched element set as a clean array
  	get: function( num ) {

  		// Return all the elements in a clean array
  		if ( num == null ) {
  			return slice.call( this );
  		}

  		// Return just the one element from the set
  		return num < 0 ? this[ num + this.length ] : this[ num ];
  	},

  	// Take an array of elements and push it onto the stack
  	// (returning the new matched element set)
  	pushStack: function( elems ) {

  		// Build a new jQuery matched element set
  		var ret = jQuery.merge( this.constructor(), elems );

  		// Add the old object onto the stack (as a reference)
  		ret.prevObject = this;

  		// Return the newly-formed element set
  		return ret;
  	},

  	// Execute a callback for every element in the matched set.
  	each: function( callback ) {
  		return jQuery.each( this, callback );
  	},

  	map: function( callback ) {
  		return this.pushStack( jQuery.map( this, function( elem, i ) {
  			return callback.call( elem, i, elem );
  		} ) );
  	},

  	slice: function() {
  		return this.pushStack( slice.apply( this, arguments ) );
  	},

  	first: function() {
  		return this.eq( 0 );
  	},

  	last: function() {
  		return this.eq( -1 );
  	},

  	even: function() {
  		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
  			return ( i + 1 ) % 2;
  		} ) );
  	},

  	odd: function() {
  		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
  			return i % 2;
  		} ) );
  	},

  	eq: function( i ) {
  		var len = this.length,
  			j = +i + ( i < 0 ? len : 0 );
  		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
  	},

  	end: function() {
  		return this.prevObject || this.constructor();
  	},

  	// For internal use only.
  	// Behaves like an Array's method, not like a jQuery method.
  	push: push,
  	sort: arr.sort,
  	splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function() {
  	var options, name, src, copy, copyIsArray, clone,
  		target = arguments[ 0 ] || {},
  		i = 1,
  		length = arguments.length,
  		deep = false;

  	// Handle a deep copy situation
  	if ( typeof target === "boolean" ) {
  		deep = target;

  		// Skip the boolean and the target
  		target = arguments[ i ] || {};
  		i++;
  	}

  	// Handle case when target is a string or something (possible in deep copy)
  	if ( typeof target !== "object" && !isFunction( target ) ) {
  		target = {};
  	}

  	// Extend jQuery itself if only one argument is passed
  	if ( i === length ) {
  		target = this;
  		i--;
  	}

  	for ( ; i < length; i++ ) {

  		// Only deal with non-null/undefined values
  		if ( ( options = arguments[ i ] ) != null ) {

  			// Extend the base object
  			for ( name in options ) {
  				copy = options[ name ];

  				// Prevent Object.prototype pollution
  				// Prevent never-ending loop
  				if ( name === "__proto__" || target === copy ) {
  					continue;
  				}

  				// Recurse if we're merging plain objects or arrays
  				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
  					( copyIsArray = Array.isArray( copy ) ) ) ) {
  					src = target[ name ];

  					// Ensure proper type for the source value
  					if ( copyIsArray && !Array.isArray( src ) ) {
  						clone = [];
  					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
  						clone = {};
  					} else {
  						clone = src;
  					}
  					copyIsArray = false;

  					// Never move original objects, clone them
  					target[ name ] = jQuery.extend( deep, clone, copy );

  				// Don't bring in undefined values
  				} else if ( copy !== undefined ) {
  					target[ name ] = copy;
  				}
  			}
  		}
  	}

  	// Return the modified object
  	return target;
  };

  jQuery.extend( {

  	// Unique for each copy of jQuery on the page
  	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

  	// Assume jQuery is ready without the ready module
  	isReady: true,

  	error: function( msg ) {
  		throw new Error( msg );
  	},

  	noop: function() {},

  	isPlainObject: function( obj ) {
  		var proto, Ctor;

  		// Detect obvious negatives
  		// Use toString instead of jQuery.type to catch host objects
  		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
  			return false;
  		}

  		proto = getProto( obj );

  		// Objects with no prototype (e.g., `Object.create( null )`) are plain
  		if ( !proto ) {
  			return true;
  		}

  		// Objects with prototype are plain iff they were constructed by a global Object function
  		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
  		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
  	},

  	isEmptyObject: function( obj ) {
  		var name;

  		for ( name in obj ) {
  			return false;
  		}
  		return true;
  	},

  	// Evaluates a script in a provided context; falls back to the global one
  	// if not specified.
  	globalEval: function( code, options, doc ) {
  		DOMEval( code, { nonce: options && options.nonce }, doc );
  	},

  	each: function( obj, callback ) {
  		var length, i = 0;

  		if ( isArrayLike( obj ) ) {
  			length = obj.length;
  			for ( ; i < length; i++ ) {
  				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  					break;
  				}
  			}
  		} else {
  			for ( i in obj ) {
  				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  					break;
  				}
  			}
  		}

  		return obj;
  	},


  	// Retrieve the text value of an array of DOM nodes
  	text: function( elem ) {
  		var node,
  			ret = "",
  			i = 0,
  			nodeType = elem.nodeType;

  		if ( !nodeType ) {

  			// If no nodeType, this is expected to be an array
  			while ( ( node = elem[ i++ ] ) ) {

  				// Do not traverse comment nodes
  				ret += jQuery.text( node );
  			}
  		}
  		if ( nodeType === 1 || nodeType === 11 ) {
  			return elem.textContent;
  		}
  		if ( nodeType === 9 ) {
  			return elem.documentElement.textContent;
  		}
  		if ( nodeType === 3 || nodeType === 4 ) {
  			return elem.nodeValue;
  		}

  		// Do not include comment or processing instruction nodes

  		return ret;
  	},

  	// results is for internal usage only
  	makeArray: function( arr, results ) {
  		var ret = results || [];

  		if ( arr != null ) {
  			if ( isArrayLike( Object( arr ) ) ) {
  				jQuery.merge( ret,
  					typeof arr === "string" ?
  						[ arr ] : arr
  				);
  			} else {
  				push.call( ret, arr );
  			}
  		}

  		return ret;
  	},

  	inArray: function( elem, arr, i ) {
  		return arr == null ? -1 : indexOf.call( arr, elem, i );
  	},

  	isXMLDoc: function( elem ) {
  		var namespace = elem && elem.namespaceURI,
  			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

  		// Assume HTML when documentElement doesn't yet exist, such as inside
  		// document fragments.
  		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
  	},

  	// Support: Android <=4.0 only, PhantomJS 1 only
  	// push.apply(_, arraylike) throws on ancient WebKit
  	merge: function( first, second ) {
  		var len = +second.length,
  			j = 0,
  			i = first.length;

  		for ( ; j < len; j++ ) {
  			first[ i++ ] = second[ j ];
  		}

  		first.length = i;

  		return first;
  	},

  	grep: function( elems, callback, invert ) {
  		var callbackInverse,
  			matches = [],
  			i = 0,
  			length = elems.length,
  			callbackExpect = !invert;

  		// Go through the array, only saving the items
  		// that pass the validator function
  		for ( ; i < length; i++ ) {
  			callbackInverse = !callback( elems[ i ], i );
  			if ( callbackInverse !== callbackExpect ) {
  				matches.push( elems[ i ] );
  			}
  		}

  		return matches;
  	},

  	// arg is for internal usage only
  	map: function( elems, callback, arg ) {
  		var length, value,
  			i = 0,
  			ret = [];

  		// Go through the array, translating each of the items to their new values
  		if ( isArrayLike( elems ) ) {
  			length = elems.length;
  			for ( ; i < length; i++ ) {
  				value = callback( elems[ i ], i, arg );

  				if ( value != null ) {
  					ret.push( value );
  				}
  			}

  		// Go through every key on the object,
  		} else {
  			for ( i in elems ) {
  				value = callback( elems[ i ], i, arg );

  				if ( value != null ) {
  					ret.push( value );
  				}
  			}
  		}

  		// Flatten any nested arrays
  		return flat( ret );
  	},

  	// A global GUID counter for objects
  	guid: 1,

  	// jQuery.support is not used in Core but other projects attach their
  	// properties to it so it needs to exist.
  	support: support
  } );

  if ( typeof Symbol === "function" ) {
  	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
  }

  // Populate the class2type map
  jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
  	function( _i, name ) {
  		class2type[ "[object " + name + "]" ] = name.toLowerCase();
  	} );

  function isArrayLike( obj ) {

  	// Support: real iOS 8.2 only (not reproducible in simulator)
  	// `in` check used to prevent JIT error (gh-2145)
  	// hasOwn isn't used here due to false negatives
  	// regarding Nodelist length in IE
  	var length = !!obj && "length" in obj && obj.length,
  		type = toType( obj );

  	if ( isFunction( obj ) || isWindow( obj ) ) {
  		return false;
  	}

  	return type === "array" || length === 0 ||
  		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
  }


  function nodeName( elem, name ) {

  	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

  }
  var pop = arr.pop;


  var sort = arr.sort;


  var splice = arr.splice;


  var whitespace = "[\\x20\\t\\r\\n\\f]";


  var rtrimCSS = new RegExp(
  	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
  	"g"
  );




  // Note: an element does not contain itself
  jQuery.contains = function( a, b ) {
  	var bup = b && b.parentNode;

  	return a === bup || !!( bup && bup.nodeType === 1 && (

  		// Support: IE 9 - 11+
  		// IE doesn't have `contains` on SVG.
  		a.contains ?
  			a.contains( bup ) :
  			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
  	) );
  };




  // CSS string/identifier serialization
  // https://drafts.csswg.org/cssom/#common-serializing-idioms
  var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

  function fcssescape( ch, asCodePoint ) {
  	if ( asCodePoint ) {

  		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
  		if ( ch === "\0" ) {
  			return "\uFFFD";
  		}

  		// Control characters and (dependent upon position) numbers get escaped as code points
  		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
  	}

  	// Other potentially-special ASCII characters get backslash-escaped
  	return "\\" + ch;
  }

  jQuery.escapeSelector = function( sel ) {
  	return ( sel + "" ).replace( rcssescape, fcssescape );
  };




  var preferredDoc = document,
  	pushNative = push;

  ( function() {

  var i,
  	Expr,
  	outermostContext,
  	sortInput,
  	hasDuplicate,
  	push = pushNative,

  	// Local document vars
  	document,
  	documentElement,
  	documentIsHTML,
  	rbuggyQSA,
  	matches,

  	// Instance-specific data
  	expando = jQuery.expando,
  	dirruns = 0,
  	done = 0,
  	classCache = createCache(),
  	tokenCache = createCache(),
  	compilerCache = createCache(),
  	nonnativeSelectorCache = createCache(),
  	sortOrder = function( a, b ) {
  		if ( a === b ) {
  			hasDuplicate = true;
  		}
  		return 0;
  	},

  	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
  		"loop|multiple|open|readonly|required|scoped",

  	// Regular expressions

  	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
  	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
  		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

  	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
  	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

  		// Operator (capture 2)
  		"*([*^$|!~]?=)" + whitespace +

  		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
  		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
  		whitespace + "*\\]",

  	pseudos = ":(" + identifier + ")(?:\\((" +

  		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
  		// 1. quoted (capture 3; capture 4 or capture 5)
  		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

  		// 2. simple (capture 6)
  		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

  		// 3. anything else (capture 2)
  		".*" +
  		")\\)|)",

  	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  	rwhitespace = new RegExp( whitespace + "+", "g" ),

  	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
  	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
  		whitespace + "*" ),
  	rdescend = new RegExp( whitespace + "|>" ),

  	rpseudo = new RegExp( pseudos ),
  	ridentifier = new RegExp( "^" + identifier + "$" ),

  	matchExpr = {
  		ID: new RegExp( "^#(" + identifier + ")" ),
  		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
  		TAG: new RegExp( "^(" + identifier + "|[*])" ),
  		ATTR: new RegExp( "^" + attributes ),
  		PSEUDO: new RegExp( "^" + pseudos ),
  		CHILD: new RegExp(
  			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
  				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
  				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
  		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

  		// For use in libraries implementing .is()
  		// We use this for POS matching in `select`
  		needsContext: new RegExp( "^" + whitespace +
  			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
  			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
  	},

  	rinputs = /^(?:input|select|textarea|button)$/i,
  	rheader = /^h\d$/i,

  	// Easily-parseable/retrievable ID or TAG or CLASS selectors
  	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

  	rsibling = /[+~]/,

  	// CSS escapes
  	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
  		"?|\\\\([^\\r\\n\\f])", "g" ),
  	funescape = function( escape, nonHex ) {
  		var high = "0x" + escape.slice( 1 ) - 0x10000;

  		if ( nonHex ) {

  			// Strip the backslash prefix from a non-hex escape sequence
  			return nonHex;
  		}

  		// Replace a hexadecimal escape sequence with the encoded Unicode code point
  		// Support: IE <=11+
  		// For values outside the Basic Multilingual Plane (BMP), manually construct a
  		// surrogate pair
  		return high < 0 ?
  			String.fromCharCode( high + 0x10000 ) :
  			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
  	},

  	// Used for iframes; see `setDocument`.
  	// Support: IE 9 - 11+, Edge 12 - 18+
  	// Removing the function wrapper causes a "Permission Denied"
  	// error in IE/Edge.
  	unloadHandler = function() {
  		setDocument();
  	},

  	inDisabledFieldset = addCombinator(
  		function( elem ) {
  			return elem.disabled === true && nodeName( elem, "fieldset" );
  		},
  		{ dir: "parentNode", next: "legend" }
  	);

  // Support: IE <=9 only
  // Accessing document.activeElement can throw unexpectedly
  // https://bugs.jquery.com/ticket/13393
  function safeActiveElement() {
  	try {
  		return document.activeElement;
  	} catch ( err ) { }
  }

  // Optimize for push.apply( _, NodeList )
  try {
  	push.apply(
  		( arr = slice.call( preferredDoc.childNodes ) ),
  		preferredDoc.childNodes
  	);

  	// Support: Android <=4.0
  	// Detect silently failing push.apply
  	// eslint-disable-next-line no-unused-expressions
  	arr[ preferredDoc.childNodes.length ].nodeType;
  } catch ( e ) {
  	push = {
  		apply: function( target, els ) {
  			pushNative.apply( target, slice.call( els ) );
  		},
  		call: function( target ) {
  			pushNative.apply( target, slice.call( arguments, 1 ) );
  		}
  	};
  }

  function find( selector, context, results, seed ) {
  	var m, i, elem, nid, match, groups, newSelector,
  		newContext = context && context.ownerDocument,

  		// nodeType defaults to 9, since context defaults to document
  		nodeType = context ? context.nodeType : 9;

  	results = results || [];

  	// Return early from calls with invalid selector or context
  	if ( typeof selector !== "string" || !selector ||
  		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

  		return results;
  	}

  	// Try to shortcut find operations (as opposed to filters) in HTML documents
  	if ( !seed ) {
  		setDocument( context );
  		context = context || document;

  		if ( documentIsHTML ) {

  			// If the selector is sufficiently simple, try using a "get*By*" DOM method
  			// (excepting DocumentFragment context, where the methods don't exist)
  			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

  				// ID selector
  				if ( ( m = match[ 1 ] ) ) {

  					// Document context
  					if ( nodeType === 9 ) {
  						if ( ( elem = context.getElementById( m ) ) ) {

  							// Support: IE 9 only
  							// getElementById can match elements by name instead of ID
  							if ( elem.id === m ) {
  								push.call( results, elem );
  								return results;
  							}
  						} else {
  							return results;
  						}

  					// Element context
  					} else {

  						// Support: IE 9 only
  						// getElementById can match elements by name instead of ID
  						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
  							find.contains( context, elem ) &&
  							elem.id === m ) {

  							push.call( results, elem );
  							return results;
  						}
  					}

  				// Type selector
  				} else if ( match[ 2 ] ) {
  					push.apply( results, context.getElementsByTagName( selector ) );
  					return results;

  				// Class selector
  				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
  					push.apply( results, context.getElementsByClassName( m ) );
  					return results;
  				}
  			}

  			// Take advantage of querySelectorAll
  			if ( !nonnativeSelectorCache[ selector + " " ] &&
  				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

  				newSelector = selector;
  				newContext = context;

  				// qSA considers elements outside a scoping root when evaluating child or
  				// descendant combinators, which is not what we want.
  				// In such cases, we work around the behavior by prefixing every selector in the
  				// list with an ID selector referencing the scope context.
  				// The technique has to be used as well when a leading combinator is used
  				// as such selectors are not recognized by querySelectorAll.
  				// Thanks to Andrew Dupont for this technique.
  				if ( nodeType === 1 &&
  					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

  					// Expand context for sibling selectors
  					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
  						context;

  					// We can use :scope instead of the ID hack if the browser
  					// supports it & if we're not changing the context.
  					// Support: IE 11+, Edge 17 - 18+
  					// IE/Edge sometimes throw a "Permission denied" error when
  					// strict-comparing two documents; shallow comparisons work.
  					// eslint-disable-next-line eqeqeq
  					if ( newContext != context || !support.scope ) {

  						// Capture the context ID, setting it first if necessary
  						if ( ( nid = context.getAttribute( "id" ) ) ) {
  							nid = jQuery.escapeSelector( nid );
  						} else {
  							context.setAttribute( "id", ( nid = expando ) );
  						}
  					}

  					// Prefix every selector in the list
  					groups = tokenize( selector );
  					i = groups.length;
  					while ( i-- ) {
  						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
  							toSelector( groups[ i ] );
  					}
  					newSelector = groups.join( "," );
  				}

  				try {
  					push.apply( results,
  						newContext.querySelectorAll( newSelector )
  					);
  					return results;
  				} catch ( qsaError ) {
  					nonnativeSelectorCache( selector, true );
  				} finally {
  					if ( nid === expando ) {
  						context.removeAttribute( "id" );
  					}
  				}
  			}
  		}
  	}

  	// All others
  	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
  }

  /**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
  function createCache() {
  	var keys = [];

  	function cache( key, value ) {

  		// Use (key + " ") to avoid collision with native prototype properties
  		// (see https://github.com/jquery/sizzle/issues/157)
  		if ( keys.push( key + " " ) > Expr.cacheLength ) {

  			// Only keep the most recent entries
  			delete cache[ keys.shift() ];
  		}
  		return ( cache[ key + " " ] = value );
  	}
  	return cache;
  }

  /**
   * Mark a function for special use by jQuery selector module
   * @param {Function} fn The function to mark
   */
  function markFunction( fn ) {
  	fn[ expando ] = true;
  	return fn;
  }

  /**
   * Support testing using an element
   * @param {Function} fn Passed the created element and returns a boolean result
   */
  function assert( fn ) {
  	var el = document.createElement( "fieldset" );

  	try {
  		return !!fn( el );
  	} catch ( e ) {
  		return false;
  	} finally {

  		// Remove from its parent by default
  		if ( el.parentNode ) {
  			el.parentNode.removeChild( el );
  		}

  		// release memory in IE
  		el = null;
  	}
  }

  /**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
  function createInputPseudo( type ) {
  	return function( elem ) {
  		return nodeName( elem, "input" ) && elem.type === type;
  	};
  }

  /**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
  function createButtonPseudo( type ) {
  	return function( elem ) {
  		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
  			elem.type === type;
  	};
  }

  /**
   * Returns a function to use in pseudos for :enabled/:disabled
   * @param {Boolean} disabled true for :disabled; false for :enabled
   */
  function createDisabledPseudo( disabled ) {

  	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
  	return function( elem ) {

  		// Only certain elements can match :enabled or :disabled
  		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
  		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
  		if ( "form" in elem ) {

  			// Check for inherited disabledness on relevant non-disabled elements:
  			// * listed form-associated elements in a disabled fieldset
  			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
  			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
  			// * option elements in a disabled optgroup
  			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
  			// All such elements have a "form" property.
  			if ( elem.parentNode && elem.disabled === false ) {

  				// Option elements defer to a parent optgroup if present
  				if ( "label" in elem ) {
  					if ( "label" in elem.parentNode ) {
  						return elem.parentNode.disabled === disabled;
  					} else {
  						return elem.disabled === disabled;
  					}
  				}

  				// Support: IE 6 - 11+
  				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
  				return elem.isDisabled === disabled ||

  					// Where there is no isDisabled, check manually
  					elem.isDisabled !== !disabled &&
  						inDisabledFieldset( elem ) === disabled;
  			}

  			return elem.disabled === disabled;

  		// Try to winnow out elements that can't be disabled before trusting the disabled property.
  		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
  		// even exist on them, let alone have a boolean value.
  		} else if ( "label" in elem ) {
  			return elem.disabled === disabled;
  		}

  		// Remaining elements are neither :enabled nor :disabled
  		return false;
  	};
  }

  /**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
  function createPositionalPseudo( fn ) {
  	return markFunction( function( argument ) {
  		argument = +argument;
  		return markFunction( function( seed, matches ) {
  			var j,
  				matchIndexes = fn( [], seed.length, argument ),
  				i = matchIndexes.length;

  			// Match elements found at the specified indexes
  			while ( i-- ) {
  				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
  					seed[ j ] = !( matches[ j ] = seed[ j ] );
  				}
  			}
  		} );
  	} );
  }

  /**
   * Checks a node for validity as a jQuery selector context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
  function testContext( context ) {
  	return context && typeof context.getElementsByTagName !== "undefined" && context;
  }

  /**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [node] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
  function setDocument( node ) {
  	var subWindow,
  		doc = node ? node.ownerDocument || node : preferredDoc;

  	// Return early if doc is invalid or already selected
  	// Support: IE 11+, Edge 17 - 18+
  	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  	// two documents; shallow comparisons work.
  	// eslint-disable-next-line eqeqeq
  	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
  		return document;
  	}

  	// Update global variables
  	document = doc;
  	documentElement = document.documentElement;
  	documentIsHTML = !jQuery.isXMLDoc( document );

  	// Support: iOS 7 only, IE 9 - 11+
  	// Older browsers didn't support unprefixed `matches`.
  	matches = documentElement.matches ||
  		documentElement.webkitMatchesSelector ||
  		documentElement.msMatchesSelector;

  	// Support: IE 9 - 11+, Edge 12 - 18+
  	// Accessing iframe documents after unload throws "permission denied" errors
  	// (see trac-13936).
  	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
  	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
  	if ( documentElement.msMatchesSelector &&

  		// Support: IE 11+, Edge 17 - 18+
  		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  		// two documents; shallow comparisons work.
  		// eslint-disable-next-line eqeqeq
  		preferredDoc != document &&
  		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

  		// Support: IE 9 - 11+, Edge 12 - 18+
  		subWindow.addEventListener( "unload", unloadHandler );
  	}

  	// Support: IE <10
  	// Check if getElementById returns elements by name
  	// The broken getElementById methods don't pick up programmatically-set names,
  	// so use a roundabout getElementsByName test
  	support.getById = assert( function( el ) {
  		documentElement.appendChild( el ).id = jQuery.expando;
  		return !document.getElementsByName ||
  			!document.getElementsByName( jQuery.expando ).length;
  	} );

  	// Support: IE 9 only
  	// Check to see if it's possible to do matchesSelector
  	// on a disconnected node.
  	support.disconnectedMatch = assert( function( el ) {
  		return matches.call( el, "*" );
  	} );

  	// Support: IE 9 - 11+, Edge 12 - 18+
  	// IE/Edge don't support the :scope pseudo-class.
  	support.scope = assert( function() {
  		return document.querySelectorAll( ":scope" );
  	} );

  	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
  	// Make sure the `:has()` argument is parsed unforgivingly.
  	// We include `*` in the test to detect buggy implementations that are
  	// _selectively_ forgiving (specifically when the list includes at least
  	// one valid selector).
  	// Note that we treat complete lack of support for `:has()` as if it were
  	// spec-compliant support, which is fine because use of `:has()` in such
  	// environments will fail in the qSA path and fall back to jQuery traversal
  	// anyway.
  	support.cssHas = assert( function() {
  		try {
  			document.querySelector( ":has(*,:jqfake)" );
  			return false;
  		} catch ( e ) {
  			return true;
  		}
  	} );

  	// ID filter and find
  	if ( support.getById ) {
  		Expr.filter.ID = function( id ) {
  			var attrId = id.replace( runescape, funescape );
  			return function( elem ) {
  				return elem.getAttribute( "id" ) === attrId;
  			};
  		};
  		Expr.find.ID = function( id, context ) {
  			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  				var elem = context.getElementById( id );
  				return elem ? [ elem ] : [];
  			}
  		};
  	} else {
  		Expr.filter.ID =  function( id ) {
  			var attrId = id.replace( runescape, funescape );
  			return function( elem ) {
  				var node = typeof elem.getAttributeNode !== "undefined" &&
  					elem.getAttributeNode( "id" );
  				return node && node.value === attrId;
  			};
  		};

  		// Support: IE 6 - 7 only
  		// getElementById is not reliable as a find shortcut
  		Expr.find.ID = function( id, context ) {
  			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  				var node, i, elems,
  					elem = context.getElementById( id );

  				if ( elem ) {

  					// Verify the id attribute
  					node = elem.getAttributeNode( "id" );
  					if ( node && node.value === id ) {
  						return [ elem ];
  					}

  					// Fall back on getElementsByName
  					elems = context.getElementsByName( id );
  					i = 0;
  					while ( ( elem = elems[ i++ ] ) ) {
  						node = elem.getAttributeNode( "id" );
  						if ( node && node.value === id ) {
  							return [ elem ];
  						}
  					}
  				}

  				return [];
  			}
  		};
  	}

  	// Tag
  	Expr.find.TAG = function( tag, context ) {
  		if ( typeof context.getElementsByTagName !== "undefined" ) {
  			return context.getElementsByTagName( tag );

  		// DocumentFragment nodes don't have gEBTN
  		} else {
  			return context.querySelectorAll( tag );
  		}
  	};

  	// Class
  	Expr.find.CLASS = function( className, context ) {
  		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
  			return context.getElementsByClassName( className );
  		}
  	};

  	/* QSA/matchesSelector
  	---------------------------------------------------------------------- */

  	// QSA and matchesSelector support

  	rbuggyQSA = [];

  	// Build QSA regex
  	// Regex strategy adopted from Diego Perini
  	assert( function( el ) {

  		var input;

  		documentElement.appendChild( el ).innerHTML =
  			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
  			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
  			"<option selected=''></option></select>";

  		// Support: iOS <=7 - 8 only
  		// Boolean attributes and "value" are not treated correctly in some XML documents
  		if ( !el.querySelectorAll( "[selected]" ).length ) {
  			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
  		}

  		// Support: iOS <=7 - 8 only
  		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
  			rbuggyQSA.push( "~=" );
  		}

  		// Support: iOS 8 only
  		// https://bugs.webkit.org/show_bug.cgi?id=136851
  		// In-page `selector#id sibling-combinator selector` fails
  		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
  			rbuggyQSA.push( ".#.+[+~]" );
  		}

  		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
  		// In some of the document kinds, these selectors wouldn't work natively.
  		// This is probably OK but for backwards compatibility we want to maintain
  		// handling them through jQuery traversal in jQuery 3.x.
  		if ( !el.querySelectorAll( ":checked" ).length ) {
  			rbuggyQSA.push( ":checked" );
  		}

  		// Support: Windows 8 Native Apps
  		// The type and name attributes are restricted during .innerHTML assignment
  		input = document.createElement( "input" );
  		input.setAttribute( "type", "hidden" );
  		el.appendChild( input ).setAttribute( "name", "D" );

  		// Support: IE 9 - 11+
  		// IE's :disabled selector does not pick up the children of disabled fieldsets
  		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
  		// In some of the document kinds, these selectors wouldn't work natively.
  		// This is probably OK but for backwards compatibility we want to maintain
  		// handling them through jQuery traversal in jQuery 3.x.
  		documentElement.appendChild( el ).disabled = true;
  		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
  			rbuggyQSA.push( ":enabled", ":disabled" );
  		}

  		// Support: IE 11+, Edge 15 - 18+
  		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
  		// Adding a temporary attribute to the document before the selection works
  		// around the issue.
  		// Interestingly, IE 10 & older don't seem to have the issue.
  		input = document.createElement( "input" );
  		input.setAttribute( "name", "" );
  		el.appendChild( input );
  		if ( !el.querySelectorAll( "[name='']" ).length ) {
  			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
  				whitespace + "*(?:''|\"\")" );
  		}
  	} );

  	if ( !support.cssHas ) {

  		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
  		// Our regular `try-catch` mechanism fails to detect natively-unsupported
  		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
  		// in browsers that parse the `:has()` argument as a forgiving selector list.
  		// https://drafts.csswg.org/selectors/#relational now requires the argument
  		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
  		rbuggyQSA.push( ":has" );
  	}

  	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

  	/* Sorting
  	---------------------------------------------------------------------- */

  	// Document order sorting
  	sortOrder = function( a, b ) {

  		// Flag for duplicate removal
  		if ( a === b ) {
  			hasDuplicate = true;
  			return 0;
  		}

  		// Sort on method existence if only one input has compareDocumentPosition
  		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
  		if ( compare ) {
  			return compare;
  		}

  		// Calculate position if both inputs belong to the same document
  		// Support: IE 11+, Edge 17 - 18+
  		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  		// two documents; shallow comparisons work.
  		// eslint-disable-next-line eqeqeq
  		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
  			a.compareDocumentPosition( b ) :

  			// Otherwise we know they are disconnected
  			1;

  		// Disconnected nodes
  		if ( compare & 1 ||
  			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

  			// Choose the first element that is related to our preferred document
  			// Support: IE 11+, Edge 17 - 18+
  			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  			// two documents; shallow comparisons work.
  			// eslint-disable-next-line eqeqeq
  			if ( a === document || a.ownerDocument == preferredDoc &&
  				find.contains( preferredDoc, a ) ) {
  				return -1;
  			}

  			// Support: IE 11+, Edge 17 - 18+
  			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  			// two documents; shallow comparisons work.
  			// eslint-disable-next-line eqeqeq
  			if ( b === document || b.ownerDocument == preferredDoc &&
  				find.contains( preferredDoc, b ) ) {
  				return 1;
  			}

  			// Maintain original order
  			return sortInput ?
  				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
  				0;
  		}

  		return compare & 4 ? -1 : 1;
  	};

  	return document;
  }

  find.matches = function( expr, elements ) {
  	return find( expr, null, null, elements );
  };

  find.matchesSelector = function( elem, expr ) {
  	setDocument( elem );

  	if ( documentIsHTML &&
  		!nonnativeSelectorCache[ expr + " " ] &&
  		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

  		try {
  			var ret = matches.call( elem, expr );

  			// IE 9's matchesSelector returns false on disconnected nodes
  			if ( ret || support.disconnectedMatch ||

  					// As well, disconnected nodes are said to be in a document
  					// fragment in IE 9
  					elem.document && elem.document.nodeType !== 11 ) {
  				return ret;
  			}
  		} catch ( e ) {
  			nonnativeSelectorCache( expr, true );
  		}
  	}

  	return find( expr, document, null, [ elem ] ).length > 0;
  };

  find.contains = function( context, elem ) {

  	// Set document vars if needed
  	// Support: IE 11+, Edge 17 - 18+
  	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  	// two documents; shallow comparisons work.
  	// eslint-disable-next-line eqeqeq
  	if ( ( context.ownerDocument || context ) != document ) {
  		setDocument( context );
  	}
  	return jQuery.contains( context, elem );
  };


  find.attr = function( elem, name ) {

  	// Set document vars if needed
  	// Support: IE 11+, Edge 17 - 18+
  	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  	// two documents; shallow comparisons work.
  	// eslint-disable-next-line eqeqeq
  	if ( ( elem.ownerDocument || elem ) != document ) {
  		setDocument( elem );
  	}

  	var fn = Expr.attrHandle[ name.toLowerCase() ],

  		// Don't get fooled by Object.prototype properties (see trac-13807)
  		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
  			fn( elem, name, !documentIsHTML ) :
  			undefined;

  	if ( val !== undefined ) {
  		return val;
  	}

  	return elem.getAttribute( name );
  };

  find.error = function( msg ) {
  	throw new Error( "Syntax error, unrecognized expression: " + msg );
  };

  /**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
  jQuery.uniqueSort = function( results ) {
  	var elem,
  		duplicates = [],
  		j = 0,
  		i = 0;

  	// Unless we *know* we can detect duplicates, assume their presence
  	//
  	// Support: Android <=4.0+
  	// Testing for detecting duplicates is unpredictable so instead assume we can't
  	// depend on duplicate detection in all browsers without a stable sort.
  	hasDuplicate = !support.sortStable;
  	sortInput = !support.sortStable && slice.call( results, 0 );
  	sort.call( results, sortOrder );

  	if ( hasDuplicate ) {
  		while ( ( elem = results[ i++ ] ) ) {
  			if ( elem === results[ i ] ) {
  				j = duplicates.push( i );
  			}
  		}
  		while ( j-- ) {
  			splice.call( results, duplicates[ j ], 1 );
  		}
  	}

  	// Clear input after sorting to release objects
  	// See https://github.com/jquery/sizzle/pull/225
  	sortInput = null;

  	return results;
  };

  jQuery.fn.uniqueSort = function() {
  	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
  };

  Expr = jQuery.expr = {

  	// Can be adjusted by the user
  	cacheLength: 50,

  	createPseudo: markFunction,

  	match: matchExpr,

  	attrHandle: {},

  	find: {},

  	relative: {
  		">": { dir: "parentNode", first: true },
  		" ": { dir: "parentNode" },
  		"+": { dir: "previousSibling", first: true },
  		"~": { dir: "previousSibling" }
  	},

  	preFilter: {
  		ATTR: function( match ) {
  			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

  			// Move the given value to match[3] whether quoted or unquoted
  			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
  				.replace( runescape, funescape );

  			if ( match[ 2 ] === "~=" ) {
  				match[ 3 ] = " " + match[ 3 ] + " ";
  			}

  			return match.slice( 0, 4 );
  		},

  		CHILD: function( match ) {

  			/* matches from matchExpr["CHILD"]
  				1 type (only|nth|...)
  				2 what (child|of-type)
  				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
  				4 xn-component of xn+y argument ([+-]?\d*n|)
  				5 sign of xn-component
  				6 x of xn-component
  				7 sign of y-component
  				8 y of y-component
  			*/
  			match[ 1 ] = match[ 1 ].toLowerCase();

  			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

  				// nth-* requires argument
  				if ( !match[ 3 ] ) {
  					find.error( match[ 0 ] );
  				}

  				// numeric x and y parameters for Expr.filter.CHILD
  				// remember that false/true cast respectively to 0/1
  				match[ 4 ] = +( match[ 4 ] ?
  					match[ 5 ] + ( match[ 6 ] || 1 ) :
  					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
  				);
  				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

  			// other types prohibit arguments
  			} else if ( match[ 3 ] ) {
  				find.error( match[ 0 ] );
  			}

  			return match;
  		},

  		PSEUDO: function( match ) {
  			var excess,
  				unquoted = !match[ 6 ] && match[ 2 ];

  			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
  				return null;
  			}

  			// Accept quoted arguments as-is
  			if ( match[ 3 ] ) {
  				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

  			// Strip excess characters from unquoted arguments
  			} else if ( unquoted && rpseudo.test( unquoted ) &&

  				// Get excess from tokenize (recursively)
  				( excess = tokenize( unquoted, true ) ) &&

  				// advance to the next closing parenthesis
  				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

  				// excess is a negative index
  				match[ 0 ] = match[ 0 ].slice( 0, excess );
  				match[ 2 ] = unquoted.slice( 0, excess );
  			}

  			// Return only captures needed by the pseudo filter method (type and argument)
  			return match.slice( 0, 3 );
  		}
  	},

  	filter: {

  		TAG: function( nodeNameSelector ) {
  			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
  			return nodeNameSelector === "*" ?
  				function() {
  					return true;
  				} :
  				function( elem ) {
  					return nodeName( elem, expectedNodeName );
  				};
  		},

  		CLASS: function( className ) {
  			var pattern = classCache[ className + " " ];

  			return pattern ||
  				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
  					"(" + whitespace + "|$)" ) ) &&
  				classCache( className, function( elem ) {
  					return pattern.test(
  						typeof elem.className === "string" && elem.className ||
  							typeof elem.getAttribute !== "undefined" &&
  								elem.getAttribute( "class" ) ||
  							""
  					);
  				} );
  		},

  		ATTR: function( name, operator, check ) {
  			return function( elem ) {
  				var result = find.attr( elem, name );

  				if ( result == null ) {
  					return operator === "!=";
  				}
  				if ( !operator ) {
  					return true;
  				}

  				result += "";

  				if ( operator === "=" ) {
  					return result === check;
  				}
  				if ( operator === "!=" ) {
  					return result !== check;
  				}
  				if ( operator === "^=" ) {
  					return check && result.indexOf( check ) === 0;
  				}
  				if ( operator === "*=" ) {
  					return check && result.indexOf( check ) > -1;
  				}
  				if ( operator === "$=" ) {
  					return check && result.slice( -check.length ) === check;
  				}
  				if ( operator === "~=" ) {
  					return ( " " + result.replace( rwhitespace, " " ) + " " )
  						.indexOf( check ) > -1;
  				}
  				if ( operator === "|=" ) {
  					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
  				}

  				return false;
  			};
  		},

  		CHILD: function( type, what, _argument, first, last ) {
  			var simple = type.slice( 0, 3 ) !== "nth",
  				forward = type.slice( -4 ) !== "last",
  				ofType = what === "of-type";

  			return first === 1 && last === 0 ?

  				// Shortcut for :nth-*(n)
  				function( elem ) {
  					return !!elem.parentNode;
  				} :

  				function( elem, _context, xml ) {
  					var cache, outerCache, node, nodeIndex, start,
  						dir = simple !== forward ? "nextSibling" : "previousSibling",
  						parent = elem.parentNode,
  						name = ofType && elem.nodeName.toLowerCase(),
  						useCache = !xml && !ofType,
  						diff = false;

  					if ( parent ) {

  						// :(first|last|only)-(child|of-type)
  						if ( simple ) {
  							while ( dir ) {
  								node = elem;
  								while ( ( node = node[ dir ] ) ) {
  									if ( ofType ?
  										nodeName( node, name ) :
  										node.nodeType === 1 ) {

  										return false;
  									}
  								}

  								// Reverse direction for :only-* (if we haven't yet done so)
  								start = dir = type === "only" && !start && "nextSibling";
  							}
  							return true;
  						}

  						start = [ forward ? parent.firstChild : parent.lastChild ];

  						// non-xml :nth-child(...) stores cache data on `parent`
  						if ( forward && useCache ) {

  							// Seek `elem` from a previously-cached index
  							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
  							cache = outerCache[ type ] || [];
  							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  							diff = nodeIndex && cache[ 2 ];
  							node = nodeIndex && parent.childNodes[ nodeIndex ];

  							while ( ( node = ++nodeIndex && node && node[ dir ] ||

  								// Fallback to seeking `elem` from the start
  								( diff = nodeIndex = 0 ) || start.pop() ) ) {

  								// When found, cache indexes on `parent` and break
  								if ( node.nodeType === 1 && ++diff && node === elem ) {
  									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
  									break;
  								}
  							}

  						} else {

  							// Use previously-cached element index if available
  							if ( useCache ) {
  								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
  								cache = outerCache[ type ] || [];
  								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  								diff = nodeIndex;
  							}

  							// xml :nth-child(...)
  							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
  							if ( diff === false ) {

  								// Use the same loop as above to seek `elem` from the start
  								while ( ( node = ++nodeIndex && node && node[ dir ] ||
  									( diff = nodeIndex = 0 ) || start.pop() ) ) {

  									if ( ( ofType ?
  										nodeName( node, name ) :
  										node.nodeType === 1 ) &&
  										++diff ) {

  										// Cache the index of each encountered element
  										if ( useCache ) {
  											outerCache = node[ expando ] ||
  												( node[ expando ] = {} );
  											outerCache[ type ] = [ dirruns, diff ];
  										}

  										if ( node === elem ) {
  											break;
  										}
  									}
  								}
  							}
  						}

  						// Incorporate the offset, then check against cycle size
  						diff -= last;
  						return diff === first || ( diff % first === 0 && diff / first >= 0 );
  					}
  				};
  		},

  		PSEUDO: function( pseudo, argument ) {

  			// pseudo-class names are case-insensitive
  			// https://www.w3.org/TR/selectors/#pseudo-classes
  			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
  			// Remember that setFilters inherits from pseudos
  			var args,
  				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
  					find.error( "unsupported pseudo: " + pseudo );

  			// The user may use createPseudo to indicate that
  			// arguments are needed to create the filter function
  			// just as jQuery does
  			if ( fn[ expando ] ) {
  				return fn( argument );
  			}

  			// But maintain support for old signatures
  			if ( fn.length > 1 ) {
  				args = [ pseudo, pseudo, "", argument ];
  				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
  					markFunction( function( seed, matches ) {
  						var idx,
  							matched = fn( seed, argument ),
  							i = matched.length;
  						while ( i-- ) {
  							idx = indexOf.call( seed, matched[ i ] );
  							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
  						}
  					} ) :
  					function( elem ) {
  						return fn( elem, 0, args );
  					};
  			}

  			return fn;
  		}
  	},

  	pseudos: {

  		// Potentially complex pseudos
  		not: markFunction( function( selector ) {

  			// Trim the selector passed to compile
  			// to avoid treating leading and trailing
  			// spaces as combinators
  			var input = [],
  				results = [],
  				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

  			return matcher[ expando ] ?
  				markFunction( function( seed, matches, _context, xml ) {
  					var elem,
  						unmatched = matcher( seed, null, xml, [] ),
  						i = seed.length;

  					// Match elements unmatched by `matcher`
  					while ( i-- ) {
  						if ( ( elem = unmatched[ i ] ) ) {
  							seed[ i ] = !( matches[ i ] = elem );
  						}
  					}
  				} ) :
  				function( elem, _context, xml ) {
  					input[ 0 ] = elem;
  					matcher( input, null, xml, results );

  					// Don't keep the element
  					// (see https://github.com/jquery/sizzle/issues/299)
  					input[ 0 ] = null;
  					return !results.pop();
  				};
  		} ),

  		has: markFunction( function( selector ) {
  			return function( elem ) {
  				return find( selector, elem ).length > 0;
  			};
  		} ),

  		contains: markFunction( function( text ) {
  			text = text.replace( runescape, funescape );
  			return function( elem ) {
  				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
  			};
  		} ),

  		// "Whether an element is represented by a :lang() selector
  		// is based solely on the element's language value
  		// being equal to the identifier C,
  		// or beginning with the identifier C immediately followed by "-".
  		// The matching of C against the element's language value is performed case-insensitively.
  		// The identifier C does not have to be a valid language name."
  		// https://www.w3.org/TR/selectors/#lang-pseudo
  		lang: markFunction( function( lang ) {

  			// lang value must be a valid identifier
  			if ( !ridentifier.test( lang || "" ) ) {
  				find.error( "unsupported lang: " + lang );
  			}
  			lang = lang.replace( runescape, funescape ).toLowerCase();
  			return function( elem ) {
  				var elemLang;
  				do {
  					if ( ( elemLang = documentIsHTML ?
  						elem.lang :
  						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

  						elemLang = elemLang.toLowerCase();
  						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
  					}
  				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
  				return false;
  			};
  		} ),

  		// Miscellaneous
  		target: function( elem ) {
  			var hash = window.location && window.location.hash;
  			return hash && hash.slice( 1 ) === elem.id;
  		},

  		root: function( elem ) {
  			return elem === documentElement;
  		},

  		focus: function( elem ) {
  			return elem === safeActiveElement() &&
  				document.hasFocus() &&
  				!!( elem.type || elem.href || ~elem.tabIndex );
  		},

  		// Boolean properties
  		enabled: createDisabledPseudo( false ),
  		disabled: createDisabledPseudo( true ),

  		checked: function( elem ) {

  			// In CSS3, :checked should return both checked and selected elements
  			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
  				( nodeName( elem, "option" ) && !!elem.selected );
  		},

  		selected: function( elem ) {

  			// Support: IE <=11+
  			// Accessing the selectedIndex property
  			// forces the browser to treat the default option as
  			// selected when in an optgroup.
  			if ( elem.parentNode ) {
  				// eslint-disable-next-line no-unused-expressions
  				elem.parentNode.selectedIndex;
  			}

  			return elem.selected === true;
  		},

  		// Contents
  		empty: function( elem ) {

  			// https://www.w3.org/TR/selectors/#empty-pseudo
  			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
  			//   but not by others (comment: 8; processing instruction: 7; etc.)
  			// nodeType < 6 works because attributes (2) do not appear as children
  			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
  				if ( elem.nodeType < 6 ) {
  					return false;
  				}
  			}
  			return true;
  		},

  		parent: function( elem ) {
  			return !Expr.pseudos.empty( elem );
  		},

  		// Element/input types
  		header: function( elem ) {
  			return rheader.test( elem.nodeName );
  		},

  		input: function( elem ) {
  			return rinputs.test( elem.nodeName );
  		},

  		button: function( elem ) {
  			return nodeName( elem, "input" ) && elem.type === "button" ||
  				nodeName( elem, "button" );
  		},

  		text: function( elem ) {
  			var attr;
  			return nodeName( elem, "input" ) && elem.type === "text" &&

  				// Support: IE <10 only
  				// New HTML5 attribute values (e.g., "search") appear
  				// with elem.type === "text"
  				( ( attr = elem.getAttribute( "type" ) ) == null ||
  					attr.toLowerCase() === "text" );
  		},

  		// Position-in-collection
  		first: createPositionalPseudo( function() {
  			return [ 0 ];
  		} ),

  		last: createPositionalPseudo( function( _matchIndexes, length ) {
  			return [ length - 1 ];
  		} ),

  		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
  			return [ argument < 0 ? argument + length : argument ];
  		} ),

  		even: createPositionalPseudo( function( matchIndexes, length ) {
  			var i = 0;
  			for ( ; i < length; i += 2 ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		} ),

  		odd: createPositionalPseudo( function( matchIndexes, length ) {
  			var i = 1;
  			for ( ; i < length; i += 2 ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		} ),

  		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
  			var i;

  			if ( argument < 0 ) {
  				i = argument + length;
  			} else if ( argument > length ) {
  				i = length;
  			} else {
  				i = argument;
  			}

  			for ( ; --i >= 0; ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		} ),

  		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
  			var i = argument < 0 ? argument + length : argument;
  			for ( ; ++i < length; ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		} )
  	}
  };

  Expr.pseudos.nth = Expr.pseudos.eq;

  // Add button/input type pseudos
  for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
  	Expr.pseudos[ i ] = createInputPseudo( i );
  }
  for ( i in { submit: true, reset: true } ) {
  	Expr.pseudos[ i ] = createButtonPseudo( i );
  }

  // Easy API for creating new setFilters
  function setFilters() {}
  setFilters.prototype = Expr.filters = Expr.pseudos;
  Expr.setFilters = new setFilters();

  function tokenize( selector, parseOnly ) {
  	var matched, match, tokens, type,
  		soFar, groups, preFilters,
  		cached = tokenCache[ selector + " " ];

  	if ( cached ) {
  		return parseOnly ? 0 : cached.slice( 0 );
  	}

  	soFar = selector;
  	groups = [];
  	preFilters = Expr.preFilter;

  	while ( soFar ) {

  		// Comma and first run
  		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
  			if ( match ) {

  				// Don't consume trailing commas as valid
  				soFar = soFar.slice( match[ 0 ].length ) || soFar;
  			}
  			groups.push( ( tokens = [] ) );
  		}

  		matched = false;

  		// Combinators
  		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
  			matched = match.shift();
  			tokens.push( {
  				value: matched,

  				// Cast descendant combinators to space
  				type: match[ 0 ].replace( rtrimCSS, " " )
  			} );
  			soFar = soFar.slice( matched.length );
  		}

  		// Filters
  		for ( type in Expr.filter ) {
  			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
  				( match = preFilters[ type ]( match ) ) ) ) {
  				matched = match.shift();
  				tokens.push( {
  					value: matched,
  					type: type,
  					matches: match
  				} );
  				soFar = soFar.slice( matched.length );
  			}
  		}

  		if ( !matched ) {
  			break;
  		}
  	}

  	// Return the length of the invalid excess
  	// if we're just parsing
  	// Otherwise, throw an error or return tokens
  	if ( parseOnly ) {
  		return soFar.length;
  	}

  	return soFar ?
  		find.error( selector ) :

  		// Cache the tokens
  		tokenCache( selector, groups ).slice( 0 );
  }

  function toSelector( tokens ) {
  	var i = 0,
  		len = tokens.length,
  		selector = "";
  	for ( ; i < len; i++ ) {
  		selector += tokens[ i ].value;
  	}
  	return selector;
  }

  function addCombinator( matcher, combinator, base ) {
  	var dir = combinator.dir,
  		skip = combinator.next,
  		key = skip || dir,
  		checkNonElements = base && key === "parentNode",
  		doneName = done++;

  	return combinator.first ?

  		// Check against closest ancestor/preceding element
  		function( elem, context, xml ) {
  			while ( ( elem = elem[ dir ] ) ) {
  				if ( elem.nodeType === 1 || checkNonElements ) {
  					return matcher( elem, context, xml );
  				}
  			}
  			return false;
  		} :

  		// Check against all ancestor/preceding elements
  		function( elem, context, xml ) {
  			var oldCache, outerCache,
  				newCache = [ dirruns, doneName ];

  			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
  			if ( xml ) {
  				while ( ( elem = elem[ dir ] ) ) {
  					if ( elem.nodeType === 1 || checkNonElements ) {
  						if ( matcher( elem, context, xml ) ) {
  							return true;
  						}
  					}
  				}
  			} else {
  				while ( ( elem = elem[ dir ] ) ) {
  					if ( elem.nodeType === 1 || checkNonElements ) {
  						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

  						if ( skip && nodeName( elem, skip ) ) {
  							elem = elem[ dir ] || elem;
  						} else if ( ( oldCache = outerCache[ key ] ) &&
  							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

  							// Assign to newCache so results back-propagate to previous elements
  							return ( newCache[ 2 ] = oldCache[ 2 ] );
  						} else {

  							// Reuse newcache so results back-propagate to previous elements
  							outerCache[ key ] = newCache;

  							// A match means we're done; a fail means we have to keep checking
  							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
  								return true;
  							}
  						}
  					}
  				}
  			}
  			return false;
  		};
  }

  function elementMatcher( matchers ) {
  	return matchers.length > 1 ?
  		function( elem, context, xml ) {
  			var i = matchers.length;
  			while ( i-- ) {
  				if ( !matchers[ i ]( elem, context, xml ) ) {
  					return false;
  				}
  			}
  			return true;
  		} :
  		matchers[ 0 ];
  }

  function multipleContexts( selector, contexts, results ) {
  	var i = 0,
  		len = contexts.length;
  	for ( ; i < len; i++ ) {
  		find( selector, contexts[ i ], results );
  	}
  	return results;
  }

  function condense( unmatched, map, filter, context, xml ) {
  	var elem,
  		newUnmatched = [],
  		i = 0,
  		len = unmatched.length,
  		mapped = map != null;

  	for ( ; i < len; i++ ) {
  		if ( ( elem = unmatched[ i ] ) ) {
  			if ( !filter || filter( elem, context, xml ) ) {
  				newUnmatched.push( elem );
  				if ( mapped ) {
  					map.push( i );
  				}
  			}
  		}
  	}

  	return newUnmatched;
  }

  function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
  	if ( postFilter && !postFilter[ expando ] ) {
  		postFilter = setMatcher( postFilter );
  	}
  	if ( postFinder && !postFinder[ expando ] ) {
  		postFinder = setMatcher( postFinder, postSelector );
  	}
  	return markFunction( function( seed, results, context, xml ) {
  		var temp, i, elem, matcherOut,
  			preMap = [],
  			postMap = [],
  			preexisting = results.length,

  			// Get initial elements from seed or context
  			elems = seed ||
  				multipleContexts( selector || "*",
  					context.nodeType ? [ context ] : context, [] ),

  			// Prefilter to get matcher input, preserving a map for seed-results synchronization
  			matcherIn = preFilter && ( seed || !selector ) ?
  				condense( elems, preMap, preFilter, context, xml ) :
  				elems;

  		if ( matcher ) {

  			// If we have a postFinder, or filtered seed, or non-seed postFilter
  			// or preexisting results,
  			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

  				// ...intermediate processing is necessary
  				[] :

  				// ...otherwise use results directly
  				results;

  			// Find primary matches
  			matcher( matcherIn, matcherOut, context, xml );
  		} else {
  			matcherOut = matcherIn;
  		}

  		// Apply postFilter
  		if ( postFilter ) {
  			temp = condense( matcherOut, postMap );
  			postFilter( temp, [], context, xml );

  			// Un-match failing elements by moving them back to matcherIn
  			i = temp.length;
  			while ( i-- ) {
  				if ( ( elem = temp[ i ] ) ) {
  					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
  				}
  			}
  		}

  		if ( seed ) {
  			if ( postFinder || preFilter ) {
  				if ( postFinder ) {

  					// Get the final matcherOut by condensing this intermediate into postFinder contexts
  					temp = [];
  					i = matcherOut.length;
  					while ( i-- ) {
  						if ( ( elem = matcherOut[ i ] ) ) {

  							// Restore matcherIn since elem is not yet a final match
  							temp.push( ( matcherIn[ i ] = elem ) );
  						}
  					}
  					postFinder( null, ( matcherOut = [] ), temp, xml );
  				}

  				// Move matched elements from seed to results to keep them synchronized
  				i = matcherOut.length;
  				while ( i-- ) {
  					if ( ( elem = matcherOut[ i ] ) &&
  						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

  						seed[ temp ] = !( results[ temp ] = elem );
  					}
  				}
  			}

  		// Add elements to results, through postFinder if defined
  		} else {
  			matcherOut = condense(
  				matcherOut === results ?
  					matcherOut.splice( preexisting, matcherOut.length ) :
  					matcherOut
  			);
  			if ( postFinder ) {
  				postFinder( null, results, matcherOut, xml );
  			} else {
  				push.apply( results, matcherOut );
  			}
  		}
  	} );
  }

  function matcherFromTokens( tokens ) {
  	var checkContext, matcher, j,
  		len = tokens.length,
  		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
  		implicitRelative = leadingRelative || Expr.relative[ " " ],
  		i = leadingRelative ? 1 : 0,

  		// The foundational matcher ensures that elements are reachable from top-level context(s)
  		matchContext = addCombinator( function( elem ) {
  			return elem === checkContext;
  		}, implicitRelative, true ),
  		matchAnyContext = addCombinator( function( elem ) {
  			return indexOf.call( checkContext, elem ) > -1;
  		}, implicitRelative, true ),
  		matchers = [ function( elem, context, xml ) {

  			// Support: IE 11+, Edge 17 - 18+
  			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  			// two documents; shallow comparisons work.
  			// eslint-disable-next-line eqeqeq
  			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
  				( checkContext = context ).nodeType ?
  					matchContext( elem, context, xml ) :
  					matchAnyContext( elem, context, xml ) );

  			// Avoid hanging onto element
  			// (see https://github.com/jquery/sizzle/issues/299)
  			checkContext = null;
  			return ret;
  		} ];

  	for ( ; i < len; i++ ) {
  		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
  			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
  		} else {
  			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

  			// Return special upon seeing a positional matcher
  			if ( matcher[ expando ] ) {

  				// Find the next relative operator (if any) for proper handling
  				j = ++i;
  				for ( ; j < len; j++ ) {
  					if ( Expr.relative[ tokens[ j ].type ] ) {
  						break;
  					}
  				}
  				return setMatcher(
  					i > 1 && elementMatcher( matchers ),
  					i > 1 && toSelector(

  						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
  						tokens.slice( 0, i - 1 )
  							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
  					).replace( rtrimCSS, "$1" ),
  					matcher,
  					i < j && matcherFromTokens( tokens.slice( i, j ) ),
  					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
  					j < len && toSelector( tokens )
  				);
  			}
  			matchers.push( matcher );
  		}
  	}

  	return elementMatcher( matchers );
  }

  function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
  	var bySet = setMatchers.length > 0,
  		byElement = elementMatchers.length > 0,
  		superMatcher = function( seed, context, xml, results, outermost ) {
  			var elem, j, matcher,
  				matchedCount = 0,
  				i = "0",
  				unmatched = seed && [],
  				setMatched = [],
  				contextBackup = outermostContext,

  				// We must always have either seed elements or outermost context
  				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

  				// Use integer dirruns iff this is the outermost matcher
  				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
  				len = elems.length;

  			if ( outermost ) {

  				// Support: IE 11+, Edge 17 - 18+
  				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  				// two documents; shallow comparisons work.
  				// eslint-disable-next-line eqeqeq
  				outermostContext = context == document || context || outermost;
  			}

  			// Add elements passing elementMatchers directly to results
  			// Support: iOS <=7 - 9 only
  			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
  			// elements by id. (see trac-14142)
  			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
  				if ( byElement && elem ) {
  					j = 0;

  					// Support: IE 11+, Edge 17 - 18+
  					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  					// two documents; shallow comparisons work.
  					// eslint-disable-next-line eqeqeq
  					if ( !context && elem.ownerDocument != document ) {
  						setDocument( elem );
  						xml = !documentIsHTML;
  					}
  					while ( ( matcher = elementMatchers[ j++ ] ) ) {
  						if ( matcher( elem, context || document, xml ) ) {
  							push.call( results, elem );
  							break;
  						}
  					}
  					if ( outermost ) {
  						dirruns = dirrunsUnique;
  					}
  				}

  				// Track unmatched elements for set filters
  				if ( bySet ) {

  					// They will have gone through all possible matchers
  					if ( ( elem = !matcher && elem ) ) {
  						matchedCount--;
  					}

  					// Lengthen the array for every element, matched or not
  					if ( seed ) {
  						unmatched.push( elem );
  					}
  				}
  			}

  			// `i` is now the count of elements visited above, and adding it to `matchedCount`
  			// makes the latter nonnegative.
  			matchedCount += i;

  			// Apply set filters to unmatched elements
  			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
  			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
  			// no element matchers and no seed.
  			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
  			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
  			// numerically zero.
  			if ( bySet && i !== matchedCount ) {
  				j = 0;
  				while ( ( matcher = setMatchers[ j++ ] ) ) {
  					matcher( unmatched, setMatched, context, xml );
  				}

  				if ( seed ) {

  					// Reintegrate element matches to eliminate the need for sorting
  					if ( matchedCount > 0 ) {
  						while ( i-- ) {
  							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
  								setMatched[ i ] = pop.call( results );
  							}
  						}
  					}

  					// Discard index placeholder values to get only actual matches
  					setMatched = condense( setMatched );
  				}

  				// Add matches to results
  				push.apply( results, setMatched );

  				// Seedless set matches succeeding multiple successful matchers stipulate sorting
  				if ( outermost && !seed && setMatched.length > 0 &&
  					( matchedCount + setMatchers.length ) > 1 ) {

  					jQuery.uniqueSort( results );
  				}
  			}

  			// Override manipulation of globals by nested matchers
  			if ( outermost ) {
  				dirruns = dirrunsUnique;
  				outermostContext = contextBackup;
  			}

  			return unmatched;
  		};

  	return bySet ?
  		markFunction( superMatcher ) :
  		superMatcher;
  }

  function compile( selector, match /* Internal Use Only */ ) {
  	var i,
  		setMatchers = [],
  		elementMatchers = [],
  		cached = compilerCache[ selector + " " ];

  	if ( !cached ) {

  		// Generate a function of recursive functions that can be used to check each element
  		if ( !match ) {
  			match = tokenize( selector );
  		}
  		i = match.length;
  		while ( i-- ) {
  			cached = matcherFromTokens( match[ i ] );
  			if ( cached[ expando ] ) {
  				setMatchers.push( cached );
  			} else {
  				elementMatchers.push( cached );
  			}
  		}

  		// Cache the compiled function
  		cached = compilerCache( selector,
  			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

  		// Save selector and tokenization
  		cached.selector = selector;
  	}
  	return cached;
  }

  /**
   * A low-level selection function that works with jQuery's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with jQuery selector compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
  function select( selector, context, results, seed ) {
  	var i, tokens, token, type, find,
  		compiled = typeof selector === "function" && selector,
  		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

  	results = results || [];

  	// Try to minimize operations if there is only one selector in the list and no seed
  	// (the latter of which guarantees us context)
  	if ( match.length === 1 ) {

  		// Reduce context if the leading compound selector is an ID
  		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
  		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
  				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

  			context = ( Expr.find.ID(
  				token.matches[ 0 ].replace( runescape, funescape ),
  				context
  			) || [] )[ 0 ];
  			if ( !context ) {
  				return results;

  			// Precompiled matchers will still verify ancestry, so step up a level
  			} else if ( compiled ) {
  				context = context.parentNode;
  			}

  			selector = selector.slice( tokens.shift().value.length );
  		}

  		// Fetch a seed set for right-to-left matching
  		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
  		while ( i-- ) {
  			token = tokens[ i ];

  			// Abort if we hit a combinator
  			if ( Expr.relative[ ( type = token.type ) ] ) {
  				break;
  			}
  			if ( ( find = Expr.find[ type ] ) ) {

  				// Search, expanding context for leading sibling combinators
  				if ( ( seed = find(
  					token.matches[ 0 ].replace( runescape, funescape ),
  					rsibling.test( tokens[ 0 ].type ) &&
  						testContext( context.parentNode ) || context
  				) ) ) {

  					// If seed is empty or no tokens remain, we can return early
  					tokens.splice( i, 1 );
  					selector = seed.length && toSelector( tokens );
  					if ( !selector ) {
  						push.apply( results, seed );
  						return results;
  					}

  					break;
  				}
  			}
  		}
  	}

  	// Compile and execute a filtering function if one is not provided
  	// Provide `match` to avoid retokenization if we modified the selector above
  	( compiled || compile( selector, match ) )(
  		seed,
  		context,
  		!documentIsHTML,
  		results,
  		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
  	);
  	return results;
  }

  // One-time assignments

  // Support: Android <=4.0 - 4.1+
  // Sort stability
  support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

  // Initialize against the default document
  setDocument();

  // Support: Android <=4.0 - 4.1+
  // Detached nodes confoundingly follow *each other*
  support.sortDetached = assert( function( el ) {

  	// Should return 1, but returns 4 (following)
  	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
  } );

  jQuery.find = find;

  // Deprecated
  jQuery.expr[ ":" ] = jQuery.expr.pseudos;
  jQuery.unique = jQuery.uniqueSort;

  // These have always been private, but they used to be documented as part of
  // Sizzle so let's maintain them for now for backwards compatibility purposes.
  find.compile = compile;
  find.select = select;
  find.setDocument = setDocument;
  find.tokenize = tokenize;

  find.escape = jQuery.escapeSelector;
  find.getText = jQuery.text;
  find.isXML = jQuery.isXMLDoc;
  find.selectors = jQuery.expr;
  find.support = jQuery.support;
  find.uniqueSort = jQuery.uniqueSort;

  	/* eslint-enable */

  } )();


  var dir = function( elem, dir, until ) {
  	var matched = [],
  		truncate = until !== undefined;

  	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
  		if ( elem.nodeType === 1 ) {
  			if ( truncate && jQuery( elem ).is( until ) ) {
  				break;
  			}
  			matched.push( elem );
  		}
  	}
  	return matched;
  };


  var siblings = function( n, elem ) {
  	var matched = [];

  	for ( ; n; n = n.nextSibling ) {
  		if ( n.nodeType === 1 && n !== elem ) {
  			matched.push( n );
  		}
  	}

  	return matched;
  };


  var rneedsContext = jQuery.expr.match.needsContext;

  var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



  // Implement the identical functionality for filter and not
  function winnow( elements, qualifier, not ) {
  	if ( isFunction( qualifier ) ) {
  		return jQuery.grep( elements, function( elem, i ) {
  			return !!qualifier.call( elem, i, elem ) !== not;
  		} );
  	}

  	// Single element
  	if ( qualifier.nodeType ) {
  		return jQuery.grep( elements, function( elem ) {
  			return ( elem === qualifier ) !== not;
  		} );
  	}

  	// Arraylike of elements (jQuery, arguments, Array)
  	if ( typeof qualifier !== "string" ) {
  		return jQuery.grep( elements, function( elem ) {
  			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
  		} );
  	}

  	// Filtered directly for both simple and complex selectors
  	return jQuery.filter( qualifier, elements, not );
  }

  jQuery.filter = function( expr, elems, not ) {
  	var elem = elems[ 0 ];

  	if ( not ) {
  		expr = ":not(" + expr + ")";
  	}

  	if ( elems.length === 1 && elem.nodeType === 1 ) {
  		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
  	}

  	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
  		return elem.nodeType === 1;
  	} ) );
  };

  jQuery.fn.extend( {
  	find: function( selector ) {
  		var i, ret,
  			len = this.length,
  			self = this;

  		if ( typeof selector !== "string" ) {
  			return this.pushStack( jQuery( selector ).filter( function() {
  				for ( i = 0; i < len; i++ ) {
  					if ( jQuery.contains( self[ i ], this ) ) {
  						return true;
  					}
  				}
  			} ) );
  		}

  		ret = this.pushStack( [] );

  		for ( i = 0; i < len; i++ ) {
  			jQuery.find( selector, self[ i ], ret );
  		}

  		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
  	},
  	filter: function( selector ) {
  		return this.pushStack( winnow( this, selector || [], false ) );
  	},
  	not: function( selector ) {
  		return this.pushStack( winnow( this, selector || [], true ) );
  	},
  	is: function( selector ) {
  		return !!winnow(
  			this,

  			// If this is a positional/relative selector, check membership in the returned set
  			// so $("p:first").is("p:last") won't return true for a doc with two "p".
  			typeof selector === "string" && rneedsContext.test( selector ) ?
  				jQuery( selector ) :
  				selector || [],
  			false
  		).length;
  	}
  } );


  // Initialize a jQuery object


  // A central reference to the root jQuery(document)
  var rootjQuery,

  	// A simple way to check for HTML strings
  	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
  	// Strict HTML recognition (trac-11290: must start with <)
  	// Shortcut simple #id case for speed
  	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

  	init = jQuery.fn.init = function( selector, context, root ) {
  		var match, elem;

  		// HANDLE: $(""), $(null), $(undefined), $(false)
  		if ( !selector ) {
  			return this;
  		}

  		// Method init() accepts an alternate rootjQuery
  		// so migrate can support jQuery.sub (gh-2101)
  		root = root || rootjQuery;

  		// Handle HTML strings
  		if ( typeof selector === "string" ) {
  			if ( selector[ 0 ] === "<" &&
  				selector[ selector.length - 1 ] === ">" &&
  				selector.length >= 3 ) {

  				// Assume that strings that start and end with <> are HTML and skip the regex check
  				match = [ null, selector, null ];

  			} else {
  				match = rquickExpr.exec( selector );
  			}

  			// Match html or make sure no context is specified for #id
  			if ( match && ( match[ 1 ] || !context ) ) {

  				// HANDLE: $(html) -> $(array)
  				if ( match[ 1 ] ) {
  					context = context instanceof jQuery ? context[ 0 ] : context;

  					// Option to run scripts is true for back-compat
  					// Intentionally let the error be thrown if parseHTML is not present
  					jQuery.merge( this, jQuery.parseHTML(
  						match[ 1 ],
  						context && context.nodeType ? context.ownerDocument || context : document,
  						true
  					) );

  					// HANDLE: $(html, props)
  					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
  						for ( match in context ) {

  							// Properties of context are called as methods if possible
  							if ( isFunction( this[ match ] ) ) {
  								this[ match ]( context[ match ] );

  							// ...and otherwise set as attributes
  							} else {
  								this.attr( match, context[ match ] );
  							}
  						}
  					}

  					return this;

  				// HANDLE: $(#id)
  				} else {
  					elem = document.getElementById( match[ 2 ] );

  					if ( elem ) {

  						// Inject the element directly into the jQuery object
  						this[ 0 ] = elem;
  						this.length = 1;
  					}
  					return this;
  				}

  			// HANDLE: $(expr, $(...))
  			} else if ( !context || context.jquery ) {
  				return ( context || root ).find( selector );

  			// HANDLE: $(expr, context)
  			// (which is just equivalent to: $(context).find(expr)
  			} else {
  				return this.constructor( context ).find( selector );
  			}

  		// HANDLE: $(DOMElement)
  		} else if ( selector.nodeType ) {
  			this[ 0 ] = selector;
  			this.length = 1;
  			return this;

  		// HANDLE: $(function)
  		// Shortcut for document ready
  		} else if ( isFunction( selector ) ) {
  			return root.ready !== undefined ?
  				root.ready( selector ) :

  				// Execute immediately if ready is not present
  				selector( jQuery );
  		}

  		return jQuery.makeArray( selector, this );
  	};

  // Give the init function the jQuery prototype for later instantiation
  init.prototype = jQuery.fn;

  // Initialize central reference
  rootjQuery = jQuery( document );


  var rparentsprev = /^(?:parents|prev(?:Until|All))/,

  	// Methods guaranteed to produce a unique set when starting from a unique set
  	guaranteedUnique = {
  		children: true,
  		contents: true,
  		next: true,
  		prev: true
  	};

  jQuery.fn.extend( {
  	has: function( target ) {
  		var targets = jQuery( target, this ),
  			l = targets.length;

  		return this.filter( function() {
  			var i = 0;
  			for ( ; i < l; i++ ) {
  				if ( jQuery.contains( this, targets[ i ] ) ) {
  					return true;
  				}
  			}
  		} );
  	},

  	closest: function( selectors, context ) {
  		var cur,
  			i = 0,
  			l = this.length,
  			matched = [],
  			targets = typeof selectors !== "string" && jQuery( selectors );

  		// Positional selectors never match, since there's no _selection_ context
  		if ( !rneedsContext.test( selectors ) ) {
  			for ( ; i < l; i++ ) {
  				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

  					// Always skip document fragments
  					if ( cur.nodeType < 11 && ( targets ?
  						targets.index( cur ) > -1 :

  						// Don't pass non-elements to jQuery#find
  						cur.nodeType === 1 &&
  							jQuery.find.matchesSelector( cur, selectors ) ) ) {

  						matched.push( cur );
  						break;
  					}
  				}
  			}
  		}

  		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
  	},

  	// Determine the position of an element within the set
  	index: function( elem ) {

  		// No argument, return index in parent
  		if ( !elem ) {
  			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
  		}

  		// Index in selector
  		if ( typeof elem === "string" ) {
  			return indexOf.call( jQuery( elem ), this[ 0 ] );
  		}

  		// Locate the position of the desired element
  		return indexOf.call( this,

  			// If it receives a jQuery object, the first element is used
  			elem.jquery ? elem[ 0 ] : elem
  		);
  	},

  	add: function( selector, context ) {
  		return this.pushStack(
  			jQuery.uniqueSort(
  				jQuery.merge( this.get(), jQuery( selector, context ) )
  			)
  		);
  	},

  	addBack: function( selector ) {
  		return this.add( selector == null ?
  			this.prevObject : this.prevObject.filter( selector )
  		);
  	}
  } );

  function sibling( cur, dir ) {
  	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
  	return cur;
  }

  jQuery.each( {
  	parent: function( elem ) {
  		var parent = elem.parentNode;
  		return parent && parent.nodeType !== 11 ? parent : null;
  	},
  	parents: function( elem ) {
  		return dir( elem, "parentNode" );
  	},
  	parentsUntil: function( elem, _i, until ) {
  		return dir( elem, "parentNode", until );
  	},
  	next: function( elem ) {
  		return sibling( elem, "nextSibling" );
  	},
  	prev: function( elem ) {
  		return sibling( elem, "previousSibling" );
  	},
  	nextAll: function( elem ) {
  		return dir( elem, "nextSibling" );
  	},
  	prevAll: function( elem ) {
  		return dir( elem, "previousSibling" );
  	},
  	nextUntil: function( elem, _i, until ) {
  		return dir( elem, "nextSibling", until );
  	},
  	prevUntil: function( elem, _i, until ) {
  		return dir( elem, "previousSibling", until );
  	},
  	siblings: function( elem ) {
  		return siblings( ( elem.parentNode || {} ).firstChild, elem );
  	},
  	children: function( elem ) {
  		return siblings( elem.firstChild );
  	},
  	contents: function( elem ) {
  		if ( elem.contentDocument != null &&

  			// Support: IE 11+
  			// <object> elements with no `data` attribute has an object
  			// `contentDocument` with a `null` prototype.
  			getProto( elem.contentDocument ) ) {

  			return elem.contentDocument;
  		}

  		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
  		// Treat the template element as a regular one in browsers that
  		// don't support it.
  		if ( nodeName( elem, "template" ) ) {
  			elem = elem.content || elem;
  		}

  		return jQuery.merge( [], elem.childNodes );
  	}
  }, function( name, fn ) {
  	jQuery.fn[ name ] = function( until, selector ) {
  		var matched = jQuery.map( this, fn, until );

  		if ( name.slice( -5 ) !== "Until" ) {
  			selector = until;
  		}

  		if ( selector && typeof selector === "string" ) {
  			matched = jQuery.filter( selector, matched );
  		}

  		if ( this.length > 1 ) {

  			// Remove duplicates
  			if ( !guaranteedUnique[ name ] ) {
  				jQuery.uniqueSort( matched );
  			}

  			// Reverse order for parents* and prev-derivatives
  			if ( rparentsprev.test( name ) ) {
  				matched.reverse();
  			}
  		}

  		return this.pushStack( matched );
  	};
  } );
  var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



  // Convert String-formatted options into Object-formatted ones
  function createOptions( options ) {
  	var object = {};
  	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
  		object[ flag ] = true;
  	} );
  	return object;
  }

  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */
  jQuery.Callbacks = function( options ) {

  	// Convert options from String-formatted to Object-formatted if needed
  	// (we check in cache first)
  	options = typeof options === "string" ?
  		createOptions( options ) :
  		jQuery.extend( {}, options );

  	var // Flag to know if list is currently firing
  		firing,

  		// Last fire value for non-forgettable lists
  		memory,

  		// Flag to know if list was already fired
  		fired,

  		// Flag to prevent firing
  		locked,

  		// Actual callback list
  		list = [],

  		// Queue of execution data for repeatable lists
  		queue = [],

  		// Index of currently firing callback (modified by add/remove as needed)
  		firingIndex = -1,

  		// Fire callbacks
  		fire = function() {

  			// Enforce single-firing
  			locked = locked || options.once;

  			// Execute callbacks for all pending executions,
  			// respecting firingIndex overrides and runtime changes
  			fired = firing = true;
  			for ( ; queue.length; firingIndex = -1 ) {
  				memory = queue.shift();
  				while ( ++firingIndex < list.length ) {

  					// Run callback and check for early termination
  					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
  						options.stopOnFalse ) {

  						// Jump to end and forget the data so .add doesn't re-fire
  						firingIndex = list.length;
  						memory = false;
  					}
  				}
  			}

  			// Forget the data if we're done with it
  			if ( !options.memory ) {
  				memory = false;
  			}

  			firing = false;

  			// Clean up if we're done firing for good
  			if ( locked ) {

  				// Keep an empty list if we have data for future add calls
  				if ( memory ) {
  					list = [];

  				// Otherwise, this object is spent
  				} else {
  					list = "";
  				}
  			}
  		},

  		// Actual Callbacks object
  		self = {

  			// Add a callback or a collection of callbacks to the list
  			add: function() {
  				if ( list ) {

  					// If we have memory from a past run, we should fire after adding
  					if ( memory && !firing ) {
  						firingIndex = list.length - 1;
  						queue.push( memory );
  					}

  					( function add( args ) {
  						jQuery.each( args, function( _, arg ) {
  							if ( isFunction( arg ) ) {
  								if ( !options.unique || !self.has( arg ) ) {
  									list.push( arg );
  								}
  							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

  								// Inspect recursively
  								add( arg );
  							}
  						} );
  					} )( arguments );

  					if ( memory && !firing ) {
  						fire();
  					}
  				}
  				return this;
  			},

  			// Remove a callback from the list
  			remove: function() {
  				jQuery.each( arguments, function( _, arg ) {
  					var index;
  					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
  						list.splice( index, 1 );

  						// Handle firing indexes
  						if ( index <= firingIndex ) {
  							firingIndex--;
  						}
  					}
  				} );
  				return this;
  			},

  			// Check if a given callback is in the list.
  			// If no argument is given, return whether or not list has callbacks attached.
  			has: function( fn ) {
  				return fn ?
  					jQuery.inArray( fn, list ) > -1 :
  					list.length > 0;
  			},

  			// Remove all callbacks from the list
  			empty: function() {
  				if ( list ) {
  					list = [];
  				}
  				return this;
  			},

  			// Disable .fire and .add
  			// Abort any current/pending executions
  			// Clear all callbacks and values
  			disable: function() {
  				locked = queue = [];
  				list = memory = "";
  				return this;
  			},
  			disabled: function() {
  				return !list;
  			},

  			// Disable .fire
  			// Also disable .add unless we have memory (since it would have no effect)
  			// Abort any pending executions
  			lock: function() {
  				locked = queue = [];
  				if ( !memory && !firing ) {
  					list = memory = "";
  				}
  				return this;
  			},
  			locked: function() {
  				return !!locked;
  			},

  			// Call all callbacks with the given context and arguments
  			fireWith: function( context, args ) {
  				if ( !locked ) {
  					args = args || [];
  					args = [ context, args.slice ? args.slice() : args ];
  					queue.push( args );
  					if ( !firing ) {
  						fire();
  					}
  				}
  				return this;
  			},

  			// Call all the callbacks with the given arguments
  			fire: function() {
  				self.fireWith( this, arguments );
  				return this;
  			},

  			// To know if the callbacks have already been called at least once
  			fired: function() {
  				return !!fired;
  			}
  		};

  	return self;
  };


  function Identity( v ) {
  	return v;
  }
  function Thrower( ex ) {
  	throw ex;
  }

  function adoptValue( value, resolve, reject, noValue ) {
  	var method;

  	try {

  		// Check for promise aspect first to privilege synchronous behavior
  		if ( value && isFunction( ( method = value.promise ) ) ) {
  			method.call( value ).done( resolve ).fail( reject );

  		// Other thenables
  		} else if ( value && isFunction( ( method = value.then ) ) ) {
  			method.call( value, resolve, reject );

  		// Other non-thenables
  		} else {

  			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
  			// * false: [ value ].slice( 0 ) => resolve( value )
  			// * true: [ value ].slice( 1 ) => resolve()
  			resolve.apply( undefined, [ value ].slice( noValue ) );
  		}

  	// For Promises/A+, convert exceptions into rejections
  	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
  	// Deferred#then to conditionally suppress rejection.
  	} catch ( value ) {

  		// Support: Android 4.0 only
  		// Strict mode functions invoked without .call/.apply get global-object context
  		reject.apply( undefined, [ value ] );
  	}
  }

  jQuery.extend( {

  	Deferred: function( func ) {
  		var tuples = [

  				// action, add listener, callbacks,
  				// ... .then handlers, argument index, [final state]
  				[ "notify", "progress", jQuery.Callbacks( "memory" ),
  					jQuery.Callbacks( "memory" ), 2 ],
  				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
  					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
  				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
  					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
  			],
  			state = "pending",
  			promise = {
  				state: function() {
  					return state;
  				},
  				always: function() {
  					deferred.done( arguments ).fail( arguments );
  					return this;
  				},
  				"catch": function( fn ) {
  					return promise.then( null, fn );
  				},

  				// Keep pipe for back-compat
  				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
  					var fns = arguments;

  					return jQuery.Deferred( function( newDefer ) {
  						jQuery.each( tuples, function( _i, tuple ) {

  							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
  							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

  							// deferred.progress(function() { bind to newDefer or newDefer.notify })
  							// deferred.done(function() { bind to newDefer or newDefer.resolve })
  							// deferred.fail(function() { bind to newDefer or newDefer.reject })
  							deferred[ tuple[ 1 ] ]( function() {
  								var returned = fn && fn.apply( this, arguments );
  								if ( returned && isFunction( returned.promise ) ) {
  									returned.promise()
  										.progress( newDefer.notify )
  										.done( newDefer.resolve )
  										.fail( newDefer.reject );
  								} else {
  									newDefer[ tuple[ 0 ] + "With" ](
  										this,
  										fn ? [ returned ] : arguments
  									);
  								}
  							} );
  						} );
  						fns = null;
  					} ).promise();
  				},
  				then: function( onFulfilled, onRejected, onProgress ) {
  					var maxDepth = 0;
  					function resolve( depth, deferred, handler, special ) {
  						return function() {
  							var that = this,
  								args = arguments,
  								mightThrow = function() {
  									var returned, then;

  									// Support: Promises/A+ section 2.3.3.3.3
  									// https://promisesaplus.com/#point-59
  									// Ignore double-resolution attempts
  									if ( depth < maxDepth ) {
  										return;
  									}

  									returned = handler.apply( that, args );

  									// Support: Promises/A+ section 2.3.1
  									// https://promisesaplus.com/#point-48
  									if ( returned === deferred.promise() ) {
  										throw new TypeError( "Thenable self-resolution" );
  									}

  									// Support: Promises/A+ sections 2.3.3.1, 3.5
  									// https://promisesaplus.com/#point-54
  									// https://promisesaplus.com/#point-75
  									// Retrieve `then` only once
  									then = returned &&

  										// Support: Promises/A+ section 2.3.4
  										// https://promisesaplus.com/#point-64
  										// Only check objects and functions for thenability
  										( typeof returned === "object" ||
  											typeof returned === "function" ) &&
  										returned.then;

  									// Handle a returned thenable
  									if ( isFunction( then ) ) {

  										// Special processors (notify) just wait for resolution
  										if ( special ) {
  											then.call(
  												returned,
  												resolve( maxDepth, deferred, Identity, special ),
  												resolve( maxDepth, deferred, Thrower, special )
  											);

  										// Normal processors (resolve) also hook into progress
  										} else {

  											// ...and disregard older resolution values
  											maxDepth++;

  											then.call(
  												returned,
  												resolve( maxDepth, deferred, Identity, special ),
  												resolve( maxDepth, deferred, Thrower, special ),
  												resolve( maxDepth, deferred, Identity,
  													deferred.notifyWith )
  											);
  										}

  									// Handle all other returned values
  									} else {

  										// Only substitute handlers pass on context
  										// and multiple values (non-spec behavior)
  										if ( handler !== Identity ) {
  											that = undefined;
  											args = [ returned ];
  										}

  										// Process the value(s)
  										// Default process is resolve
  										( special || deferred.resolveWith )( that, args );
  									}
  								},

  								// Only normal processors (resolve) catch and reject exceptions
  								process = special ?
  									mightThrow :
  									function() {
  										try {
  											mightThrow();
  										} catch ( e ) {

  											if ( jQuery.Deferred.exceptionHook ) {
  												jQuery.Deferred.exceptionHook( e,
  													process.error );
  											}

  											// Support: Promises/A+ section 2.3.3.3.4.1
  											// https://promisesaplus.com/#point-61
  											// Ignore post-resolution exceptions
  											if ( depth + 1 >= maxDepth ) {

  												// Only substitute handlers pass on context
  												// and multiple values (non-spec behavior)
  												if ( handler !== Thrower ) {
  													that = undefined;
  													args = [ e ];
  												}

  												deferred.rejectWith( that, args );
  											}
  										}
  									};

  							// Support: Promises/A+ section 2.3.3.3.1
  							// https://promisesaplus.com/#point-57
  							// Re-resolve promises immediately to dodge false rejection from
  							// subsequent errors
  							if ( depth ) {
  								process();
  							} else {

  								// Call an optional hook to record the error, in case of exception
  								// since it's otherwise lost when execution goes async
  								if ( jQuery.Deferred.getErrorHook ) {
  									process.error = jQuery.Deferred.getErrorHook();

  								// The deprecated alias of the above. While the name suggests
  								// returning the stack, not an error instance, jQuery just passes
  								// it directly to `console.warn` so both will work; an instance
  								// just better cooperates with source maps.
  								} else if ( jQuery.Deferred.getStackHook ) {
  									process.error = jQuery.Deferred.getStackHook();
  								}
  								window.setTimeout( process );
  							}
  						};
  					}

  					return jQuery.Deferred( function( newDefer ) {

  						// progress_handlers.add( ... )
  						tuples[ 0 ][ 3 ].add(
  							resolve(
  								0,
  								newDefer,
  								isFunction( onProgress ) ?
  									onProgress :
  									Identity,
  								newDefer.notifyWith
  							)
  						);

  						// fulfilled_handlers.add( ... )
  						tuples[ 1 ][ 3 ].add(
  							resolve(
  								0,
  								newDefer,
  								isFunction( onFulfilled ) ?
  									onFulfilled :
  									Identity
  							)
  						);

  						// rejected_handlers.add( ... )
  						tuples[ 2 ][ 3 ].add(
  							resolve(
  								0,
  								newDefer,
  								isFunction( onRejected ) ?
  									onRejected :
  									Thrower
  							)
  						);
  					} ).promise();
  				},

  				// Get a promise for this deferred
  				// If obj is provided, the promise aspect is added to the object
  				promise: function( obj ) {
  					return obj != null ? jQuery.extend( obj, promise ) : promise;
  				}
  			},
  			deferred = {};

  		// Add list-specific methods
  		jQuery.each( tuples, function( i, tuple ) {
  			var list = tuple[ 2 ],
  				stateString = tuple[ 5 ];

  			// promise.progress = list.add
  			// promise.done = list.add
  			// promise.fail = list.add
  			promise[ tuple[ 1 ] ] = list.add;

  			// Handle state
  			if ( stateString ) {
  				list.add(
  					function() {

  						// state = "resolved" (i.e., fulfilled)
  						// state = "rejected"
  						state = stateString;
  					},

  					// rejected_callbacks.disable
  					// fulfilled_callbacks.disable
  					tuples[ 3 - i ][ 2 ].disable,

  					// rejected_handlers.disable
  					// fulfilled_handlers.disable
  					tuples[ 3 - i ][ 3 ].disable,

  					// progress_callbacks.lock
  					tuples[ 0 ][ 2 ].lock,

  					// progress_handlers.lock
  					tuples[ 0 ][ 3 ].lock
  				);
  			}

  			// progress_handlers.fire
  			// fulfilled_handlers.fire
  			// rejected_handlers.fire
  			list.add( tuple[ 3 ].fire );

  			// deferred.notify = function() { deferred.notifyWith(...) }
  			// deferred.resolve = function() { deferred.resolveWith(...) }
  			// deferred.reject = function() { deferred.rejectWith(...) }
  			deferred[ tuple[ 0 ] ] = function() {
  				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
  				return this;
  			};

  			// deferred.notifyWith = list.fireWith
  			// deferred.resolveWith = list.fireWith
  			// deferred.rejectWith = list.fireWith
  			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
  		} );

  		// Make the deferred a promise
  		promise.promise( deferred );

  		// Call given func if any
  		if ( func ) {
  			func.call( deferred, deferred );
  		}

  		// All done!
  		return deferred;
  	},

  	// Deferred helper
  	when: function( singleValue ) {
  		var

  			// count of uncompleted subordinates
  			remaining = arguments.length,

  			// count of unprocessed arguments
  			i = remaining,

  			// subordinate fulfillment data
  			resolveContexts = Array( i ),
  			resolveValues = slice.call( arguments ),

  			// the primary Deferred
  			primary = jQuery.Deferred(),

  			// subordinate callback factory
  			updateFunc = function( i ) {
  				return function( value ) {
  					resolveContexts[ i ] = this;
  					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
  					if ( !( --remaining ) ) {
  						primary.resolveWith( resolveContexts, resolveValues );
  					}
  				};
  			};

  		// Single- and empty arguments are adopted like Promise.resolve
  		if ( remaining <= 1 ) {
  			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
  				!remaining );

  			// Use .then() to unwrap secondary thenables (cf. gh-3000)
  			if ( primary.state() === "pending" ||
  				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

  				return primary.then();
  			}
  		}

  		// Multiple arguments are aggregated like Promise.all array elements
  		while ( i-- ) {
  			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
  		}

  		return primary.promise();
  	}
  } );


  // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.
  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  // If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
  // captured before the async barrier to get the original error cause
  // which may otherwise be hidden.
  jQuery.Deferred.exceptionHook = function( error, asyncError ) {

  	// Support: IE 8 - 9 only
  	// Console exists when dev tools are open, which can happen at any time
  	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
  		window.console.warn( "jQuery.Deferred exception: " + error.message,
  			error.stack, asyncError );
  	}
  };




  jQuery.readyException = function( error ) {
  	window.setTimeout( function() {
  		throw error;
  	} );
  };




  // The deferred used on DOM ready
  var readyList = jQuery.Deferred();

  jQuery.fn.ready = function( fn ) {

  	readyList
  		.then( fn )

  		// Wrap jQuery.readyException in a function so that the lookup
  		// happens at the time of error handling instead of callback
  		// registration.
  		.catch( function( error ) {
  			jQuery.readyException( error );
  		} );

  	return this;
  };

  jQuery.extend( {

  	// Is the DOM ready to be used? Set to true once it occurs.
  	isReady: false,

  	// A counter to track how many items to wait for before
  	// the ready event fires. See trac-6781
  	readyWait: 1,

  	// Handle when the DOM is ready
  	ready: function( wait ) {

  		// Abort if there are pending holds or we're already ready
  		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
  			return;
  		}

  		// Remember that the DOM is ready
  		jQuery.isReady = true;

  		// If a normal DOM Ready event fired, decrement, and wait if need be
  		if ( wait !== true && --jQuery.readyWait > 0 ) {
  			return;
  		}

  		// If there are functions bound, to execute
  		readyList.resolveWith( document, [ jQuery ] );
  	}
  } );

  jQuery.ready.then = readyList.then;

  // The ready event handler and self cleanup method
  function completed() {
  	document.removeEventListener( "DOMContentLoaded", completed );
  	window.removeEventListener( "load", completed );
  	jQuery.ready();
  }

  // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon
  if ( document.readyState === "complete" ||
  	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

  	// Handle it asynchronously to allow scripts the opportunity to delay ready
  	window.setTimeout( jQuery.ready );

  } else {

  	// Use the handy event callback
  	document.addEventListener( "DOMContentLoaded", completed );

  	// A fallback to window.onload, that will always work
  	window.addEventListener( "load", completed );
  }




  // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function
  var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
  	var i = 0,
  		len = elems.length,
  		bulk = key == null;

  	// Sets many values
  	if ( toType( key ) === "object" ) {
  		chainable = true;
  		for ( i in key ) {
  			access( elems, fn, i, key[ i ], true, emptyGet, raw );
  		}

  	// Sets one value
  	} else if ( value !== undefined ) {
  		chainable = true;

  		if ( !isFunction( value ) ) {
  			raw = true;
  		}

  		if ( bulk ) {

  			// Bulk operations run against the entire set
  			if ( raw ) {
  				fn.call( elems, value );
  				fn = null;

  			// ...except when executing function values
  			} else {
  				bulk = fn;
  				fn = function( elem, _key, value ) {
  					return bulk.call( jQuery( elem ), value );
  				};
  			}
  		}

  		if ( fn ) {
  			for ( ; i < len; i++ ) {
  				fn(
  					elems[ i ], key, raw ?
  						value :
  						value.call( elems[ i ], i, fn( elems[ i ], key ) )
  				);
  			}
  		}
  	}

  	if ( chainable ) {
  		return elems;
  	}

  	// Gets
  	if ( bulk ) {
  		return fn.call( elems );
  	}

  	return len ? fn( elems[ 0 ], key ) : emptyGet;
  };


  // Matches dashed string for camelizing
  var rmsPrefix = /^-ms-/,
  	rdashAlpha = /-([a-z])/g;

  // Used by camelCase as callback to replace()
  function fcamelCase( _all, letter ) {
  	return letter.toUpperCase();
  }

  // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (trac-9572)
  function camelCase( string ) {
  	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  }
  var acceptData = function( owner ) {

  	// Accepts only:
  	//  - Node
  	//    - Node.ELEMENT_NODE
  	//    - Node.DOCUMENT_NODE
  	//  - Object
  	//    - Any
  	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
  };




  function Data() {
  	this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;

  Data.prototype = {

  	cache: function( owner ) {

  		// Check if the owner object already has a cache
  		var value = owner[ this.expando ];

  		// If not, create one
  		if ( !value ) {
  			value = {};

  			// We can accept data for non-element nodes in modern browsers,
  			// but we should not, see trac-8335.
  			// Always return an empty object.
  			if ( acceptData( owner ) ) {

  				// If it is a node unlikely to be stringify-ed or looped over
  				// use plain assignment
  				if ( owner.nodeType ) {
  					owner[ this.expando ] = value;

  				// Otherwise secure it in a non-enumerable property
  				// configurable must be true to allow the property to be
  				// deleted when data is removed
  				} else {
  					Object.defineProperty( owner, this.expando, {
  						value: value,
  						configurable: true
  					} );
  				}
  			}
  		}

  		return value;
  	},
  	set: function( owner, data, value ) {
  		var prop,
  			cache = this.cache( owner );

  		// Handle: [ owner, key, value ] args
  		// Always use camelCase key (gh-2257)
  		if ( typeof data === "string" ) {
  			cache[ camelCase( data ) ] = value;

  		// Handle: [ owner, { properties } ] args
  		} else {

  			// Copy the properties one-by-one to the cache object
  			for ( prop in data ) {
  				cache[ camelCase( prop ) ] = data[ prop ];
  			}
  		}
  		return cache;
  	},
  	get: function( owner, key ) {
  		return key === undefined ?
  			this.cache( owner ) :

  			// Always use camelCase key (gh-2257)
  			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
  	},
  	access: function( owner, key, value ) {

  		// In cases where either:
  		//
  		//   1. No key was specified
  		//   2. A string key was specified, but no value provided
  		//
  		// Take the "read" path and allow the get method to determine
  		// which value to return, respectively either:
  		//
  		//   1. The entire cache object
  		//   2. The data stored at the key
  		//
  		if ( key === undefined ||
  				( ( key && typeof key === "string" ) && value === undefined ) ) {

  			return this.get( owner, key );
  		}

  		// When the key is not a string, or both a key and value
  		// are specified, set or extend (existing objects) with either:
  		//
  		//   1. An object of properties
  		//   2. A key and value
  		//
  		this.set( owner, key, value );

  		// Since the "set" path can have two possible entry points
  		// return the expected data based on which path was taken[*]
  		return value !== undefined ? value : key;
  	},
  	remove: function( owner, key ) {
  		var i,
  			cache = owner[ this.expando ];

  		if ( cache === undefined ) {
  			return;
  		}

  		if ( key !== undefined ) {

  			// Support array or space separated string of keys
  			if ( Array.isArray( key ) ) {

  				// If key is an array of keys...
  				// We always set camelCase keys, so remove that.
  				key = key.map( camelCase );
  			} else {
  				key = camelCase( key );

  				// If a key with the spaces exists, use it.
  				// Otherwise, create an array by matching non-whitespace
  				key = key in cache ?
  					[ key ] :
  					( key.match( rnothtmlwhite ) || [] );
  			}

  			i = key.length;

  			while ( i-- ) {
  				delete cache[ key[ i ] ];
  			}
  		}

  		// Remove the expando if there's no more data
  		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

  			// Support: Chrome <=35 - 45
  			// Webkit & Blink performance suffers when deleting properties
  			// from DOM nodes, so set to undefined instead
  			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
  			if ( owner.nodeType ) {
  				owner[ this.expando ] = undefined;
  			} else {
  				delete owner[ this.expando ];
  			}
  		}
  	},
  	hasData: function( owner ) {
  		var cache = owner[ this.expando ];
  		return cache !== undefined && !jQuery.isEmptyObject( cache );
  	}
  };
  var dataPriv = new Data();

  var dataUser = new Data();



  //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
  	rmultiDash = /[A-Z]/g;

  function getData( data ) {
  	if ( data === "true" ) {
  		return true;
  	}

  	if ( data === "false" ) {
  		return false;
  	}

  	if ( data === "null" ) {
  		return null;
  	}

  	// Only convert to a number if it doesn't change the string
  	if ( data === +data + "" ) {
  		return +data;
  	}

  	if ( rbrace.test( data ) ) {
  		return JSON.parse( data );
  	}

  	return data;
  }

  function dataAttr( elem, key, data ) {
  	var name;

  	// If nothing was found internally, try to fetch any
  	// data from the HTML5 data-* attribute
  	if ( data === undefined && elem.nodeType === 1 ) {
  		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
  		data = elem.getAttribute( name );

  		if ( typeof data === "string" ) {
  			try {
  				data = getData( data );
  			} catch ( e ) {}

  			// Make sure we set the data so it isn't changed later
  			dataUser.set( elem, key, data );
  		} else {
  			data = undefined;
  		}
  	}
  	return data;
  }

  jQuery.extend( {
  	hasData: function( elem ) {
  		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
  	},

  	data: function( elem, name, data ) {
  		return dataUser.access( elem, name, data );
  	},

  	removeData: function( elem, name ) {
  		dataUser.remove( elem, name );
  	},

  	// TODO: Now that all calls to _data and _removeData have been replaced
  	// with direct calls to dataPriv methods, these can be deprecated.
  	_data: function( elem, name, data ) {
  		return dataPriv.access( elem, name, data );
  	},

  	_removeData: function( elem, name ) {
  		dataPriv.remove( elem, name );
  	}
  } );

  jQuery.fn.extend( {
  	data: function( key, value ) {
  		var i, name, data,
  			elem = this[ 0 ],
  			attrs = elem && elem.attributes;

  		// Gets all values
  		if ( key === undefined ) {
  			if ( this.length ) {
  				data = dataUser.get( elem );

  				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
  					i = attrs.length;
  					while ( i-- ) {

  						// Support: IE 11 only
  						// The attrs elements can be null (trac-14894)
  						if ( attrs[ i ] ) {
  							name = attrs[ i ].name;
  							if ( name.indexOf( "data-" ) === 0 ) {
  								name = camelCase( name.slice( 5 ) );
  								dataAttr( elem, name, data[ name ] );
  							}
  						}
  					}
  					dataPriv.set( elem, "hasDataAttrs", true );
  				}
  			}

  			return data;
  		}

  		// Sets multiple values
  		if ( typeof key === "object" ) {
  			return this.each( function() {
  				dataUser.set( this, key );
  			} );
  		}

  		return access( this, function( value ) {
  			var data;

  			// The calling jQuery object (element matches) is not empty
  			// (and therefore has an element appears at this[ 0 ]) and the
  			// `value` parameter was not undefined. An empty jQuery object
  			// will result in `undefined` for elem = this[ 0 ] which will
  			// throw an exception if an attempt to read a data cache is made.
  			if ( elem && value === undefined ) {

  				// Attempt to get data from the cache
  				// The key will always be camelCased in Data
  				data = dataUser.get( elem, key );
  				if ( data !== undefined ) {
  					return data;
  				}

  				// Attempt to "discover" the data in
  				// HTML5 custom data-* attrs
  				data = dataAttr( elem, key );
  				if ( data !== undefined ) {
  					return data;
  				}

  				// We tried really hard, but the data doesn't exist.
  				return;
  			}

  			// Set the data...
  			this.each( function() {

  				// We always store the camelCased key
  				dataUser.set( this, key, value );
  			} );
  		}, null, value, arguments.length > 1, null, true );
  	},

  	removeData: function( key ) {
  		return this.each( function() {
  			dataUser.remove( this, key );
  		} );
  	}
  } );


  jQuery.extend( {
  	queue: function( elem, type, data ) {
  		var queue;

  		if ( elem ) {
  			type = ( type || "fx" ) + "queue";
  			queue = dataPriv.get( elem, type );

  			// Speed up dequeue by getting out quickly if this is just a lookup
  			if ( data ) {
  				if ( !queue || Array.isArray( data ) ) {
  					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
  				} else {
  					queue.push( data );
  				}
  			}
  			return queue || [];
  		}
  	},

  	dequeue: function( elem, type ) {
  		type = type || "fx";

  		var queue = jQuery.queue( elem, type ),
  			startLength = queue.length,
  			fn = queue.shift(),
  			hooks = jQuery._queueHooks( elem, type ),
  			next = function() {
  				jQuery.dequeue( elem, type );
  			};

  		// If the fx queue is dequeued, always remove the progress sentinel
  		if ( fn === "inprogress" ) {
  			fn = queue.shift();
  			startLength--;
  		}

  		if ( fn ) {

  			// Add a progress sentinel to prevent the fx queue from being
  			// automatically dequeued
  			if ( type === "fx" ) {
  				queue.unshift( "inprogress" );
  			}

  			// Clear up the last queue stop function
  			delete hooks.stop;
  			fn.call( elem, next, hooks );
  		}

  		if ( !startLength && hooks ) {
  			hooks.empty.fire();
  		}
  	},

  	// Not public - generate a queueHooks object, or return the current one
  	_queueHooks: function( elem, type ) {
  		var key = type + "queueHooks";
  		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
  			empty: jQuery.Callbacks( "once memory" ).add( function() {
  				dataPriv.remove( elem, [ type + "queue", key ] );
  			} )
  		} );
  	}
  } );

  jQuery.fn.extend( {
  	queue: function( type, data ) {
  		var setter = 2;

  		if ( typeof type !== "string" ) {
  			data = type;
  			type = "fx";
  			setter--;
  		}

  		if ( arguments.length < setter ) {
  			return jQuery.queue( this[ 0 ], type );
  		}

  		return data === undefined ?
  			this :
  			this.each( function() {
  				var queue = jQuery.queue( this, type, data );

  				// Ensure a hooks for this queue
  				jQuery._queueHooks( this, type );

  				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
  					jQuery.dequeue( this, type );
  				}
  			} );
  	},
  	dequeue: function( type ) {
  		return this.each( function() {
  			jQuery.dequeue( this, type );
  		} );
  	},
  	clearQueue: function( type ) {
  		return this.queue( type || "fx", [] );
  	},

  	// Get a promise resolved when queues of a certain type
  	// are emptied (fx is the type by default)
  	promise: function( type, obj ) {
  		var tmp,
  			count = 1,
  			defer = jQuery.Deferred(),
  			elements = this,
  			i = this.length,
  			resolve = function() {
  				if ( !( --count ) ) {
  					defer.resolveWith( elements, [ elements ] );
  				}
  			};

  		if ( typeof type !== "string" ) {
  			obj = type;
  			type = undefined;
  		}
  		type = type || "fx";

  		while ( i-- ) {
  			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
  			if ( tmp && tmp.empty ) {
  				count++;
  				tmp.empty.add( resolve );
  			}
  		}
  		resolve();
  		return defer.promise( obj );
  	}
  } );
  var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

  var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


  var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

  var documentElement = document.documentElement;



  	var isAttached = function( elem ) {
  			return jQuery.contains( elem.ownerDocument, elem );
  		},
  		composed = { composed: true };

  	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
  	// Check attachment across shadow DOM boundaries when possible (gh-3504)
  	// Support: iOS 10.0-10.2 only
  	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
  	// leading to errors. We need to check for `getRootNode`.
  	if ( documentElement.getRootNode ) {
  		isAttached = function( elem ) {
  			return jQuery.contains( elem.ownerDocument, elem ) ||
  				elem.getRootNode( composed ) === elem.ownerDocument;
  		};
  	}
  var isHiddenWithinTree = function( elem, el ) {

  		// isHiddenWithinTree might be called from jQuery#filter function;
  		// in that case, element will be second argument
  		elem = elem;

  		// Inline style trumps all
  		return elem.style.display === "none" ||
  			elem.style.display === "" &&

  			// Otherwise, check computed style
  			// Support: Firefox <=43 - 45
  			// Disconnected elements can have computed display: none, so first confirm that elem is
  			// in the document.
  			isAttached( elem ) &&

  			jQuery.css( elem, "display" ) === "none";
  	};



  function adjustCSS( elem, prop, valueParts, tween ) {
  	var adjusted, scale,
  		maxIterations = 20,
  		currentValue = function() {
  				return jQuery.css( elem, prop, "" );
  			},
  		initial = currentValue(),
  		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

  		// Starting value computation is required for potential unit mismatches
  		initialInUnit = elem.nodeType &&
  			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
  			rcssNum.exec( jQuery.css( elem, prop ) );

  	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

  		// Support: Firefox <=54
  		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
  		initial = initial / 2;

  		// Trust units reported by jQuery.css
  		unit = unit || initialInUnit[ 3 ];

  		// Iteratively approximate from a nonzero starting point
  		initialInUnit = +initial || 1;

  		while ( maxIterations-- ) {

  			// Evaluate and update our best guess (doubling guesses that zero out).
  			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
  			jQuery.style( elem, prop, initialInUnit + unit );
  			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
  				maxIterations = 0;
  			}
  			initialInUnit = initialInUnit / scale;

  		}

  		initialInUnit = initialInUnit * 2;
  		jQuery.style( elem, prop, initialInUnit + unit );

  		// Make sure we update the tween properties later on
  		valueParts = valueParts || [];
  	}

  	if ( valueParts ) {
  		initialInUnit = +initialInUnit || +initial || 0;

  		// Apply relative offset (+=/-=) if specified
  		adjusted = valueParts[ 1 ] ?
  			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
  			+valueParts[ 2 ];
  	}
  	return adjusted;
  }


  var defaultDisplayMap = {};

  function getDefaultDisplay( elem ) {
  	var temp,
  		doc = elem.ownerDocument,
  		nodeName = elem.nodeName,
  		display = defaultDisplayMap[ nodeName ];

  	if ( display ) {
  		return display;
  	}

  	temp = doc.body.appendChild( doc.createElement( nodeName ) );
  	display = jQuery.css( temp, "display" );

  	temp.parentNode.removeChild( temp );

  	if ( display === "none" ) {
  		display = "block";
  	}
  	defaultDisplayMap[ nodeName ] = display;

  	return display;
  }

  function showHide( elements, show ) {
  	var display, elem,
  		values = [],
  		index = 0,
  		length = elements.length;

  	// Determine new display value for elements that need to change
  	for ( ; index < length; index++ ) {
  		elem = elements[ index ];
  		if ( !elem.style ) {
  			continue;
  		}

  		display = elem.style.display;
  		if ( show ) {

  			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
  			// check is required in this first loop unless we have a nonempty display value (either
  			// inline or about-to-be-restored)
  			if ( display === "none" ) {
  				values[ index ] = dataPriv.get( elem, "display" ) || null;
  				if ( !values[ index ] ) {
  					elem.style.display = "";
  				}
  			}
  			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
  				values[ index ] = getDefaultDisplay( elem );
  			}
  		} else {
  			if ( display !== "none" ) {
  				values[ index ] = "none";

  				// Remember what we're overwriting
  				dataPriv.set( elem, "display", display );
  			}
  		}
  	}

  	// Set the display of the elements in a second loop to avoid constant reflow
  	for ( index = 0; index < length; index++ ) {
  		if ( values[ index ] != null ) {
  			elements[ index ].style.display = values[ index ];
  		}
  	}

  	return elements;
  }

  jQuery.fn.extend( {
  	show: function() {
  		return showHide( this, true );
  	},
  	hide: function() {
  		return showHide( this );
  	},
  	toggle: function( state ) {
  		if ( typeof state === "boolean" ) {
  			return state ? this.show() : this.hide();
  		}

  		return this.each( function() {
  			if ( isHiddenWithinTree( this ) ) {
  				jQuery( this ).show();
  			} else {
  				jQuery( this ).hide();
  			}
  		} );
  	}
  } );
  var rcheckableType = ( /^(?:checkbox|radio)$/i );

  var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

  var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



  ( function() {
  	var fragment = document.createDocumentFragment(),
  		div = fragment.appendChild( document.createElement( "div" ) ),
  		input = document.createElement( "input" );

  	// Support: Android 4.0 - 4.3 only
  	// Check state lost if the name is set (trac-11217)
  	// Support: Windows Web Apps (WWA)
  	// `name` and `type` must use .setAttribute for WWA (trac-14901)
  	input.setAttribute( "type", "radio" );
  	input.setAttribute( "checked", "checked" );
  	input.setAttribute( "name", "t" );

  	div.appendChild( input );

  	// Support: Android <=4.1 only
  	// Older WebKit doesn't clone checked state correctly in fragments
  	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

  	// Support: IE <=11 only
  	// Make sure textarea (and checkbox) defaultValue is properly cloned
  	div.innerHTML = "<textarea>x</textarea>";
  	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

  	// Support: IE <=9 only
  	// IE <=9 replaces <option> tags with their contents when inserted outside of
  	// the select element.
  	div.innerHTML = "<option></option>";
  	support.option = !!div.lastChild;
  } )();


  // We have to close these tags to support XHTML (trac-13200)
  var wrapMap = {

  	// XHTML parsers do not magically insert elements in the
  	// same way that tag soup parsers do. So we cannot shorten
  	// this by omitting <tbody> or other required elements.
  	thead: [ 1, "<table>", "</table>" ],
  	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
  	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
  	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

  	_default: [ 0, "", "" ]
  };

  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;

  // Support: IE <=9 only
  if ( !support.option ) {
  	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
  }


  function getAll( context, tag ) {

  	// Support: IE <=9 - 11 only
  	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
  	var ret;

  	if ( typeof context.getElementsByTagName !== "undefined" ) {
  		ret = context.getElementsByTagName( tag || "*" );

  	} else if ( typeof context.querySelectorAll !== "undefined" ) {
  		ret = context.querySelectorAll( tag || "*" );

  	} else {
  		ret = [];
  	}

  	if ( tag === undefined || tag && nodeName( context, tag ) ) {
  		return jQuery.merge( [ context ], ret );
  	}

  	return ret;
  }


  // Mark scripts as having already been evaluated
  function setGlobalEval( elems, refElements ) {
  	var i = 0,
  		l = elems.length;

  	for ( ; i < l; i++ ) {
  		dataPriv.set(
  			elems[ i ],
  			"globalEval",
  			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
  		);
  	}
  }


  var rhtml = /<|&#?\w+;/;

  function buildFragment( elems, context, scripts, selection, ignored ) {
  	var elem, tmp, tag, wrap, attached, j,
  		fragment = context.createDocumentFragment(),
  		nodes = [],
  		i = 0,
  		l = elems.length;

  	for ( ; i < l; i++ ) {
  		elem = elems[ i ];

  		if ( elem || elem === 0 ) {

  			// Add nodes directly
  			if ( toType( elem ) === "object" ) {

  				// Support: Android <=4.0 only, PhantomJS 1 only
  				// push.apply(_, arraylike) throws on ancient WebKit
  				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

  			// Convert non-html into a text node
  			} else if ( !rhtml.test( elem ) ) {
  				nodes.push( context.createTextNode( elem ) );

  			// Convert html into DOM nodes
  			} else {
  				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

  				// Deserialize a standard representation
  				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
  				wrap = wrapMap[ tag ] || wrapMap._default;
  				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

  				// Descend through wrappers to the right content
  				j = wrap[ 0 ];
  				while ( j-- ) {
  					tmp = tmp.lastChild;
  				}

  				// Support: Android <=4.0 only, PhantomJS 1 only
  				// push.apply(_, arraylike) throws on ancient WebKit
  				jQuery.merge( nodes, tmp.childNodes );

  				// Remember the top-level container
  				tmp = fragment.firstChild;

  				// Ensure the created nodes are orphaned (trac-12392)
  				tmp.textContent = "";
  			}
  		}
  	}

  	// Remove wrapper from fragment
  	fragment.textContent = "";

  	i = 0;
  	while ( ( elem = nodes[ i++ ] ) ) {

  		// Skip elements already in the context collection (trac-4087)
  		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
  			if ( ignored ) {
  				ignored.push( elem );
  			}
  			continue;
  		}

  		attached = isAttached( elem );

  		// Append to fragment
  		tmp = getAll( fragment.appendChild( elem ), "script" );

  		// Preserve script evaluation history
  		if ( attached ) {
  			setGlobalEval( tmp );
  		}

  		// Capture executables
  		if ( scripts ) {
  			j = 0;
  			while ( ( elem = tmp[ j++ ] ) ) {
  				if ( rscriptType.test( elem.type || "" ) ) {
  					scripts.push( elem );
  				}
  			}
  		}
  	}

  	return fragment;
  }


  var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
  	return true;
  }

  function returnFalse() {
  	return false;
  }

  function on( elem, types, selector, data, fn, one ) {
  	var origFn, type;

  	// Types can be a map of types/handlers
  	if ( typeof types === "object" ) {

  		// ( types-Object, selector, data )
  		if ( typeof selector !== "string" ) {

  			// ( types-Object, data )
  			data = data || selector;
  			selector = undefined;
  		}
  		for ( type in types ) {
  			on( elem, type, selector, data, types[ type ], one );
  		}
  		return elem;
  	}

  	if ( data == null && fn == null ) {

  		// ( types, fn )
  		fn = selector;
  		data = selector = undefined;
  	} else if ( fn == null ) {
  		if ( typeof selector === "string" ) {

  			// ( types, selector, fn )
  			fn = data;
  			data = undefined;
  		} else {

  			// ( types, data, fn )
  			fn = data;
  			data = selector;
  			selector = undefined;
  		}
  	}
  	if ( fn === false ) {
  		fn = returnFalse;
  	} else if ( !fn ) {
  		return elem;
  	}

  	if ( one === 1 ) {
  		origFn = fn;
  		fn = function( event ) {

  			// Can use an empty set, since event contains the info
  			jQuery().off( event );
  			return origFn.apply( this, arguments );
  		};

  		// Use same guid so caller can remove using origFn
  		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
  	}
  	return elem.each( function() {
  		jQuery.event.add( this, types, fn, data, selector );
  	} );
  }

  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */
  jQuery.event = {

  	global: {},

  	add: function( elem, types, handler, data, selector ) {

  		var handleObjIn, eventHandle, tmp,
  			events, t, handleObj,
  			special, handlers, type, namespaces, origType,
  			elemData = dataPriv.get( elem );

  		// Only attach events to objects that accept data
  		if ( !acceptData( elem ) ) {
  			return;
  		}

  		// Caller can pass in an object of custom data in lieu of the handler
  		if ( handler.handler ) {
  			handleObjIn = handler;
  			handler = handleObjIn.handler;
  			selector = handleObjIn.selector;
  		}

  		// Ensure that invalid selectors throw exceptions at attach time
  		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
  		if ( selector ) {
  			jQuery.find.matchesSelector( documentElement, selector );
  		}

  		// Make sure that the handler has a unique ID, used to find/remove it later
  		if ( !handler.guid ) {
  			handler.guid = jQuery.guid++;
  		}

  		// Init the element's event structure and main handler, if this is the first
  		if ( !( events = elemData.events ) ) {
  			events = elemData.events = Object.create( null );
  		}
  		if ( !( eventHandle = elemData.handle ) ) {
  			eventHandle = elemData.handle = function( e ) {

  				// Discard the second event of a jQuery.event.trigger() and
  				// when an event is called after a page has unloaded
  				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
  					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
  			};
  		}

  		// Handle multiple events separated by a space
  		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  		t = types.length;
  		while ( t-- ) {
  			tmp = rtypenamespace.exec( types[ t ] ) || [];
  			type = origType = tmp[ 1 ];
  			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  			// There *must* be a type, no attaching namespace-only handlers
  			if ( !type ) {
  				continue;
  			}

  			// If event changes its type, use the special event handlers for the changed type
  			special = jQuery.event.special[ type ] || {};

  			// If selector defined, determine special event api type, otherwise given type
  			type = ( selector ? special.delegateType : special.bindType ) || type;

  			// Update special based on newly reset type
  			special = jQuery.event.special[ type ] || {};

  			// handleObj is passed to all event handlers
  			handleObj = jQuery.extend( {
  				type: type,
  				origType: origType,
  				data: data,
  				handler: handler,
  				guid: handler.guid,
  				selector: selector,
  				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
  				namespace: namespaces.join( "." )
  			}, handleObjIn );

  			// Init the event handler queue if we're the first
  			if ( !( handlers = events[ type ] ) ) {
  				handlers = events[ type ] = [];
  				handlers.delegateCount = 0;

  				// Only use addEventListener if the special events handler returns false
  				if ( !special.setup ||
  					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

  					if ( elem.addEventListener ) {
  						elem.addEventListener( type, eventHandle );
  					}
  				}
  			}

  			if ( special.add ) {
  				special.add.call( elem, handleObj );

  				if ( !handleObj.handler.guid ) {
  					handleObj.handler.guid = handler.guid;
  				}
  			}

  			// Add to the element's handler list, delegates in front
  			if ( selector ) {
  				handlers.splice( handlers.delegateCount++, 0, handleObj );
  			} else {
  				handlers.push( handleObj );
  			}

  			// Keep track of which events have ever been used, for event optimization
  			jQuery.event.global[ type ] = true;
  		}

  	},

  	// Detach an event or set of events from an element
  	remove: function( elem, types, handler, selector, mappedTypes ) {

  		var j, origCount, tmp,
  			events, t, handleObj,
  			special, handlers, type, namespaces, origType,
  			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

  		if ( !elemData || !( events = elemData.events ) ) {
  			return;
  		}

  		// Once for each type.namespace in types; type may be omitted
  		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  		t = types.length;
  		while ( t-- ) {
  			tmp = rtypenamespace.exec( types[ t ] ) || [];
  			type = origType = tmp[ 1 ];
  			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  			// Unbind all events (on this namespace, if provided) for the element
  			if ( !type ) {
  				for ( type in events ) {
  					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
  				}
  				continue;
  			}

  			special = jQuery.event.special[ type ] || {};
  			type = ( selector ? special.delegateType : special.bindType ) || type;
  			handlers = events[ type ] || [];
  			tmp = tmp[ 2 ] &&
  				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

  			// Remove matching events
  			origCount = j = handlers.length;
  			while ( j-- ) {
  				handleObj = handlers[ j ];

  				if ( ( mappedTypes || origType === handleObj.origType ) &&
  					( !handler || handler.guid === handleObj.guid ) &&
  					( !tmp || tmp.test( handleObj.namespace ) ) &&
  					( !selector || selector === handleObj.selector ||
  						selector === "**" && handleObj.selector ) ) {
  					handlers.splice( j, 1 );

  					if ( handleObj.selector ) {
  						handlers.delegateCount--;
  					}
  					if ( special.remove ) {
  						special.remove.call( elem, handleObj );
  					}
  				}
  			}

  			// Remove generic event handler if we removed something and no more handlers exist
  			// (avoids potential for endless recursion during removal of special event handlers)
  			if ( origCount && !handlers.length ) {
  				if ( !special.teardown ||
  					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

  					jQuery.removeEvent( elem, type, elemData.handle );
  				}

  				delete events[ type ];
  			}
  		}

  		// Remove data and the expando if it's no longer used
  		if ( jQuery.isEmptyObject( events ) ) {
  			dataPriv.remove( elem, "handle events" );
  		}
  	},

  	dispatch: function( nativeEvent ) {

  		var i, j, ret, matched, handleObj, handlerQueue,
  			args = new Array( arguments.length ),

  			// Make a writable jQuery.Event from the native event object
  			event = jQuery.event.fix( nativeEvent ),

  			handlers = (
  				dataPriv.get( this, "events" ) || Object.create( null )
  			)[ event.type ] || [],
  			special = jQuery.event.special[ event.type ] || {};

  		// Use the fix-ed jQuery.Event rather than the (read-only) native event
  		args[ 0 ] = event;

  		for ( i = 1; i < arguments.length; i++ ) {
  			args[ i ] = arguments[ i ];
  		}

  		event.delegateTarget = this;

  		// Call the preDispatch hook for the mapped type, and let it bail if desired
  		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
  			return;
  		}

  		// Determine handlers
  		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

  		// Run delegates first; they may want to stop propagation beneath us
  		i = 0;
  		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
  			event.currentTarget = matched.elem;

  			j = 0;
  			while ( ( handleObj = matched.handlers[ j++ ] ) &&
  				!event.isImmediatePropagationStopped() ) {

  				// If the event is namespaced, then each handler is only invoked if it is
  				// specially universal or its namespaces are a superset of the event's.
  				if ( !event.rnamespace || handleObj.namespace === false ||
  					event.rnamespace.test( handleObj.namespace ) ) {

  					event.handleObj = handleObj;
  					event.data = handleObj.data;

  					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
  						handleObj.handler ).apply( matched.elem, args );

  					if ( ret !== undefined ) {
  						if ( ( event.result = ret ) === false ) {
  							event.preventDefault();
  							event.stopPropagation();
  						}
  					}
  				}
  			}
  		}

  		// Call the postDispatch hook for the mapped type
  		if ( special.postDispatch ) {
  			special.postDispatch.call( this, event );
  		}

  		return event.result;
  	},

  	handlers: function( event, handlers ) {
  		var i, handleObj, sel, matchedHandlers, matchedSelectors,
  			handlerQueue = [],
  			delegateCount = handlers.delegateCount,
  			cur = event.target;

  		// Find delegate handlers
  		if ( delegateCount &&

  			// Support: IE <=9
  			// Black-hole SVG <use> instance trees (trac-13180)
  			cur.nodeType &&

  			// Support: Firefox <=42
  			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
  			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
  			// Support: IE 11 only
  			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
  			!( event.type === "click" && event.button >= 1 ) ) {

  			for ( ; cur !== this; cur = cur.parentNode || this ) {

  				// Don't check non-elements (trac-13208)
  				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
  				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
  					matchedHandlers = [];
  					matchedSelectors = {};
  					for ( i = 0; i < delegateCount; i++ ) {
  						handleObj = handlers[ i ];

  						// Don't conflict with Object.prototype properties (trac-13203)
  						sel = handleObj.selector + " ";

  						if ( matchedSelectors[ sel ] === undefined ) {
  							matchedSelectors[ sel ] = handleObj.needsContext ?
  								jQuery( sel, this ).index( cur ) > -1 :
  								jQuery.find( sel, this, null, [ cur ] ).length;
  						}
  						if ( matchedSelectors[ sel ] ) {
  							matchedHandlers.push( handleObj );
  						}
  					}
  					if ( matchedHandlers.length ) {
  						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
  					}
  				}
  			}
  		}

  		// Add the remaining (directly-bound) handlers
  		cur = this;
  		if ( delegateCount < handlers.length ) {
  			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
  		}

  		return handlerQueue;
  	},

  	addProp: function( name, hook ) {
  		Object.defineProperty( jQuery.Event.prototype, name, {
  			enumerable: true,
  			configurable: true,

  			get: isFunction( hook ) ?
  				function() {
  					if ( this.originalEvent ) {
  						return hook( this.originalEvent );
  					}
  				} :
  				function() {
  					if ( this.originalEvent ) {
  						return this.originalEvent[ name ];
  					}
  				},

  			set: function( value ) {
  				Object.defineProperty( this, name, {
  					enumerable: true,
  					configurable: true,
  					writable: true,
  					value: value
  				} );
  			}
  		} );
  	},

  	fix: function( originalEvent ) {
  		return originalEvent[ jQuery.expando ] ?
  			originalEvent :
  			new jQuery.Event( originalEvent );
  	},

  	special: {
  		load: {

  			// Prevent triggered image.load events from bubbling to window.load
  			noBubble: true
  		},
  		click: {

  			// Utilize native event to ensure correct state for checkable inputs
  			setup: function( data ) {

  				// For mutual compressibility with _default, replace `this` access with a local var.
  				// `|| data` is dead code meant only to preserve the variable through minification.
  				var el = this || data;

  				// Claim the first handler
  				if ( rcheckableType.test( el.type ) &&
  					el.click && nodeName( el, "input" ) ) {

  					// dataPriv.set( el, "click", ... )
  					leverageNative( el, "click", true );
  				}

  				// Return false to allow normal processing in the caller
  				return false;
  			},
  			trigger: function( data ) {

  				// For mutual compressibility with _default, replace `this` access with a local var.
  				// `|| data` is dead code meant only to preserve the variable through minification.
  				var el = this || data;

  				// Force setup before triggering a click
  				if ( rcheckableType.test( el.type ) &&
  					el.click && nodeName( el, "input" ) ) {

  					leverageNative( el, "click" );
  				}

  				// Return non-false to allow normal event-path propagation
  				return true;
  			},

  			// For cross-browser consistency, suppress native .click() on links
  			// Also prevent it if we're currently inside a leveraged native-event stack
  			_default: function( event ) {
  				var target = event.target;
  				return rcheckableType.test( target.type ) &&
  					target.click && nodeName( target, "input" ) &&
  					dataPriv.get( target, "click" ) ||
  					nodeName( target, "a" );
  			}
  		},

  		beforeunload: {
  			postDispatch: function( event ) {

  				// Support: Firefox 20+
  				// Firefox doesn't alert if the returnValue field is not set.
  				if ( event.result !== undefined && event.originalEvent ) {
  					event.originalEvent.returnValue = event.result;
  				}
  			}
  		}
  	}
  };

  // Ensure the presence of an event listener that handles manually-triggered
  // synthetic events by interrupting progress until reinvoked in response to
  // *native* events that it fires directly, ensuring that state changes have
  // already occurred before other listeners are invoked.
  function leverageNative( el, type, isSetup ) {

  	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
  	if ( !isSetup ) {
  		if ( dataPriv.get( el, type ) === undefined ) {
  			jQuery.event.add( el, type, returnTrue );
  		}
  		return;
  	}

  	// Register the controller as a special universal handler for all event namespaces
  	dataPriv.set( el, type, false );
  	jQuery.event.add( el, type, {
  		namespace: false,
  		handler: function( event ) {
  			var result,
  				saved = dataPriv.get( this, type );

  			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

  				// Interrupt processing of the outer synthetic .trigger()ed event
  				if ( !saved ) {

  					// Store arguments for use when handling the inner native event
  					// There will always be at least one argument (an event object), so this array
  					// will not be confused with a leftover capture object.
  					saved = slice.call( arguments );
  					dataPriv.set( this, type, saved );

  					// Trigger the native event and capture its result
  					this[ type ]();
  					result = dataPriv.get( this, type );
  					dataPriv.set( this, type, false );

  					if ( saved !== result ) {

  						// Cancel the outer synthetic event
  						event.stopImmediatePropagation();
  						event.preventDefault();

  						return result;
  					}

  				// If this is an inner synthetic event for an event with a bubbling surrogate
  				// (focus or blur), assume that the surrogate already propagated from triggering
  				// the native event and prevent that from happening again here.
  				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
  				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
  				// less bad than duplication.
  				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
  					event.stopPropagation();
  				}

  			// If this is a native event triggered above, everything is now in order
  			// Fire an inner synthetic event with the original arguments
  			} else if ( saved ) {

  				// ...and capture the result
  				dataPriv.set( this, type, jQuery.event.trigger(
  					saved[ 0 ],
  					saved.slice( 1 ),
  					this
  				) );

  				// Abort handling of the native event by all jQuery handlers while allowing
  				// native handlers on the same element to run. On target, this is achieved
  				// by stopping immediate propagation just on the jQuery event. However,
  				// the native event is re-wrapped by a jQuery one on each level of the
  				// propagation so the only way to stop it for jQuery is to stop it for
  				// everyone via native `stopPropagation()`. This is not a problem for
  				// focus/blur which don't bubble, but it does also stop click on checkboxes
  				// and radios. We accept this limitation.
  				event.stopPropagation();
  				event.isImmediatePropagationStopped = returnTrue;
  			}
  		}
  	} );
  }

  jQuery.removeEvent = function( elem, type, handle ) {

  	// This "if" is needed for plain objects
  	if ( elem.removeEventListener ) {
  		elem.removeEventListener( type, handle );
  	}
  };

  jQuery.Event = function( src, props ) {

  	// Allow instantiation without the 'new' keyword
  	if ( !( this instanceof jQuery.Event ) ) {
  		return new jQuery.Event( src, props );
  	}

  	// Event object
  	if ( src && src.type ) {
  		this.originalEvent = src;
  		this.type = src.type;

  		// Events bubbling up the document may have been marked as prevented
  		// by a handler lower down the tree; reflect the correct value.
  		this.isDefaultPrevented = src.defaultPrevented ||
  				src.defaultPrevented === undefined &&

  				// Support: Android <=2.3 only
  				src.returnValue === false ?
  			returnTrue :
  			returnFalse;

  		// Create target properties
  		// Support: Safari <=6 - 7 only
  		// Target should not be a text node (trac-504, trac-13143)
  		this.target = ( src.target && src.target.nodeType === 3 ) ?
  			src.target.parentNode :
  			src.target;

  		this.currentTarget = src.currentTarget;
  		this.relatedTarget = src.relatedTarget;

  	// Event type
  	} else {
  		this.type = src;
  	}

  	// Put explicitly provided properties onto the event object
  	if ( props ) {
  		jQuery.extend( this, props );
  	}

  	// Create a timestamp if incoming event doesn't have one
  	this.timeStamp = src && src.timeStamp || Date.now();

  	// Mark it as fixed
  	this[ jQuery.expando ] = true;
  };

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  jQuery.Event.prototype = {
  	constructor: jQuery.Event,
  	isDefaultPrevented: returnFalse,
  	isPropagationStopped: returnFalse,
  	isImmediatePropagationStopped: returnFalse,
  	isSimulated: false,

  	preventDefault: function() {
  		var e = this.originalEvent;

  		this.isDefaultPrevented = returnTrue;

  		if ( e && !this.isSimulated ) {
  			e.preventDefault();
  		}
  	},
  	stopPropagation: function() {
  		var e = this.originalEvent;

  		this.isPropagationStopped = returnTrue;

  		if ( e && !this.isSimulated ) {
  			e.stopPropagation();
  		}
  	},
  	stopImmediatePropagation: function() {
  		var e = this.originalEvent;

  		this.isImmediatePropagationStopped = returnTrue;

  		if ( e && !this.isSimulated ) {
  			e.stopImmediatePropagation();
  		}

  		this.stopPropagation();
  	}
  };

  // Includes all common event props including KeyEvent and MouseEvent specific props
  jQuery.each( {
  	altKey: true,
  	bubbles: true,
  	cancelable: true,
  	changedTouches: true,
  	ctrlKey: true,
  	detail: true,
  	eventPhase: true,
  	metaKey: true,
  	pageX: true,
  	pageY: true,
  	shiftKey: true,
  	view: true,
  	"char": true,
  	code: true,
  	charCode: true,
  	key: true,
  	keyCode: true,
  	button: true,
  	buttons: true,
  	clientX: true,
  	clientY: true,
  	offsetX: true,
  	offsetY: true,
  	pointerId: true,
  	pointerType: true,
  	screenX: true,
  	screenY: true,
  	targetTouches: true,
  	toElement: true,
  	touches: true,
  	which: true
  }, jQuery.event.addProp );

  jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

  	function focusMappedHandler( nativeEvent ) {
  		if ( document.documentMode ) {

  			// Support: IE 11+
  			// Attach a single focusin/focusout handler on the document while someone wants
  			// focus/blur. This is because the former are synchronous in IE while the latter
  			// are async. In other browsers, all those handlers are invoked synchronously.

  			// `handle` from private data would already wrap the event, but we need
  			// to change the `type` here.
  			var handle = dataPriv.get( this, "handle" ),
  				event = jQuery.event.fix( nativeEvent );
  			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
  			event.isSimulated = true;

  			// First, handle focusin/focusout
  			handle( nativeEvent );

  			// ...then, handle focus/blur
  			//
  			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
  			// invoking the handler at the lower level.
  			if ( event.target === event.currentTarget ) {

  				// The setup part calls `leverageNative`, which, in turn, calls
  				// `jQuery.event.add`, so event handle will already have been set
  				// by this point.
  				handle( event );
  			}
  		} else {

  			// For non-IE browsers, attach a single capturing handler on the document
  			// while someone wants focusin/focusout.
  			jQuery.event.simulate( delegateType, nativeEvent.target,
  				jQuery.event.fix( nativeEvent ) );
  		}
  	}

  	jQuery.event.special[ type ] = {

  		// Utilize native event if possible so blur/focus sequence is correct
  		setup: function() {

  			var attaches;

  			// Claim the first handler
  			// dataPriv.set( this, "focus", ... )
  			// dataPriv.set( this, "blur", ... )
  			leverageNative( this, type, true );

  			if ( document.documentMode ) {

  				// Support: IE 9 - 11+
  				// We use the same native handler for focusin & focus (and focusout & blur)
  				// so we need to coordinate setup & teardown parts between those events.
  				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
  				attaches = dataPriv.get( this, delegateType );
  				if ( !attaches ) {
  					this.addEventListener( delegateType, focusMappedHandler );
  				}
  				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
  			} else {

  				// Return false to allow normal processing in the caller
  				return false;
  			}
  		},
  		trigger: function() {

  			// Force setup before trigger
  			leverageNative( this, type );

  			// Return non-false to allow normal event-path propagation
  			return true;
  		},

  		teardown: function() {
  			var attaches;

  			if ( document.documentMode ) {
  				attaches = dataPriv.get( this, delegateType ) - 1;
  				if ( !attaches ) {
  					this.removeEventListener( delegateType, focusMappedHandler );
  					dataPriv.remove( this, delegateType );
  				} else {
  					dataPriv.set( this, delegateType, attaches );
  				}
  			} else {

  				// Return false to indicate standard teardown should be applied
  				return false;
  			}
  		},

  		// Suppress native focus or blur if we're currently inside
  		// a leveraged native-event stack
  		_default: function( event ) {
  			return dataPriv.get( event.target, type );
  		},

  		delegateType: delegateType
  	};

  	// Support: Firefox <=44
  	// Firefox doesn't have focus(in | out) events
  	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  	//
  	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  	// focus(in | out) events fire after focus & blur events,
  	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
  	//
  	// Support: IE 9 - 11+
  	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
  	// attach a single handler for both events in IE.
  	jQuery.event.special[ delegateType ] = {
  		setup: function() {

  			// Handle: regular nodes (via `this.ownerDocument`), window
  			// (via `this.document`) & document (via `this`).
  			var doc = this.ownerDocument || this.document || this,
  				dataHolder = document.documentMode ? this : doc,
  				attaches = dataPriv.get( dataHolder, delegateType );

  			// Support: IE 9 - 11+
  			// We use the same native handler for focusin & focus (and focusout & blur)
  			// so we need to coordinate setup & teardown parts between those events.
  			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
  			if ( !attaches ) {
  				if ( document.documentMode ) {
  					this.addEventListener( delegateType, focusMappedHandler );
  				} else {
  					doc.addEventListener( type, focusMappedHandler, true );
  				}
  			}
  			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
  		},
  		teardown: function() {
  			var doc = this.ownerDocument || this.document || this,
  				dataHolder = document.documentMode ? this : doc,
  				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

  			if ( !attaches ) {
  				if ( document.documentMode ) {
  					this.removeEventListener( delegateType, focusMappedHandler );
  				} else {
  					doc.removeEventListener( type, focusMappedHandler, true );
  				}
  				dataPriv.remove( dataHolder, delegateType );
  			} else {
  				dataPriv.set( dataHolder, delegateType, attaches );
  			}
  		}
  	};
  } );

  // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).
  jQuery.each( {
  	mouseenter: "mouseover",
  	mouseleave: "mouseout",
  	pointerenter: "pointerover",
  	pointerleave: "pointerout"
  }, function( orig, fix ) {
  	jQuery.event.special[ orig ] = {
  		delegateType: fix,
  		bindType: fix,

  		handle: function( event ) {
  			var ret,
  				target = this,
  				related = event.relatedTarget,
  				handleObj = event.handleObj;

  			// For mouseenter/leave call the handler if related is outside the target.
  			// NB: No relatedTarget if the mouse left/entered the browser window
  			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
  				event.type = handleObj.origType;
  				ret = handleObj.handler.apply( this, arguments );
  				event.type = fix;
  			}
  			return ret;
  		}
  	};
  } );

  jQuery.fn.extend( {

  	on: function( types, selector, data, fn ) {
  		return on( this, types, selector, data, fn );
  	},
  	one: function( types, selector, data, fn ) {
  		return on( this, types, selector, data, fn, 1 );
  	},
  	off: function( types, selector, fn ) {
  		var handleObj, type;
  		if ( types && types.preventDefault && types.handleObj ) {

  			// ( event )  dispatched jQuery.Event
  			handleObj = types.handleObj;
  			jQuery( types.delegateTarget ).off(
  				handleObj.namespace ?
  					handleObj.origType + "." + handleObj.namespace :
  					handleObj.origType,
  				handleObj.selector,
  				handleObj.handler
  			);
  			return this;
  		}
  		if ( typeof types === "object" ) {

  			// ( types-object [, selector] )
  			for ( type in types ) {
  				this.off( type, selector, types[ type ] );
  			}
  			return this;
  		}
  		if ( selector === false || typeof selector === "function" ) {

  			// ( types [, fn] )
  			fn = selector;
  			selector = undefined;
  		}
  		if ( fn === false ) {
  			fn = returnFalse;
  		}
  		return this.each( function() {
  			jQuery.event.remove( this, types, fn, selector );
  		} );
  	}
  } );


  var

  	// Support: IE <=10 - 11, Edge 12 - 13 only
  	// In IE/Edge using regex groups here causes severe slowdowns.
  	// See https://connect.microsoft.com/IE/feedback/details/1736512/
  	rnoInnerhtml = /<script|<style|<link/i,

  	// checked="checked" or checked
  	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

  	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

  // Prefer a tbody over its parent table for containing new rows
  function manipulationTarget( elem, content ) {
  	if ( nodeName( elem, "table" ) &&
  		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

  		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
  	}

  	return elem;
  }

  // Replace/restore the type attribute of script elements for safe DOM manipulation
  function disableScript( elem ) {
  	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
  	return elem;
  }
  function restoreScript( elem ) {
  	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
  		elem.type = elem.type.slice( 5 );
  	} else {
  		elem.removeAttribute( "type" );
  	}

  	return elem;
  }

  function cloneCopyEvent( src, dest ) {
  	var i, l, type, pdataOld, udataOld, udataCur, events;

  	if ( dest.nodeType !== 1 ) {
  		return;
  	}

  	// 1. Copy private data: events, handlers, etc.
  	if ( dataPriv.hasData( src ) ) {
  		pdataOld = dataPriv.get( src );
  		events = pdataOld.events;

  		if ( events ) {
  			dataPriv.remove( dest, "handle events" );

  			for ( type in events ) {
  				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
  					jQuery.event.add( dest, type, events[ type ][ i ] );
  				}
  			}
  		}
  	}

  	// 2. Copy user data
  	if ( dataUser.hasData( src ) ) {
  		udataOld = dataUser.access( src );
  		udataCur = jQuery.extend( {}, udataOld );

  		dataUser.set( dest, udataCur );
  	}
  }

  // Fix IE bugs, see support tests
  function fixInput( src, dest ) {
  	var nodeName = dest.nodeName.toLowerCase();

  	// Fails to persist the checked state of a cloned checkbox or radio button.
  	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
  		dest.checked = src.checked;

  	// Fails to return the selected option to the default selected state when cloning options
  	} else if ( nodeName === "input" || nodeName === "textarea" ) {
  		dest.defaultValue = src.defaultValue;
  	}
  }

  function domManip( collection, args, callback, ignored ) {

  	// Flatten any nested arrays
  	args = flat( args );

  	var fragment, first, scripts, hasScripts, node, doc,
  		i = 0,
  		l = collection.length,
  		iNoClone = l - 1,
  		value = args[ 0 ],
  		valueIsFunction = isFunction( value );

  	// We can't cloneNode fragments that contain checked, in WebKit
  	if ( valueIsFunction ||
  			( l > 1 && typeof value === "string" &&
  				!support.checkClone && rchecked.test( value ) ) ) {
  		return collection.each( function( index ) {
  			var self = collection.eq( index );
  			if ( valueIsFunction ) {
  				args[ 0 ] = value.call( this, index, self.html() );
  			}
  			domManip( self, args, callback, ignored );
  		} );
  	}

  	if ( l ) {
  		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
  		first = fragment.firstChild;

  		if ( fragment.childNodes.length === 1 ) {
  			fragment = first;
  		}

  		// Require either new content or an interest in ignored elements to invoke the callback
  		if ( first || ignored ) {
  			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
  			hasScripts = scripts.length;

  			// Use the original fragment for the last item
  			// instead of the first because it can end up
  			// being emptied incorrectly in certain situations (trac-8070).
  			for ( ; i < l; i++ ) {
  				node = fragment;

  				if ( i !== iNoClone ) {
  					node = jQuery.clone( node, true, true );

  					// Keep references to cloned scripts for later restoration
  					if ( hasScripts ) {

  						// Support: Android <=4.0 only, PhantomJS 1 only
  						// push.apply(_, arraylike) throws on ancient WebKit
  						jQuery.merge( scripts, getAll( node, "script" ) );
  					}
  				}

  				callback.call( collection[ i ], node, i );
  			}

  			if ( hasScripts ) {
  				doc = scripts[ scripts.length - 1 ].ownerDocument;

  				// Re-enable scripts
  				jQuery.map( scripts, restoreScript );

  				// Evaluate executable scripts on first document insertion
  				for ( i = 0; i < hasScripts; i++ ) {
  					node = scripts[ i ];
  					if ( rscriptType.test( node.type || "" ) &&
  						!dataPriv.access( node, "globalEval" ) &&
  						jQuery.contains( doc, node ) ) {

  						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

  							// Optional AJAX dependency, but won't run scripts if not present
  							if ( jQuery._evalUrl && !node.noModule ) {
  								jQuery._evalUrl( node.src, {
  									nonce: node.nonce || node.getAttribute( "nonce" )
  								}, doc );
  							}
  						} else {

  							// Unwrap a CDATA section containing script contents. This shouldn't be
  							// needed as in XML documents they're already not visible when
  							// inspecting element contents and in HTML documents they have no
  							// meaning but we're preserving that logic for backwards compatibility.
  							// This will be removed completely in 4.0. See gh-4904.
  							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
  						}
  					}
  				}
  			}
  		}
  	}

  	return collection;
  }

  function remove( elem, selector, keepData ) {
  	var node,
  		nodes = selector ? jQuery.filter( selector, elem ) : elem,
  		i = 0;

  	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
  		if ( !keepData && node.nodeType === 1 ) {
  			jQuery.cleanData( getAll( node ) );
  		}

  		if ( node.parentNode ) {
  			if ( keepData && isAttached( node ) ) {
  				setGlobalEval( getAll( node, "script" ) );
  			}
  			node.parentNode.removeChild( node );
  		}
  	}

  	return elem;
  }

  jQuery.extend( {
  	htmlPrefilter: function( html ) {
  		return html;
  	},

  	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
  		var i, l, srcElements, destElements,
  			clone = elem.cloneNode( true ),
  			inPage = isAttached( elem );

  		// Fix IE cloning issues
  		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
  				!jQuery.isXMLDoc( elem ) ) {

  			// We eschew jQuery#find here for performance reasons:
  			// https://jsperf.com/getall-vs-sizzle/2
  			destElements = getAll( clone );
  			srcElements = getAll( elem );

  			for ( i = 0, l = srcElements.length; i < l; i++ ) {
  				fixInput( srcElements[ i ], destElements[ i ] );
  			}
  		}

  		// Copy the events from the original to the clone
  		if ( dataAndEvents ) {
  			if ( deepDataAndEvents ) {
  				srcElements = srcElements || getAll( elem );
  				destElements = destElements || getAll( clone );

  				for ( i = 0, l = srcElements.length; i < l; i++ ) {
  					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
  				}
  			} else {
  				cloneCopyEvent( elem, clone );
  			}
  		}

  		// Preserve script evaluation history
  		destElements = getAll( clone, "script" );
  		if ( destElements.length > 0 ) {
  			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
  		}

  		// Return the cloned set
  		return clone;
  	},

  	cleanData: function( elems ) {
  		var data, elem, type,
  			special = jQuery.event.special,
  			i = 0;

  		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
  			if ( acceptData( elem ) ) {
  				if ( ( data = elem[ dataPriv.expando ] ) ) {
  					if ( data.events ) {
  						for ( type in data.events ) {
  							if ( special[ type ] ) {
  								jQuery.event.remove( elem, type );

  							// This is a shortcut to avoid jQuery.event.remove's overhead
  							} else {
  								jQuery.removeEvent( elem, type, data.handle );
  							}
  						}
  					}

  					// Support: Chrome <=35 - 45+
  					// Assign undefined instead of using delete, see Data#remove
  					elem[ dataPriv.expando ] = undefined;
  				}
  				if ( elem[ dataUser.expando ] ) {

  					// Support: Chrome <=35 - 45+
  					// Assign undefined instead of using delete, see Data#remove
  					elem[ dataUser.expando ] = undefined;
  				}
  			}
  		}
  	}
  } );

  jQuery.fn.extend( {
  	detach: function( selector ) {
  		return remove( this, selector, true );
  	},

  	remove: function( selector ) {
  		return remove( this, selector );
  	},

  	text: function( value ) {
  		return access( this, function( value ) {
  			return value === undefined ?
  				jQuery.text( this ) :
  				this.empty().each( function() {
  					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  						this.textContent = value;
  					}
  				} );
  		}, null, value, arguments.length );
  	},

  	append: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  				var target = manipulationTarget( this, elem );
  				target.appendChild( elem );
  			}
  		} );
  	},

  	prepend: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  				var target = manipulationTarget( this, elem );
  				target.insertBefore( elem, target.firstChild );
  			}
  		} );
  	},

  	before: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.parentNode ) {
  				this.parentNode.insertBefore( elem, this );
  			}
  		} );
  	},

  	after: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.parentNode ) {
  				this.parentNode.insertBefore( elem, this.nextSibling );
  			}
  		} );
  	},

  	empty: function() {
  		var elem,
  			i = 0;

  		for ( ; ( elem = this[ i ] ) != null; i++ ) {
  			if ( elem.nodeType === 1 ) {

  				// Prevent memory leaks
  				jQuery.cleanData( getAll( elem, false ) );

  				// Remove any remaining nodes
  				elem.textContent = "";
  			}
  		}

  		return this;
  	},

  	clone: function( dataAndEvents, deepDataAndEvents ) {
  		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
  		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

  		return this.map( function() {
  			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
  		} );
  	},

  	html: function( value ) {
  		return access( this, function( value ) {
  			var elem = this[ 0 ] || {},
  				i = 0,
  				l = this.length;

  			if ( value === undefined && elem.nodeType === 1 ) {
  				return elem.innerHTML;
  			}

  			// See if we can take a shortcut and just use innerHTML
  			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
  				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

  				value = jQuery.htmlPrefilter( value );

  				try {
  					for ( ; i < l; i++ ) {
  						elem = this[ i ] || {};

  						// Remove element nodes and prevent memory leaks
  						if ( elem.nodeType === 1 ) {
  							jQuery.cleanData( getAll( elem, false ) );
  							elem.innerHTML = value;
  						}
  					}

  					elem = 0;

  				// If using innerHTML throws an exception, use the fallback method
  				} catch ( e ) {}
  			}

  			if ( elem ) {
  				this.empty().append( value );
  			}
  		}, null, value, arguments.length );
  	},

  	replaceWith: function() {
  		var ignored = [];

  		// Make the changes, replacing each non-ignored context element with the new content
  		return domManip( this, arguments, function( elem ) {
  			var parent = this.parentNode;

  			if ( jQuery.inArray( this, ignored ) < 0 ) {
  				jQuery.cleanData( getAll( this ) );
  				if ( parent ) {
  					parent.replaceChild( elem, this );
  				}
  			}

  		// Force callback invocation
  		}, ignored );
  	}
  } );

  jQuery.each( {
  	appendTo: "append",
  	prependTo: "prepend",
  	insertBefore: "before",
  	insertAfter: "after",
  	replaceAll: "replaceWith"
  }, function( name, original ) {
  	jQuery.fn[ name ] = function( selector ) {
  		var elems,
  			ret = [],
  			insert = jQuery( selector ),
  			last = insert.length - 1,
  			i = 0;

  		for ( ; i <= last; i++ ) {
  			elems = i === last ? this : this.clone( true );
  			jQuery( insert[ i ] )[ original ]( elems );

  			// Support: Android <=4.0 only, PhantomJS 1 only
  			// .get() because push.apply(_, arraylike) throws on ancient WebKit
  			push.apply( ret, elems.get() );
  		}

  		return this.pushStack( ret );
  	};
  } );
  var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

  var rcustomProp = /^--/;


  var getStyles = function( elem ) {

  		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
  		// IE throws on elements created in popups
  		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
  		var view = elem.ownerDocument.defaultView;

  		if ( !view || !view.opener ) {
  			view = window;
  		}

  		return view.getComputedStyle( elem );
  	};

  var swap = function( elem, options, callback ) {
  	var ret, name,
  		old = {};

  	// Remember the old values, and insert the new ones
  	for ( name in options ) {
  		old[ name ] = elem.style[ name ];
  		elem.style[ name ] = options[ name ];
  	}

  	ret = callback.call( elem );

  	// Revert the old values
  	for ( name in options ) {
  		elem.style[ name ] = old[ name ];
  	}

  	return ret;
  };


  var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



  ( function() {

  	// Executing both pixelPosition & boxSizingReliable tests require only one layout
  	// so they're executed at the same time to save the second computation.
  	function computeStyleTests() {

  		// This is a singleton, we need to execute it only once
  		if ( !div ) {
  			return;
  		}

  		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
  			"margin-top:1px;padding:0;border:0";
  		div.style.cssText =
  			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
  			"margin:auto;border:1px;padding:1px;" +
  			"width:60%;top:1%";
  		documentElement.appendChild( container ).appendChild( div );

  		var divStyle = window.getComputedStyle( div );
  		pixelPositionVal = divStyle.top !== "1%";

  		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
  		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

  		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
  		// Some styles come back with percentage values, even though they shouldn't
  		div.style.right = "60%";
  		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

  		// Support: IE 9 - 11 only
  		// Detect misreporting of content dimensions for box-sizing:border-box elements
  		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

  		// Support: IE 9 only
  		// Detect overflow:scroll screwiness (gh-3699)
  		// Support: Chrome <=64
  		// Don't get tricked when zoom affects offsetWidth (gh-4029)
  		div.style.position = "absolute";
  		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

  		documentElement.removeChild( container );

  		// Nullify the div so it wouldn't be stored in the memory and
  		// it will also be a sign that checks already performed
  		div = null;
  	}

  	function roundPixelMeasures( measure ) {
  		return Math.round( parseFloat( measure ) );
  	}

  	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
  		reliableTrDimensionsVal, reliableMarginLeftVal,
  		container = document.createElement( "div" ),
  		div = document.createElement( "div" );

  	// Finish early in limited (non-browser) environments
  	if ( !div.style ) {
  		return;
  	}

  	// Support: IE <=9 - 11 only
  	// Style of cloned element affects source element cloned (trac-8908)
  	div.style.backgroundClip = "content-box";
  	div.cloneNode( true ).style.backgroundClip = "";
  	support.clearCloneStyle = div.style.backgroundClip === "content-box";

  	jQuery.extend( support, {
  		boxSizingReliable: function() {
  			computeStyleTests();
  			return boxSizingReliableVal;
  		},
  		pixelBoxStyles: function() {
  			computeStyleTests();
  			return pixelBoxStylesVal;
  		},
  		pixelPosition: function() {
  			computeStyleTests();
  			return pixelPositionVal;
  		},
  		reliableMarginLeft: function() {
  			computeStyleTests();
  			return reliableMarginLeftVal;
  		},
  		scrollboxSize: function() {
  			computeStyleTests();
  			return scrollboxSizeVal;
  		},

  		// Support: IE 9 - 11+, Edge 15 - 18+
  		// IE/Edge misreport `getComputedStyle` of table rows with width/height
  		// set in CSS while `offset*` properties report correct values.
  		// Behavior in IE 9 is more subtle than in newer versions & it passes
  		// some versions of this test; make sure not to make it pass there!
  		//
  		// Support: Firefox 70+
  		// Only Firefox includes border widths
  		// in computed dimensions. (gh-4529)
  		reliableTrDimensions: function() {
  			var table, tr, trChild, trStyle;
  			if ( reliableTrDimensionsVal == null ) {
  				table = document.createElement( "table" );
  				tr = document.createElement( "tr" );
  				trChild = document.createElement( "div" );

  				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
  				tr.style.cssText = "box-sizing:content-box;border:1px solid";

  				// Support: Chrome 86+
  				// Height set through cssText does not get applied.
  				// Computed height then comes back as 0.
  				tr.style.height = "1px";
  				trChild.style.height = "9px";

  				// Support: Android 8 Chrome 86+
  				// In our bodyBackground.html iframe,
  				// display for all div elements is set to "inline",
  				// which causes a problem only in Android 8 Chrome 86.
  				// Ensuring the div is `display: block`
  				// gets around this issue.
  				trChild.style.display = "block";

  				documentElement
  					.appendChild( table )
  					.appendChild( tr )
  					.appendChild( trChild );

  				trStyle = window.getComputedStyle( tr );
  				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
  					parseInt( trStyle.borderTopWidth, 10 ) +
  					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

  				documentElement.removeChild( table );
  			}
  			return reliableTrDimensionsVal;
  		}
  	} );
  } )();


  function curCSS( elem, name, computed ) {
  	var width, minWidth, maxWidth, ret,
  		isCustomProp = rcustomProp.test( name ),

  		// Support: Firefox 51+
  		// Retrieving style before computed somehow
  		// fixes an issue with getting wrong values
  		// on detached elements
  		style = elem.style;

  	computed = computed || getStyles( elem );

  	// getPropertyValue is needed for:
  	//   .css('filter') (IE 9 only, trac-12537)
  	//   .css('--customProperty) (gh-3144)
  	if ( computed ) {

  		// Support: IE <=9 - 11+
  		// IE only supports `"float"` in `getPropertyValue`; in computed styles
  		// it's only available as `"cssFloat"`. We no longer modify properties
  		// sent to `.css()` apart from camelCasing, so we need to check both.
  		// Normally, this would create difference in behavior: if
  		// `getPropertyValue` returns an empty string, the value returned
  		// by `.css()` would be `undefined`. This is usually the case for
  		// disconnected elements. However, in IE even disconnected elements
  		// with no styles return `"none"` for `getPropertyValue( "float" )`
  		ret = computed.getPropertyValue( name ) || computed[ name ];

  		if ( isCustomProp && ret ) {

  			// Support: Firefox 105+, Chrome <=105+
  			// Spec requires trimming whitespace for custom properties (gh-4926).
  			// Firefox only trims leading whitespace. Chrome just collapses
  			// both leading & trailing whitespace to a single space.
  			//
  			// Fall back to `undefined` if empty string returned.
  			// This collapses a missing definition with property defined
  			// and set to an empty string but there's no standard API
  			// allowing us to differentiate them without a performance penalty
  			// and returning `undefined` aligns with older jQuery.
  			//
  			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
  			// as whitespace while CSS does not, but this is not a problem
  			// because CSS preprocessing replaces them with U+000A LINE FEED
  			// (which *is* CSS whitespace)
  			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
  			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
  		}

  		if ( ret === "" && !isAttached( elem ) ) {
  			ret = jQuery.style( elem, name );
  		}

  		// A tribute to the "awesome hack by Dean Edwards"
  		// Android Browser returns percentage for some values,
  		// but width seems to be reliably pixels.
  		// This is against the CSSOM draft spec:
  		// https://drafts.csswg.org/cssom/#resolved-values
  		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

  			// Remember the original values
  			width = style.width;
  			minWidth = style.minWidth;
  			maxWidth = style.maxWidth;

  			// Put in the new values to get a computed value out
  			style.minWidth = style.maxWidth = style.width = ret;
  			ret = computed.width;

  			// Revert the changed values
  			style.width = width;
  			style.minWidth = minWidth;
  			style.maxWidth = maxWidth;
  		}
  	}

  	return ret !== undefined ?

  		// Support: IE <=9 - 11 only
  		// IE returns zIndex value as an integer.
  		ret + "" :
  		ret;
  }


  function addGetHookIf( conditionFn, hookFn ) {

  	// Define the hook, we'll check on the first run if it's really needed.
  	return {
  		get: function() {
  			if ( conditionFn() ) {

  				// Hook not needed (or it's not possible to use it due
  				// to missing dependency), remove it.
  				delete this.get;
  				return;
  			}

  			// Hook needed; redefine it so that the support test is not executed again.
  			return ( this.get = hookFn ).apply( this, arguments );
  		}
  	};
  }


  var cssPrefixes = [ "Webkit", "Moz", "ms" ],
  	emptyStyle = document.createElement( "div" ).style,
  	vendorProps = {};

  // Return a vendor-prefixed property or undefined
  function vendorPropName( name ) {

  	// Check for vendor prefixed names
  	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
  		i = cssPrefixes.length;

  	while ( i-- ) {
  		name = cssPrefixes[ i ] + capName;
  		if ( name in emptyStyle ) {
  			return name;
  		}
  	}
  }

  // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
  function finalPropName( name ) {
  	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

  	if ( final ) {
  		return final;
  	}
  	if ( name in emptyStyle ) {
  		return name;
  	}
  	return vendorProps[ name ] = vendorPropName( name ) || name;
  }


  var

  	// Swappable if display is none or starts with table
  	// except "table", "table-cell", or "table-caption"
  	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
  	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  	cssNormalTransform = {
  		letterSpacing: "0",
  		fontWeight: "400"
  	};

  function setPositiveNumber( _elem, value, subtract ) {

  	// Any relative (+/-) values have already been
  	// normalized at this point
  	var matches = rcssNum.exec( value );
  	return matches ?

  		// Guard against undefined "subtract", e.g., when used as in cssHooks
  		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
  		value;
  }

  function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
  	var i = dimension === "width" ? 1 : 0,
  		extra = 0,
  		delta = 0,
  		marginDelta = 0;

  	// Adjustment may not be necessary
  	if ( box === ( isBorderBox ? "border" : "content" ) ) {
  		return 0;
  	}

  	for ( ; i < 4; i += 2 ) {

  		// Both box models exclude margin
  		// Count margin delta separately to only add it after scroll gutter adjustment.
  		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
  		if ( box === "margin" ) {
  			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
  		}

  		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
  		if ( !isBorderBox ) {

  			// Add padding
  			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

  			// For "border" or "margin", add border
  			if ( box !== "padding" ) {
  				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

  			// But still keep track of it otherwise
  			} else {
  				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  			}

  		// If we get here with a border-box (content + padding + border), we're seeking "content" or
  		// "padding" or "margin"
  		} else {

  			// For "content", subtract padding
  			if ( box === "content" ) {
  				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
  			}

  			// For "content" or "padding", subtract border
  			if ( box !== "margin" ) {
  				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  			}
  		}
  	}

  	// Account for positive content-box scroll gutter when requested by providing computedVal
  	if ( !isBorderBox && computedVal >= 0 ) {

  		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
  		// Assuming integer scroll gutter, subtract the rest and round down
  		delta += Math.max( 0, Math.ceil(
  			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  			computedVal -
  			delta -
  			extra -
  			0.5

  		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
  		// Use an explicit zero to avoid NaN (gh-3964)
  		) ) || 0;
  	}

  	return delta + marginDelta;
  }

  function getWidthOrHeight( elem, dimension, extra ) {

  	// Start with computed style
  	var styles = getStyles( elem ),

  		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
  		// Fake content-box until we know it's needed to know the true value.
  		boxSizingNeeded = !support.boxSizingReliable() || extra,
  		isBorderBox = boxSizingNeeded &&
  			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  		valueIsBorderBox = isBorderBox,

  		val = curCSS( elem, dimension, styles ),
  		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

  	// Support: Firefox <=54
  	// Return a confounding non-pixel value or feign ignorance, as appropriate.
  	if ( rnumnonpx.test( val ) ) {
  		if ( !extra ) {
  			return val;
  		}
  		val = "auto";
  	}


  	// Support: IE 9 - 11 only
  	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
  	// In those cases, the computed value can be trusted to be border-box.
  	if ( ( !support.boxSizingReliable() && isBorderBox ||

  		// Support: IE 10 - 11+, Edge 15 - 18+
  		// IE/Edge misreport `getComputedStyle` of table rows with width/height
  		// set in CSS while `offset*` properties report correct values.
  		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
  		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

  		// Fall back to offsetWidth/offsetHeight when value is "auto"
  		// This happens for inline elements with no explicit setting (gh-3571)
  		val === "auto" ||

  		// Support: Android <=4.1 - 4.3 only
  		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
  		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

  		// Make sure the element is visible & connected
  		elem.getClientRects().length ) {

  		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

  		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
  		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
  		// retrieved value as a content box dimension.
  		valueIsBorderBox = offsetProp in elem;
  		if ( valueIsBorderBox ) {
  			val = elem[ offsetProp ];
  		}
  	}

  	// Normalize "" and auto
  	val = parseFloat( val ) || 0;

  	// Adjust for the element's box model
  	return ( val +
  		boxModelAdjustment(
  			elem,
  			dimension,
  			extra || ( isBorderBox ? "border" : "content" ),
  			valueIsBorderBox,
  			styles,

  			// Provide the current computed size to request scroll gutter calculation (gh-3589)
  			val
  		)
  	) + "px";
  }

  jQuery.extend( {

  	// Add in style property hooks for overriding the default
  	// behavior of getting and setting a style property
  	cssHooks: {
  		opacity: {
  			get: function( elem, computed ) {
  				if ( computed ) {

  					// We should always get a number back from opacity
  					var ret = curCSS( elem, "opacity" );
  					return ret === "" ? "1" : ret;
  				}
  			}
  		}
  	},

  	// Don't automatically add "px" to these possibly-unitless properties
  	cssNumber: {
  		animationIterationCount: true,
  		aspectRatio: true,
  		borderImageSlice: true,
  		columnCount: true,
  		flexGrow: true,
  		flexShrink: true,
  		fontWeight: true,
  		gridArea: true,
  		gridColumn: true,
  		gridColumnEnd: true,
  		gridColumnStart: true,
  		gridRow: true,
  		gridRowEnd: true,
  		gridRowStart: true,
  		lineHeight: true,
  		opacity: true,
  		order: true,
  		orphans: true,
  		scale: true,
  		widows: true,
  		zIndex: true,
  		zoom: true,

  		// SVG-related
  		fillOpacity: true,
  		floodOpacity: true,
  		stopOpacity: true,
  		strokeMiterlimit: true,
  		strokeOpacity: true
  	},

  	// Add in properties whose names you wish to fix before
  	// setting or getting the value
  	cssProps: {},

  	// Get and set the style property on a DOM Node
  	style: function( elem, name, value, extra ) {

  		// Don't set styles on text and comment nodes
  		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
  			return;
  		}

  		// Make sure that we're working with the right name
  		var ret, type, hooks,
  			origName = camelCase( name ),
  			isCustomProp = rcustomProp.test( name ),
  			style = elem.style;

  		// Make sure that we're working with the right name. We don't
  		// want to query the value if it is a CSS custom property
  		// since they are user-defined.
  		if ( !isCustomProp ) {
  			name = finalPropName( origName );
  		}

  		// Gets hook for the prefixed version, then unprefixed version
  		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  		// Check if we're setting a value
  		if ( value !== undefined ) {
  			type = typeof value;

  			// Convert "+=" or "-=" to relative numbers (trac-7345)
  			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
  				value = adjustCSS( elem, name, ret );

  				// Fixes bug trac-9237
  				type = "number";
  			}

  			// Make sure that null and NaN values aren't set (trac-7116)
  			if ( value == null || value !== value ) {
  				return;
  			}

  			// If a number was passed in, add the unit (except for certain CSS properties)
  			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
  			// "px" to a few hardcoded values.
  			if ( type === "number" && !isCustomProp ) {
  				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
  			}

  			// background-* props affect original clone's values
  			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
  				style[ name ] = "inherit";
  			}

  			// If a hook was provided, use that value, otherwise just set the specified value
  			if ( !hooks || !( "set" in hooks ) ||
  				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

  				if ( isCustomProp ) {
  					style.setProperty( name, value );
  				} else {
  					style[ name ] = value;
  				}
  			}

  		} else {

  			// If a hook was provided get the non-computed value from there
  			if ( hooks && "get" in hooks &&
  				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

  				return ret;
  			}

  			// Otherwise just get the value from the style object
  			return style[ name ];
  		}
  	},

  	css: function( elem, name, extra, styles ) {
  		var val, num, hooks,
  			origName = camelCase( name ),
  			isCustomProp = rcustomProp.test( name );

  		// Make sure that we're working with the right name. We don't
  		// want to modify the value if it is a CSS custom property
  		// since they are user-defined.
  		if ( !isCustomProp ) {
  			name = finalPropName( origName );
  		}

  		// Try prefixed name followed by the unprefixed name
  		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  		// If a hook was provided get the computed value from there
  		if ( hooks && "get" in hooks ) {
  			val = hooks.get( elem, true, extra );
  		}

  		// Otherwise, if a way to get the computed value exists, use that
  		if ( val === undefined ) {
  			val = curCSS( elem, name, styles );
  		}

  		// Convert "normal" to computed value
  		if ( val === "normal" && name in cssNormalTransform ) {
  			val = cssNormalTransform[ name ];
  		}

  		// Make numeric if forced or a qualifier was provided and val looks numeric
  		if ( extra === "" || extra ) {
  			num = parseFloat( val );
  			return extra === true || isFinite( num ) ? num || 0 : val;
  		}

  		return val;
  	}
  } );

  jQuery.each( [ "height", "width" ], function( _i, dimension ) {
  	jQuery.cssHooks[ dimension ] = {
  		get: function( elem, computed, extra ) {
  			if ( computed ) {

  				// Certain elements can have dimension info if we invisibly show them
  				// but it must have a current display style that would benefit
  				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

  					// Support: Safari 8+
  					// Table columns in Safari have non-zero offsetWidth & zero
  					// getBoundingClientRect().width unless display is changed.
  					// Support: IE <=11 only
  					// Running getBoundingClientRect on a disconnected node
  					// in IE throws an error.
  					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
  					swap( elem, cssShow, function() {
  						return getWidthOrHeight( elem, dimension, extra );
  					} ) :
  					getWidthOrHeight( elem, dimension, extra );
  			}
  		},

  		set: function( elem, value, extra ) {
  			var matches,
  				styles = getStyles( elem ),

  				// Only read styles.position if the test has a chance to fail
  				// to avoid forcing a reflow.
  				scrollboxSizeBuggy = !support.scrollboxSize() &&
  					styles.position === "absolute",

  				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
  				boxSizingNeeded = scrollboxSizeBuggy || extra,
  				isBorderBox = boxSizingNeeded &&
  					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  				subtract = extra ?
  					boxModelAdjustment(
  						elem,
  						dimension,
  						extra,
  						isBorderBox,
  						styles
  					) :
  					0;

  			// Account for unreliable border-box dimensions by comparing offset* to computed and
  			// faking a content-box to get border and padding (gh-3699)
  			if ( isBorderBox && scrollboxSizeBuggy ) {
  				subtract -= Math.ceil(
  					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  					parseFloat( styles[ dimension ] ) -
  					boxModelAdjustment( elem, dimension, "border", false, styles ) -
  					0.5
  				);
  			}

  			// Convert to pixels if value adjustment is needed
  			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
  				( matches[ 3 ] || "px" ) !== "px" ) {

  				elem.style[ dimension ] = value;
  				value = jQuery.css( elem, dimension );
  			}

  			return setPositiveNumber( elem, value, subtract );
  		}
  	};
  } );

  jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
  	function( elem, computed ) {
  		if ( computed ) {
  			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
  				elem.getBoundingClientRect().left -
  					swap( elem, { marginLeft: 0 }, function() {
  						return elem.getBoundingClientRect().left;
  					} )
  			) + "px";
  		}
  	}
  );

  // These hooks are used by animate to expand properties
  jQuery.each( {
  	margin: "",
  	padding: "",
  	border: "Width"
  }, function( prefix, suffix ) {
  	jQuery.cssHooks[ prefix + suffix ] = {
  		expand: function( value ) {
  			var i = 0,
  				expanded = {},

  				// Assumes a single number if not a string
  				parts = typeof value === "string" ? value.split( " " ) : [ value ];

  			for ( ; i < 4; i++ ) {
  				expanded[ prefix + cssExpand[ i ] + suffix ] =
  					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
  			}

  			return expanded;
  		}
  	};

  	if ( prefix !== "margin" ) {
  		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
  	}
  } );

  jQuery.fn.extend( {
  	css: function( name, value ) {
  		return access( this, function( elem, name, value ) {
  			var styles, len,
  				map = {},
  				i = 0;

  			if ( Array.isArray( name ) ) {
  				styles = getStyles( elem );
  				len = name.length;

  				for ( ; i < len; i++ ) {
  					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
  				}

  				return map;
  			}

  			return value !== undefined ?
  				jQuery.style( elem, name, value ) :
  				jQuery.css( elem, name );
  		}, name, value, arguments.length > 1 );
  	}
  } );


  // Based off of the plugin by Clint Helfers, with permission.
  jQuery.fn.delay = function( time, type ) {
  	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
  	type = type || "fx";

  	return this.queue( type, function( next, hooks ) {
  		var timeout = window.setTimeout( next, time );
  		hooks.stop = function() {
  			window.clearTimeout( timeout );
  		};
  	} );
  };


  ( function() {
  	var input = document.createElement( "input" ),
  		select = document.createElement( "select" ),
  		opt = select.appendChild( document.createElement( "option" ) );

  	input.type = "checkbox";

  	// Support: Android <=4.3 only
  	// Default value for a checkbox should be "on"
  	support.checkOn = input.value !== "";

  	// Support: IE <=11 only
  	// Must access selectedIndex to make default options select
  	support.optSelected = opt.selected;

  	// Support: IE <=11 only
  	// An input loses its value after becoming a radio
  	input = document.createElement( "input" );
  	input.value = "t";
  	input.type = "radio";
  	support.radioValue = input.value === "t";
  } )();


  var boolHook,
  	attrHandle = jQuery.expr.attrHandle;

  jQuery.fn.extend( {
  	attr: function( name, value ) {
  		return access( this, jQuery.attr, name, value, arguments.length > 1 );
  	},

  	removeAttr: function( name ) {
  		return this.each( function() {
  			jQuery.removeAttr( this, name );
  		} );
  	}
  } );

  jQuery.extend( {
  	attr: function( elem, name, value ) {
  		var ret, hooks,
  			nType = elem.nodeType;

  		// Don't get/set attributes on text, comment and attribute nodes
  		if ( nType === 3 || nType === 8 || nType === 2 ) {
  			return;
  		}

  		// Fallback to prop when attributes are not supported
  		if ( typeof elem.getAttribute === "undefined" ) {
  			return jQuery.prop( elem, name, value );
  		}

  		// Attribute hooks are determined by the lowercase version
  		// Grab necessary hook if one is defined
  		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
  			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
  				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
  		}

  		if ( value !== undefined ) {
  			if ( value === null ) {
  				jQuery.removeAttr( elem, name );
  				return;
  			}

  			if ( hooks && "set" in hooks &&
  				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  				return ret;
  			}

  			elem.setAttribute( name, value + "" );
  			return value;
  		}

  		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  			return ret;
  		}

  		ret = jQuery.find.attr( elem, name );

  		// Non-existent attributes return null, we normalize to undefined
  		return ret == null ? undefined : ret;
  	},

  	attrHooks: {
  		type: {
  			set: function( elem, value ) {
  				if ( !support.radioValue && value === "radio" &&
  					nodeName( elem, "input" ) ) {
  					var val = elem.value;
  					elem.setAttribute( "type", value );
  					if ( val ) {
  						elem.value = val;
  					}
  					return value;
  				}
  			}
  		}
  	},

  	removeAttr: function( elem, value ) {
  		var name,
  			i = 0,

  			// Attribute names can contain non-HTML whitespace characters
  			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
  			attrNames = value && value.match( rnothtmlwhite );

  		if ( attrNames && elem.nodeType === 1 ) {
  			while ( ( name = attrNames[ i++ ] ) ) {
  				elem.removeAttribute( name );
  			}
  		}
  	}
  } );

  // Hooks for boolean attributes
  boolHook = {
  	set: function( elem, value, name ) {
  		if ( value === false ) {

  			// Remove boolean attributes when set to false
  			jQuery.removeAttr( elem, name );
  		} else {
  			elem.setAttribute( name, name );
  		}
  		return name;
  	}
  };

  jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
  	var getter = attrHandle[ name ] || jQuery.find.attr;

  	attrHandle[ name ] = function( elem, name, isXML ) {
  		var ret, handle,
  			lowercaseName = name.toLowerCase();

  		if ( !isXML ) {

  			// Avoid an infinite loop by temporarily removing this function from the getter
  			handle = attrHandle[ lowercaseName ];
  			attrHandle[ lowercaseName ] = ret;
  			ret = getter( elem, name, isXML ) != null ?
  				lowercaseName :
  				null;
  			attrHandle[ lowercaseName ] = handle;
  		}
  		return ret;
  	};
  } );




  var rfocusable = /^(?:input|select|textarea|button)$/i,
  	rclickable = /^(?:a|area)$/i;

  jQuery.fn.extend( {
  	prop: function( name, value ) {
  		return access( this, jQuery.prop, name, value, arguments.length > 1 );
  	},

  	removeProp: function( name ) {
  		return this.each( function() {
  			delete this[ jQuery.propFix[ name ] || name ];
  		} );
  	}
  } );

  jQuery.extend( {
  	prop: function( elem, name, value ) {
  		var ret, hooks,
  			nType = elem.nodeType;

  		// Don't get/set properties on text, comment and attribute nodes
  		if ( nType === 3 || nType === 8 || nType === 2 ) {
  			return;
  		}

  		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

  			// Fix name and attach hooks
  			name = jQuery.propFix[ name ] || name;
  			hooks = jQuery.propHooks[ name ];
  		}

  		if ( value !== undefined ) {
  			if ( hooks && "set" in hooks &&
  				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  				return ret;
  			}

  			return ( elem[ name ] = value );
  		}

  		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  			return ret;
  		}

  		return elem[ name ];
  	},

  	propHooks: {
  		tabIndex: {
  			get: function( elem ) {

  				// Support: IE <=9 - 11 only
  				// elem.tabIndex doesn't always return the
  				// correct value when it hasn't been explicitly set
  				// Use proper attribute retrieval (trac-12072)
  				var tabindex = jQuery.find.attr( elem, "tabindex" );

  				if ( tabindex ) {
  					return parseInt( tabindex, 10 );
  				}

  				if (
  					rfocusable.test( elem.nodeName ) ||
  					rclickable.test( elem.nodeName ) &&
  					elem.href
  				) {
  					return 0;
  				}

  				return -1;
  			}
  		}
  	},

  	propFix: {
  		"for": "htmlFor",
  		"class": "className"
  	}
  } );

  // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop
  if ( !support.optSelected ) {
  	jQuery.propHooks.selected = {
  		get: function( elem ) {

  			/* eslint no-unused-expressions: "off" */

  			var parent = elem.parentNode;
  			if ( parent && parent.parentNode ) {
  				parent.parentNode.selectedIndex;
  			}
  			return null;
  		},
  		set: function( elem ) {

  			/* eslint no-unused-expressions: "off" */

  			var parent = elem.parentNode;
  			if ( parent ) {
  				parent.selectedIndex;

  				if ( parent.parentNode ) {
  					parent.parentNode.selectedIndex;
  				}
  			}
  		}
  	};
  }

  jQuery.each( [
  	"tabIndex",
  	"readOnly",
  	"maxLength",
  	"cellSpacing",
  	"cellPadding",
  	"rowSpan",
  	"colSpan",
  	"useMap",
  	"frameBorder",
  	"contentEditable"
  ], function() {
  	jQuery.propFix[ this.toLowerCase() ] = this;
  } );




  	// Strip and collapse whitespace according to HTML spec
  	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
  	function stripAndCollapse( value ) {
  		var tokens = value.match( rnothtmlwhite ) || [];
  		return tokens.join( " " );
  	}


  function getClass( elem ) {
  	return elem.getAttribute && elem.getAttribute( "class" ) || "";
  }

  function classesToArray( value ) {
  	if ( Array.isArray( value ) ) {
  		return value;
  	}
  	if ( typeof value === "string" ) {
  		return value.match( rnothtmlwhite ) || [];
  	}
  	return [];
  }

  jQuery.fn.extend( {
  	addClass: function( value ) {
  		var classNames, cur, curValue, className, i, finalValue;

  		if ( isFunction( value ) ) {
  			return this.each( function( j ) {
  				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
  			} );
  		}

  		classNames = classesToArray( value );

  		if ( classNames.length ) {
  			return this.each( function() {
  				curValue = getClass( this );
  				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  				if ( cur ) {
  					for ( i = 0; i < classNames.length; i++ ) {
  						className = classNames[ i ];
  						if ( cur.indexOf( " " + className + " " ) < 0 ) {
  							cur += className + " ";
  						}
  					}

  					// Only assign if different to avoid unneeded rendering.
  					finalValue = stripAndCollapse( cur );
  					if ( curValue !== finalValue ) {
  						this.setAttribute( "class", finalValue );
  					}
  				}
  			} );
  		}

  		return this;
  	},

  	removeClass: function( value ) {
  		var classNames, cur, curValue, className, i, finalValue;

  		if ( isFunction( value ) ) {
  			return this.each( function( j ) {
  				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
  			} );
  		}

  		if ( !arguments.length ) {
  			return this.attr( "class", "" );
  		}

  		classNames = classesToArray( value );

  		if ( classNames.length ) {
  			return this.each( function() {
  				curValue = getClass( this );

  				// This expression is here for better compressibility (see addClass)
  				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  				if ( cur ) {
  					for ( i = 0; i < classNames.length; i++ ) {
  						className = classNames[ i ];

  						// Remove *all* instances
  						while ( cur.indexOf( " " + className + " " ) > -1 ) {
  							cur = cur.replace( " " + className + " ", " " );
  						}
  					}

  					// Only assign if different to avoid unneeded rendering.
  					finalValue = stripAndCollapse( cur );
  					if ( curValue !== finalValue ) {
  						this.setAttribute( "class", finalValue );
  					}
  				}
  			} );
  		}

  		return this;
  	},

  	toggleClass: function( value, stateVal ) {
  		var classNames, className, i, self,
  			type = typeof value,
  			isValidValue = type === "string" || Array.isArray( value );

  		if ( isFunction( value ) ) {
  			return this.each( function( i ) {
  				jQuery( this ).toggleClass(
  					value.call( this, i, getClass( this ), stateVal ),
  					stateVal
  				);
  			} );
  		}

  		if ( typeof stateVal === "boolean" && isValidValue ) {
  			return stateVal ? this.addClass( value ) : this.removeClass( value );
  		}

  		classNames = classesToArray( value );

  		return this.each( function() {
  			if ( isValidValue ) {

  				// Toggle individual class names
  				self = jQuery( this );

  				for ( i = 0; i < classNames.length; i++ ) {
  					className = classNames[ i ];

  					// Check each className given, space separated list
  					if ( self.hasClass( className ) ) {
  						self.removeClass( className );
  					} else {
  						self.addClass( className );
  					}
  				}

  			// Toggle whole class name
  			} else if ( value === undefined || type === "boolean" ) {
  				className = getClass( this );
  				if ( className ) {

  					// Store className if set
  					dataPriv.set( this, "__className__", className );
  				}

  				// If the element has a class name or if we're passed `false`,
  				// then remove the whole classname (if there was one, the above saved it).
  				// Otherwise bring back whatever was previously saved (if anything),
  				// falling back to the empty string if nothing was stored.
  				if ( this.setAttribute ) {
  					this.setAttribute( "class",
  						className || value === false ?
  							"" :
  							dataPriv.get( this, "__className__" ) || ""
  					);
  				}
  			}
  		} );
  	},

  	hasClass: function( selector ) {
  		var className, elem,
  			i = 0;

  		className = " " + selector + " ";
  		while ( ( elem = this[ i++ ] ) ) {
  			if ( elem.nodeType === 1 &&
  				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
  				return true;
  			}
  		}

  		return false;
  	}
  } );




  var rreturn = /\r/g;

  jQuery.fn.extend( {
  	val: function( value ) {
  		var hooks, ret, valueIsFunction,
  			elem = this[ 0 ];

  		if ( !arguments.length ) {
  			if ( elem ) {
  				hooks = jQuery.valHooks[ elem.type ] ||
  					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

  				if ( hooks &&
  					"get" in hooks &&
  					( ret = hooks.get( elem, "value" ) ) !== undefined
  				) {
  					return ret;
  				}

  				ret = elem.value;

  				// Handle most common string cases
  				if ( typeof ret === "string" ) {
  					return ret.replace( rreturn, "" );
  				}

  				// Handle cases where value is null/undef or number
  				return ret == null ? "" : ret;
  			}

  			return;
  		}

  		valueIsFunction = isFunction( value );

  		return this.each( function( i ) {
  			var val;

  			if ( this.nodeType !== 1 ) {
  				return;
  			}

  			if ( valueIsFunction ) {
  				val = value.call( this, i, jQuery( this ).val() );
  			} else {
  				val = value;
  			}

  			// Treat null/undefined as ""; convert numbers to string
  			if ( val == null ) {
  				val = "";

  			} else if ( typeof val === "number" ) {
  				val += "";

  			} else if ( Array.isArray( val ) ) {
  				val = jQuery.map( val, function( value ) {
  					return value == null ? "" : value + "";
  				} );
  			}

  			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

  			// If set returns undefined, fall back to normal setting
  			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
  				this.value = val;
  			}
  		} );
  	}
  } );

  jQuery.extend( {
  	valHooks: {
  		option: {
  			get: function( elem ) {

  				var val = jQuery.find.attr( elem, "value" );
  				return val != null ?
  					val :

  					// Support: IE <=10 - 11 only
  					// option.text throws exceptions (trac-14686, trac-14858)
  					// Strip and collapse whitespace
  					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
  					stripAndCollapse( jQuery.text( elem ) );
  			}
  		},
  		select: {
  			get: function( elem ) {
  				var value, option, i,
  					options = elem.options,
  					index = elem.selectedIndex,
  					one = elem.type === "select-one",
  					values = one ? null : [],
  					max = one ? index + 1 : options.length;

  				if ( index < 0 ) {
  					i = max;

  				} else {
  					i = one ? index : 0;
  				}

  				// Loop through all the selected options
  				for ( ; i < max; i++ ) {
  					option = options[ i ];

  					// Support: IE <=9 only
  					// IE8-9 doesn't update selected after form reset (trac-2551)
  					if ( ( option.selected || i === index ) &&

  							// Don't return options that are disabled or in a disabled optgroup
  							!option.disabled &&
  							( !option.parentNode.disabled ||
  								!nodeName( option.parentNode, "optgroup" ) ) ) {

  						// Get the specific value for the option
  						value = jQuery( option ).val();

  						// We don't need an array for one selects
  						if ( one ) {
  							return value;
  						}

  						// Multi-Selects return an array
  						values.push( value );
  					}
  				}

  				return values;
  			},

  			set: function( elem, value ) {
  				var optionSet, option,
  					options = elem.options,
  					values = jQuery.makeArray( value ),
  					i = options.length;

  				while ( i-- ) {
  					option = options[ i ];

  					/* eslint-disable no-cond-assign */

  					if ( option.selected =
  						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
  					) {
  						optionSet = true;
  					}

  					/* eslint-enable no-cond-assign */
  				}

  				// Force browsers to behave consistently when non-matching value is set
  				if ( !optionSet ) {
  					elem.selectedIndex = -1;
  				}
  				return values;
  			}
  		}
  	}
  } );

  // Radios and checkboxes getter/setter
  jQuery.each( [ "radio", "checkbox" ], function() {
  	jQuery.valHooks[ this ] = {
  		set: function( elem, value ) {
  			if ( Array.isArray( value ) ) {
  				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
  			}
  		}
  	};
  	if ( !support.checkOn ) {
  		jQuery.valHooks[ this ].get = function( elem ) {
  			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
  		};
  	}
  } );




  // Return jQuery for attributes-only inclusion


  // Cross-browser xml parsing
  jQuery.parseXML = function( data ) {
  	var xml, parserErrorElem;
  	if ( !data || typeof data !== "string" ) {
  		return null;
  	}

  	// Support: IE 9 - 11 only
  	// IE throws on parseFromString with invalid input.
  	try {
  		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
  	} catch ( e ) {}

  	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
  	if ( !xml || parserErrorElem ) {
  		jQuery.error( "Invalid XML: " + (
  			parserErrorElem ?
  				jQuery.map( parserErrorElem.childNodes, function( el ) {
  					return el.textContent;
  				} ).join( "\n" ) :
  				data
  		) );
  	}
  	return xml;
  };


  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  	stopPropagationCallback = function( e ) {
  		e.stopPropagation();
  	};

  jQuery.extend( jQuery.event, {

  	trigger: function( event, data, elem, onlyHandlers ) {

  		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
  			eventPath = [ elem || document ],
  			type = hasOwn.call( event, "type" ) ? event.type : event,
  			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

  		cur = lastElement = tmp = elem = elem || document;

  		// Don't do events on text and comment nodes
  		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
  			return;
  		}

  		// focus/blur morphs to focusin/out; ensure we're not firing them right now
  		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
  			return;
  		}

  		if ( type.indexOf( "." ) > -1 ) {

  			// Namespaced trigger; create a regexp to match event type in handle()
  			namespaces = type.split( "." );
  			type = namespaces.shift();
  			namespaces.sort();
  		}
  		ontype = type.indexOf( ":" ) < 0 && "on" + type;

  		// Caller can pass in a jQuery.Event object, Object, or just an event type string
  		event = event[ jQuery.expando ] ?
  			event :
  			new jQuery.Event( type, typeof event === "object" && event );

  		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
  		event.isTrigger = onlyHandlers ? 2 : 3;
  		event.namespace = namespaces.join( "." );
  		event.rnamespace = event.namespace ?
  			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
  			null;

  		// Clean up the event in case it is being reused
  		event.result = undefined;
  		if ( !event.target ) {
  			event.target = elem;
  		}

  		// Clone any incoming data and prepend the event, creating the handler arg list
  		data = data == null ?
  			[ event ] :
  			jQuery.makeArray( data, [ event ] );

  		// Allow special events to draw outside the lines
  		special = jQuery.event.special[ type ] || {};
  		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
  			return;
  		}

  		// Determine event propagation path in advance, per W3C events spec (trac-9951)
  		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
  		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

  			bubbleType = special.delegateType || type;
  			if ( !rfocusMorph.test( bubbleType + type ) ) {
  				cur = cur.parentNode;
  			}
  			for ( ; cur; cur = cur.parentNode ) {
  				eventPath.push( cur );
  				tmp = cur;
  			}

  			// Only add window if we got to document (e.g., not plain obj or detached DOM)
  			if ( tmp === ( elem.ownerDocument || document ) ) {
  				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
  			}
  		}

  		// Fire handlers on the event path
  		i = 0;
  		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
  			lastElement = cur;
  			event.type = i > 1 ?
  				bubbleType :
  				special.bindType || type;

  			// jQuery handler
  			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
  				dataPriv.get( cur, "handle" );
  			if ( handle ) {
  				handle.apply( cur, data );
  			}

  			// Native handler
  			handle = ontype && cur[ ontype ];
  			if ( handle && handle.apply && acceptData( cur ) ) {
  				event.result = handle.apply( cur, data );
  				if ( event.result === false ) {
  					event.preventDefault();
  				}
  			}
  		}
  		event.type = type;

  		// If nobody prevented the default action, do it now
  		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

  			if ( ( !special._default ||
  				special._default.apply( eventPath.pop(), data ) === false ) &&
  				acceptData( elem ) ) {

  				// Call a native DOM method on the target with the same name as the event.
  				// Don't do default actions on window, that's where global variables be (trac-6170)
  				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

  					// Don't re-trigger an onFOO event when we call its FOO() method
  					tmp = elem[ ontype ];

  					if ( tmp ) {
  						elem[ ontype ] = null;
  					}

  					// Prevent re-triggering of the same event, since we already bubbled it above
  					jQuery.event.triggered = type;

  					if ( event.isPropagationStopped() ) {
  						lastElement.addEventListener( type, stopPropagationCallback );
  					}

  					elem[ type ]();

  					if ( event.isPropagationStopped() ) {
  						lastElement.removeEventListener( type, stopPropagationCallback );
  					}

  					jQuery.event.triggered = undefined;

  					if ( tmp ) {
  						elem[ ontype ] = tmp;
  					}
  				}
  			}
  		}

  		return event.result;
  	},

  	// Piggyback on a donor event to simulate a different one
  	// Used only for `focus(in | out)` events
  	simulate: function( type, elem, event ) {
  		var e = jQuery.extend(
  			new jQuery.Event(),
  			event,
  			{
  				type: type,
  				isSimulated: true
  			}
  		);

  		jQuery.event.trigger( e, null, elem );
  	}

  } );

  jQuery.fn.extend( {

  	trigger: function( type, data ) {
  		return this.each( function() {
  			jQuery.event.trigger( type, data, this );
  		} );
  	},
  	triggerHandler: function( type, data ) {
  		var elem = this[ 0 ];
  		if ( elem ) {
  			return jQuery.event.trigger( type, data, elem, true );
  		}
  	}
  } );


  var
  	rbracket = /\[\]$/,
  	rCRLF = /\r?\n/g,
  	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
  	rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams( prefix, obj, traditional, add ) {
  	var name;

  	if ( Array.isArray( obj ) ) {

  		// Serialize array item.
  		jQuery.each( obj, function( i, v ) {
  			if ( traditional || rbracket.test( prefix ) ) {

  				// Treat each array item as a scalar.
  				add( prefix, v );

  			} else {

  				// Item is non-scalar (array or object), encode its numeric index.
  				buildParams(
  					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
  					v,
  					traditional,
  					add
  				);
  			}
  		} );

  	} else if ( !traditional && toType( obj ) === "object" ) {

  		// Serialize object item.
  		for ( name in obj ) {
  			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
  		}

  	} else {

  		// Serialize scalar item.
  		add( prefix, obj );
  	}
  }

  // Serialize an array of form elements or a set of
  // key/values into a query string
  jQuery.param = function( a, traditional ) {
  	var prefix,
  		s = [],
  		add = function( key, valueOrFunction ) {

  			// If value is a function, invoke it and use its return value
  			var value = isFunction( valueOrFunction ) ?
  				valueOrFunction() :
  				valueOrFunction;

  			s[ s.length ] = encodeURIComponent( key ) + "=" +
  				encodeURIComponent( value == null ? "" : value );
  		};

  	if ( a == null ) {
  		return "";
  	}

  	// If an array was passed in, assume that it is an array of form elements.
  	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

  		// Serialize the form elements
  		jQuery.each( a, function() {
  			add( this.name, this.value );
  		} );

  	} else {

  		// If traditional, encode the "old" way (the way 1.3.2 or older
  		// did it), otherwise encode params recursively.
  		for ( prefix in a ) {
  			buildParams( prefix, a[ prefix ], traditional, add );
  		}
  	}

  	// Return the resulting serialization
  	return s.join( "&" );
  };

  jQuery.fn.extend( {
  	serialize: function() {
  		return jQuery.param( this.serializeArray() );
  	},
  	serializeArray: function() {
  		return this.map( function() {

  			// Can add propHook for "elements" to filter or add form elements
  			var elements = jQuery.prop( this, "elements" );
  			return elements ? jQuery.makeArray( elements ) : this;
  		} ).filter( function() {
  			var type = this.type;

  			// Use .is( ":disabled" ) so that fieldset[disabled] works
  			return this.name && !jQuery( this ).is( ":disabled" ) &&
  				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
  				( this.checked || !rcheckableType.test( type ) );
  		} ).map( function( _i, elem ) {
  			var val = jQuery( this ).val();

  			if ( val == null ) {
  				return null;
  			}

  			if ( Array.isArray( val ) ) {
  				return jQuery.map( val, function( val ) {
  					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  				} );
  			}

  			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  		} ).get();
  	}
  } );


  jQuery.fn.extend( {
  	wrapAll: function( html ) {
  		var wrap;

  		if ( this[ 0 ] ) {
  			if ( isFunction( html ) ) {
  				html = html.call( this[ 0 ] );
  			}

  			// The elements to wrap the target around
  			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

  			if ( this[ 0 ].parentNode ) {
  				wrap.insertBefore( this[ 0 ] );
  			}

  			wrap.map( function() {
  				var elem = this;

  				while ( elem.firstElementChild ) {
  					elem = elem.firstElementChild;
  				}

  				return elem;
  			} ).append( this );
  		}

  		return this;
  	},

  	wrapInner: function( html ) {
  		if ( isFunction( html ) ) {
  			return this.each( function( i ) {
  				jQuery( this ).wrapInner( html.call( this, i ) );
  			} );
  		}

  		return this.each( function() {
  			var self = jQuery( this ),
  				contents = self.contents();

  			if ( contents.length ) {
  				contents.wrapAll( html );

  			} else {
  				self.append( html );
  			}
  		} );
  	},

  	wrap: function( html ) {
  		var htmlIsFunction = isFunction( html );

  		return this.each( function( i ) {
  			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
  		} );
  	},

  	unwrap: function( selector ) {
  		this.parent( selector ).not( "body" ).each( function() {
  			jQuery( this ).replaceWith( this.childNodes );
  		} );
  		return this;
  	}
  } );


  jQuery.expr.pseudos.hidden = function( elem ) {
  	return !jQuery.expr.pseudos.visible( elem );
  };
  jQuery.expr.pseudos.visible = function( elem ) {
  	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
  };




  // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337
  support.createHTMLDocument = ( function() {
  	var body = document.implementation.createHTMLDocument( "" ).body;
  	body.innerHTML = "<form></form><form></form>";
  	return body.childNodes.length === 2;
  } )();


  // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string
  jQuery.parseHTML = function( data, context, keepScripts ) {
  	if ( typeof data !== "string" ) {
  		return [];
  	}
  	if ( typeof context === "boolean" ) {
  		keepScripts = context;
  		context = false;
  	}

  	var base, parsed, scripts;

  	if ( !context ) {

  		// Stop scripts or inline event handlers from being executed immediately
  		// by using document.implementation
  		if ( support.createHTMLDocument ) {
  			context = document.implementation.createHTMLDocument( "" );

  			// Set the base href for the created document
  			// so any parsed elements with URLs
  			// are based on the document's URL (gh-2965)
  			base = context.createElement( "base" );
  			base.href = document.location.href;
  			context.head.appendChild( base );
  		} else {
  			context = document;
  		}
  	}

  	parsed = rsingleTag.exec( data );
  	scripts = !keepScripts && [];

  	// Single tag
  	if ( parsed ) {
  		return [ context.createElement( parsed[ 1 ] ) ];
  	}

  	parsed = buildFragment( [ data ], context, scripts );

  	if ( scripts && scripts.length ) {
  		jQuery( scripts ).remove();
  	}

  	return jQuery.merge( [], parsed.childNodes );
  };


  jQuery.offset = {
  	setOffset: function( elem, options, i ) {
  		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
  			position = jQuery.css( elem, "position" ),
  			curElem = jQuery( elem ),
  			props = {};

  		// Set position first, in-case top/left are set even on static elem
  		if ( position === "static" ) {
  			elem.style.position = "relative";
  		}

  		curOffset = curElem.offset();
  		curCSSTop = jQuery.css( elem, "top" );
  		curCSSLeft = jQuery.css( elem, "left" );
  		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
  			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

  		// Need to be able to calculate position if either
  		// top or left is auto and position is either absolute or fixed
  		if ( calculatePosition ) {
  			curPosition = curElem.position();
  			curTop = curPosition.top;
  			curLeft = curPosition.left;

  		} else {
  			curTop = parseFloat( curCSSTop ) || 0;
  			curLeft = parseFloat( curCSSLeft ) || 0;
  		}

  		if ( isFunction( options ) ) {

  			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
  			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
  		}

  		if ( options.top != null ) {
  			props.top = ( options.top - curOffset.top ) + curTop;
  		}
  		if ( options.left != null ) {
  			props.left = ( options.left - curOffset.left ) + curLeft;
  		}

  		if ( "using" in options ) {
  			options.using.call( elem, props );

  		} else {
  			curElem.css( props );
  		}
  	}
  };

  jQuery.fn.extend( {

  	// offset() relates an element's border box to the document origin
  	offset: function( options ) {

  		// Preserve chaining for setter
  		if ( arguments.length ) {
  			return options === undefined ?
  				this :
  				this.each( function( i ) {
  					jQuery.offset.setOffset( this, options, i );
  				} );
  		}

  		var rect, win,
  			elem = this[ 0 ];

  		if ( !elem ) {
  			return;
  		}

  		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
  		// Support: IE <=11 only
  		// Running getBoundingClientRect on a
  		// disconnected node in IE throws an error
  		if ( !elem.getClientRects().length ) {
  			return { top: 0, left: 0 };
  		}

  		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
  		rect = elem.getBoundingClientRect();
  		win = elem.ownerDocument.defaultView;
  		return {
  			top: rect.top + win.pageYOffset,
  			left: rect.left + win.pageXOffset
  		};
  	},

  	// position() relates an element's margin box to its offset parent's padding box
  	// This corresponds to the behavior of CSS absolute positioning
  	position: function() {
  		if ( !this[ 0 ] ) {
  			return;
  		}

  		var offsetParent, offset, doc,
  			elem = this[ 0 ],
  			parentOffset = { top: 0, left: 0 };

  		// position:fixed elements are offset from the viewport, which itself always has zero offset
  		if ( jQuery.css( elem, "position" ) === "fixed" ) {

  			// Assume position:fixed implies availability of getBoundingClientRect
  			offset = elem.getBoundingClientRect();

  		} else {
  			offset = this.offset();

  			// Account for the *real* offset parent, which can be the document or its root element
  			// when a statically positioned element is identified
  			doc = elem.ownerDocument;
  			offsetParent = elem.offsetParent || doc.documentElement;
  			while ( offsetParent &&
  				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
  				jQuery.css( offsetParent, "position" ) === "static" ) {

  				offsetParent = offsetParent.parentNode;
  			}
  			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

  				// Incorporate borders into its offset, since they are outside its content origin
  				parentOffset = jQuery( offsetParent ).offset();
  				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
  				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
  			}
  		}

  		// Subtract parent offsets and element margins
  		return {
  			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
  			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
  		};
  	},

  	// This method will return documentElement in the following cases:
  	// 1) For the element inside the iframe without offsetParent, this method will return
  	//    documentElement of the parent window
  	// 2) For the hidden or detached element
  	// 3) For body or html element, i.e. in case of the html node - it will return itself
  	//
  	// but those exceptions were never presented as a real life use-cases
  	// and might be considered as more preferable results.
  	//
  	// This logic, however, is not guaranteed and can change at any point in the future
  	offsetParent: function() {
  		return this.map( function() {
  			var offsetParent = this.offsetParent;

  			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
  				offsetParent = offsetParent.offsetParent;
  			}

  			return offsetParent || documentElement;
  		} );
  	}
  } );

  // Create scrollLeft and scrollTop methods
  jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
  	var top = "pageYOffset" === prop;

  	jQuery.fn[ method ] = function( val ) {
  		return access( this, function( elem, method, val ) {

  			// Coalesce documents and windows
  			var win;
  			if ( isWindow( elem ) ) {
  				win = elem;
  			} else if ( elem.nodeType === 9 ) {
  				win = elem.defaultView;
  			}

  			if ( val === undefined ) {
  				return win ? win[ prop ] : elem[ method ];
  			}

  			if ( win ) {
  				win.scrollTo(
  					!top ? val : win.pageXOffset,
  					top ? val : win.pageYOffset
  				);

  			} else {
  				elem[ method ] = val;
  			}
  		}, method, val, arguments.length );
  	};
  } );

  // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here
  jQuery.each( [ "top", "left" ], function( _i, prop ) {
  	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
  		function( elem, computed ) {
  			if ( computed ) {
  				computed = curCSS( elem, prop );

  				// If curCSS returns percentage, fallback to offset
  				return rnumnonpx.test( computed ) ?
  					jQuery( elem ).position()[ prop ] + "px" :
  					computed;
  			}
  		}
  	);
  } );


  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
  	jQuery.each( {
  		padding: "inner" + name,
  		content: type,
  		"": "outer" + name
  	}, function( defaultExtra, funcName ) {

  		// Margin is only for outerHeight, outerWidth
  		jQuery.fn[ funcName ] = function( margin, value ) {
  			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
  				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

  			return access( this, function( elem, type, value ) {
  				var doc;

  				if ( isWindow( elem ) ) {

  					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
  					return funcName.indexOf( "outer" ) === 0 ?
  						elem[ "inner" + name ] :
  						elem.document.documentElement[ "client" + name ];
  				}

  				// Get document width or height
  				if ( elem.nodeType === 9 ) {
  					doc = elem.documentElement;

  					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
  					// whichever is greatest
  					return Math.max(
  						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
  						elem.body[ "offset" + name ], doc[ "offset" + name ],
  						doc[ "client" + name ]
  					);
  				}

  				return value === undefined ?

  					// Get width or height on the element, requesting but not forcing parseFloat
  					jQuery.css( elem, type, extra ) :

  					// Set width or height on the element
  					jQuery.style( elem, type, value, extra );
  			}, type, chainable ? margin : undefined, chainable );
  		};
  	} );
  } );


  jQuery.fn.extend( {

  	bind: function( types, data, fn ) {
  		return this.on( types, null, data, fn );
  	},
  	unbind: function( types, fn ) {
  		return this.off( types, null, fn );
  	},

  	delegate: function( selector, types, data, fn ) {
  		return this.on( types, selector, data, fn );
  	},
  	undelegate: function( selector, types, fn ) {

  		// ( namespace ) or ( selector, types [, fn] )
  		return arguments.length === 1 ?
  			this.off( selector, "**" ) :
  			this.off( types, selector || "**", fn );
  	},

  	hover: function( fnOver, fnOut ) {
  		return this
  			.on( "mouseenter", fnOver )
  			.on( "mouseleave", fnOut || fnOver );
  	}
  } );

  jQuery.each(
  	( "blur focus focusin focusout resize scroll click dblclick " +
  	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
  	function( _i, name ) {

  		// Handle event binding
  		jQuery.fn[ name ] = function( data, fn ) {
  			return arguments.length > 0 ?
  				this.on( name, null, data, fn ) :
  				this.trigger( name );
  		};
  	}
  );




  // Support: Android <=4.0 only
  // Make sure we trim BOM and NBSP
  // Require that the "whitespace run" starts from a non-whitespace
  // to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
  var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

  // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon
  jQuery.proxy = function( fn, context ) {
  	var tmp, args, proxy;

  	if ( typeof context === "string" ) {
  		tmp = fn[ context ];
  		context = fn;
  		fn = tmp;
  	}

  	// Quick check to determine if target is callable, in the spec
  	// this throws a TypeError, but we will just return undefined.
  	if ( !isFunction( fn ) ) {
  		return undefined;
  	}

  	// Simulated bind
  	args = slice.call( arguments, 2 );
  	proxy = function() {
  		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
  	};

  	// Set the guid of unique handler to the same of original handler, so it can be removed
  	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

  	return proxy;
  };

  jQuery.holdReady = function( hold ) {
  	if ( hold ) {
  		jQuery.readyWait++;
  	} else {
  		jQuery.ready( true );
  	}
  };
  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;

  jQuery.now = Date.now;

  jQuery.isNumeric = function( obj ) {

  	// As of jQuery 3.0, isNumeric is limited to
  	// strings and numbers (primitives or objects)
  	// that can be coerced to finite numbers (gh-2662)
  	var type = jQuery.type( obj );
  	return ( type === "number" || type === "string" ) &&

  		// parseFloat NaNs numeric-cast false positives ("")
  		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
  		// subtraction forces infinities to NaN
  		!isNaN( obj - parseFloat( obj ) );
  };

  jQuery.trim = function( text ) {
  	return text == null ?
  		"" :
  		( text + "" ).replace( rtrim, "$1" );
  };



  // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.

  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

  if ( typeof define === "function" && define.amd ) {
  	define( "jquery", [], function() {
  		return jQuery;
  	} );
  }




  var

  	// Map over jQuery in case of overwrite
  	_jQuery = window.jQuery,

  	// Map over the $ in case of overwrite
  	_$ = window.$;

  jQuery.noConflict = function( deep ) {
  	if ( window.$ === jQuery ) {
  		window.$ = _$;
  	}

  	if ( deep && window.jQuery === jQuery ) {
  		window.jQuery = _jQuery;
  	}

  	return jQuery;
  };

  // Expose jQuery and $ identifiers, even in AMD
  // (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (trac-13566)
  if ( typeof noGlobal === "undefined" ) {
  	window.jQuery = window.$ = jQuery;
  }




  return jQuery;
  } );

  var jQuery = window.jQuery || window.$;

  const SVG_NS = "http://www.w3.org/2000/svg";

  function applyAttrs(el, attrs = {}) {
    Object.entries(attrs).forEach(([key, value]) => {
      if (value === undefined || value === null) return;
      const attrName = key === "class_" ? "class" : key;
      el.setAttribute(attrName, String(value));
    });
  }

  class SvgPathBuilder {
    constructor() {
      this.d = "";
    }
    move(x, y) {
      this.d += `M${x} ${y}`;
      return this;
    }
    line(x, y, relative = false) {
      this.d += relative ? ` l${x} ${y}` : ` L${x} ${y}`;
      return this;
    }
    horiz(x) {
      this.d += ` H${x}`;
      return this;
    }
    vert(y) {
      this.d += ` V${y}`;
      return this;
    }
    close() {
      this.d += " Z";
      return this;
    }
    toString() {
      return this.d.trim();
    }
  }

  class SvgWrapper {
    constructor(root) {
      this.root = root;
      this.doc = root.ownerDocument;
    }

    configure(attrs = {}) {
      applyAttrs(this.root, attrs);
      return this.root;
    }

    group(parent = this.root, attrs = {}) {
      const g = this.doc.createElementNS(SVG_NS, "g");
      applyAttrs(g, attrs);
      parent.appendChild(g);
      return g;
    }

    rect(parent, x, y, width, height, rx = 0, ry = 0, attrs = {}) {
      const el = this.doc.createElementNS(SVG_NS, "rect");
      Object.assign(el, { x, y, width, height, rx, ry });
      applyAttrs(el, attrs);
      parent.appendChild(el);
      return el;
    }

    line(parent, x1, y1, x2, y2, attrs = {}) {
      const el = this.doc.createElementNS(SVG_NS, "line");
      applyAttrs(el, { x1, y1, x2, y2, ...attrs });
      parent.appendChild(el);
      return el;
    }

    text(parent, x, y, textNode, attrs = {}) {
      const el = this.doc.createElementNS(SVG_NS, "text");
      applyAttrs(el, { x, y, ...attrs });
      if (textNode instanceof this.doc.defaultView.Text || textNode instanceof this.doc.defaultView.SVGTextContentElement) {
        el.appendChild(textNode);
      } else if (textNode && textNode.nodeType) {
        el.appendChild(textNode);
      }
      parent.appendChild(el);
      return el;
    }

    createText() {
      const textNode = this.doc.createElementNS(SVG_NS, "text");
      return {
        string: str => {
          textNode.textContent = str;
          return textNode;
        },
      };
    }

    createPath() {
      return new SvgPathBuilder();
    }

    path(parent, pathObj, attrs = {}) {
      const el = this.doc.createElementNS(SVG_NS, "path");
      const d = typeof pathObj === "string" ? pathObj : pathObj?.toString?.();
      if (d) el.setAttribute("d", d);
      applyAttrs(el, attrs);
      parent.appendChild(el);
      return el;
    }

    change(element, attrs = {}) {
      applyAttrs(element, attrs);
      return element;
    }
  }

  jQuery.fn.svg = function(callback) {
    return this.each(function() {
      const host = this;
      const doc = host.ownerDocument;
      let svg = host.querySelector("svg");
      if (!svg) {
        svg = doc.createElementNS(SVG_NS, "svg");
        host.appendChild(svg);
      }
      const wrapper = new SvgWrapper(svg);
      if (typeof callback === "function") {
        callback.call(host, wrapper);
      }
    });
  };

  var css = `/* --- REGPICT --- */
text.regBitNumMiddle {
    text-anchor: middle;
    fill: grey;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
}
text.regBitNumMiddleTop {
    text-anchor: middle;
    fill: grey;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    alignment-baseline: middle;
    dominant-baseline: middle;
    text-anchor: middle;
}
text.regBitNumMiddleBottom {
    text-anchor: middle;
    fill: grey;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    alignment-baseline: middle;
    dominant-baseline: middle;
    text-anchor: middle;
}
text.regBitNumLeft {
    text-anchor: end;
    fill: grey;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
}
text.regBitNumRight {
    text-anchor: start;
    fill: grey;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
}
text.regBitNumFieldLeft {
    text-anchor: end;
    fill: grey;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: smaller;
    font-weight: bold;
}
text.regBitNumFieldRight {
    text-anchor: start;
    fill: grey;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: smaller;
    font-weight: bold;
}
text.regFieldValue {
    text-anchor: middle;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-weight: bold;
}
text.regFieldValueMore {
    text-anchor: middle;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-weight: normal;
}
text.regFieldValueText {
    text-anchor: middle;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-weight: bold;
}
text.regFieldName {
    text-anchor: middle;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-weight: normal;
}
text.regFieldName:hover {
    cursor: pointer;
    text-decoration: underline;
}
path.regFieldBox {
    stroke: black;
    stroke-width: 0.8;
    fill: lightgray;
    opacity: 1.0;
}
text.regBitWidth {
    text-anchor: middle;
    fill: gray;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: smaller;
}
path.regBitBracket {
    stroke: gray;
    stroke-width: 1.0;
    fill: white;
    opacity: 1.0;
}
path.regBitLine {
    stroke: gray;
    stroke-width: 1.0;
    fill: white;
    opacity: 1.0;
}
path.regBitEdge {
    stroke: gray;
    stroke-width: 1.0;
    fill: white;
    opacity: 1.0;
}
text.regCaption {
    text-anchor: middle;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
}
text.regBitTag {
    text-anchor: middle;
    fill: gray;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: smaller;
}
text.regBitTag:hover {
    cursor: pointer;
    text-decoration: underline;
}
text.regFieldValueLeft {
    text-anchor: end;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: small;
    font-weight: bold;
}
text.regFieldValueLeft:hover {
    cursor: pointer;
    text-decoration: underline;
}
text.regFieldValueRight {
    text-anchor: start;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: small;
    font-weight: bold;
}
text.regFieldValueRight:hover {
    cursor: pointer;
    text-decoration: underline;
}
path.regFieldExternal {
    stroke: black;
    stroke-width: 0.8;
    fill: yellow;
    opacity: 1.0;
}
path.regFieldExternal0 {
    stroke: black;
    stroke-width: 0.8;
    fill: yellow;
    opacity: 1.0;
}
path.regFieldExternal1 {
    stroke: black;
    stroke-width: 0.8;
    fill: orange;
    opacity: 1.0;
}
text.regBitNumMidBoundary {
    text-anchor: middle;
    fill: gray;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
}
text.regBitNumLeftBoundary {
    text-anchor: start;
    fill: gray;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
}
text.regBitNumRightBoundary {
    text-anchor: end;
    fill: gray;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
}
path.regFieldHidden {
    stroke: black;
    stroke-width: 0.8;
    fill: white;
    opacity: 0.0;
}
.regRowTagLeft {
    text-anchor: end;
    fill: gray;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: smaller;
}
.regRowTagRight {
    text-anchor: start;
    fill: gray;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: smaller;
}
.regCaption {
    text-anchor: middle;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: 14pt;
    font-weight: bold;
}
.regCaption:hover {
    cursor: pointer;
    text-decoration: underline;
}
.regBitBracket {
    stroke: gray;
    stroke-width: 1.0;
    fill: white;
    opacity: 1.0;
}
.regBitLine {
    stroke: gray;
    stroke-width: 1.0;
    fill: white;
    opacity: 1.0;
}
.regBitEdge {
    stroke: gray;
    stroke-width: 1.0;
    fill: white;
    opacity: 1.0;
}
.regError {
    fill: red;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: larger;
    font-weight: bold;
}
.regAllZero {
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: 12pt;
    fill: gray;
}
text.regFieldExtendsLeft {
    text-anchor: end;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: 12pt;
    font-weight: bold;
}
text.regFieldExtendsRight {
    text-anchor: start;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: 12pt;
    font-weight: bold;
}
.regFieldValueText {
    text-anchor: middle;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: 12pt;
    font-weight: bold;
}
.regFieldValueLeftText {
    text-anchor: end;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: 12pt;
    font-weight: bold;
}
.regFieldValueRightText {
    text-anchor: start;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: 12pt;
    font-weight: bold;
}
.regBitLabel {
    text-anchor: middle;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
}
.regBitLabel:hover {
    cursor: pointer;
    text-decoration: underline;
}
text.regRowTagLeft {
    text-anchor: end;
    fill: gray;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: smaller;
}
text.regRowTagRight {
    text-anchor: start;
    fill: gray;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: smaller;
}

figure.register,
figure.message,
figure.capability,
figure.memoryBlock,
figure.regFieldExternal,
figure.regFieldHidden {
    text-align: center;
}

figure.register > figcaption,
figure.message > figcaption,
figure.capability > figcaption,
figure.memoryBlock > figcaption,
figure.regFieldExternal > figcaption,
figure.regFieldHidden > figcaption {
    text-align: center;
}

figcaption svg text:hover {
    cursor: pointer;
    text-decoration: underline;
}

svg.isRegister text.regFieldName,
svg.isMemoryBlock text.regFieldName,
svg.isMessage text.regFieldName {
    text-anchor: middle;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: larger;
}
svg.isRegister text.regFieldName.regFieldValueText,
svg.isMemoryBlock text.regFieldName.regFieldValueText,
svg.isMessage text.regFieldName.regFieldValueText {
    text-anchor: middle;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: 12pt;
    font-weight: bold;
}
svg.isRegister text.regFieldName.regFieldValueLeftText,
svg.isMemoryBlock text.regFieldName.regFieldValueLeftText,
svg.isMessage text.regFieldName.regFieldValueLeftText {
    text-anchor: end;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: 12pt;
    font-weight: bold;
}
svg.isRegister text.regFieldName.regFieldValueRightText,
svg.isMemoryBlock text.regFieldName.regFieldValueRightText,
svg.isMessage text.regFieldName.regFieldValueRightText {
    text-anchor: start;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: 12pt;
    font-weight: bold;
}
svg.isRegister text.regFieldValueText,
svg.isMemoryBlock text.regFieldValueText,
svg.isMessage text.regFieldValueText {
    text-anchor: middle;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: 12pt;
    font-weight: bold;
}
svg.isRegister text.regFieldValueLeftText,
svg.isMemoryBlock text.regFieldValueLeftText,
svg.isMessage text.regFieldValueLeftText {
    text-anchor: end;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: 12pt;
    font-weight: bold;
}
svg.isRegister text.regFieldValueRightText,
svg.isMemoryBlock text.regFieldValueRightText,
svg.isMessage text.regFieldValueRightText {
    text-anchor: start;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: 12pt;
    font-weight: bold;
}
svg.isRegister text.regBitNumMidBoundary,
svg.isMemoryBlock text.regBitNumMidBoundary,
svg.isMessage text.regBitNumMidBoundary {
    text-anchor: middle;
    fill: gray;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: smaller;
}
svg.isRegister text.regBitNumLeftBoundary,
svg.isMemoryBlock text.regBitNumLeftBoundary,
svg.isMessage text.regBitNumLeftBoundary {
    text-anchor: start;
    fill: gray;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
}
svg.isRegister text.regBitNumRightBoundary,
svg.isMemoryBlock text.regBitNumRightBoundary,
svg.isMessage text.regBitNumRightBoundary {
    text-anchor: end;
    fill: gray;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
}
svg.isRegister text.regFieldName,
svg.isMemoryBlock text.regFieldName,
svg.isMessage text.regFieldName {
    text-anchor: middle;
    font-family: "Source Sans Pro", Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Helvetica Neue", Arial, sans-serif;
    font-size: larger;
}
svg.isRegister text.regFieldName:hover,
svg.isMemoryBlock text.regFieldName:hover,
svg.isMessage text.regFieldName:hover {
    cursor: pointer;
    text-decoration: underline;
}
svg.isRegister .regFieldHidden,
svg.isMemoryBlock .regFieldHidden,
svg.isMessage .regFieldHidden {
    opacity: 0.0;
}
svg.isRegister .regFieldExternal,
svg.isMemoryBlock .regFieldExternal,
svg.isMessage .regFieldExternal {
    opacity: 1.0;
}
svg.isRegister .regFieldExternal0,
svg.isMemoryBlock .regFieldExternal0,
svg.isMessage .regFieldExternal0 {
    fill: yellow;
}
svg.isRegister .regFieldExternal1,
svg.isMemoryBlock .regFieldExternal1,
svg.isMessage .regFieldExternal1 {
    fill: orange;
}
svg.isRegister .regFieldExternal2,
svg.isMemoryBlock .regFieldExternal2,
svg.isMessage .regFieldExternal2 {
    fill: lightgreen;
}
svg.isRegister .regFieldExternal3,
svg.isMemoryBlock .regFieldExternal3,
svg.isMessage .regFieldExternal3 {
    fill: lightblue;
}
svg.isRegister .regFieldExternal4,
svg.isMemoryBlock .regFieldExternal4,
svg.isMessage .regFieldExternal4 {
    fill: khaki;
}
svg.isRegister .regFieldExternal5,
svg.isMemoryBlock .regFieldExternal5,
svg.isMessage .regFieldExternal5 {
    fill: burlywood;
}
svg.isRegister .regFieldExternal6,
svg.isMemoryBlock .regFieldExternal6,
svg.isMessage .regFieldExternal6 {
    fill: aquamarine;
}
svg.isRegister .regFieldExternal7,
svg.isMemoryBlock .regFieldExternal7,
svg.isMessage .regFieldExternal7 {
    fill: thistle;
}
svg.isRegister .regFieldExternal8,
svg.isMemoryBlock .regFieldExternal8,
svg.isMessage .regFieldExternal8 {
    fill: peru;
}
svg.isRegister .regFieldExternal9,
svg.isMemoryBlock .regFieldExternal9,
svg.isMessage .regFieldExternal9 {
    fill: lightgray;
}

svg.isRegister .regFieldExternal.regFieldExternal0,
svg.isMemoryBlock .regFieldExternal.regFieldExternal0,
svg.isMessage .regFieldExternal.regFieldExternal0 {
    fill: yellow;
}
svg.isRegister .regFieldExternal.regFieldExternal1,
svg.isMemoryBlock .regFieldExternal.regFieldExternal1,
svg.isMessage .regFieldExternal.regFieldExternal1 {
    fill: orange;
}
svg.isRegister .regFieldExternal.regFieldExternal2,
svg.isMemoryBlock .regFieldExternal.regFieldExternal2,
svg.isMessage .regFieldExternal.regFieldExternal2 {
    fill: lightgreen;
}
svg.isRegister .regFieldExternal.regFieldExternal3,
svg.isMemoryBlock .regFieldExternal.regFieldExternal3,
svg.isMessage .regFieldExternal.regFieldExternal3 {
    fill: lightblue;
}
svg.isRegister .regFieldExternal.regFieldExternal4,
svg.isMemoryBlock .regFieldExternal.regFieldExternal4,
svg.isMessage .regFieldExternal.regFieldExternal4 {
    fill: khaki;
}
svg.isRegister .regFieldExternal.regFieldExternal5,
svg.isMemoryBlock .regFieldExternal.regFieldExternal5,
svg.isMessage .regFieldExternal.regFieldExternal5 {
    fill: burlywood;
}
svg.isRegister .regFieldExternal.regFieldExternal6,
svg.isMemoryBlock .regFieldExternal.regFieldExternal6,
svg.isMessage .regFieldExternal.regFieldExternal6 {
    fill: aquamarine;
}
svg.isRegister .regFieldExternal.regFieldExternal7,
svg.isMemoryBlock .regFieldExternal.regFieldExternal7,
svg.isMessage .regFieldExternal.regFieldExternal7 {
    fill: thistle;
}
svg.isRegister .regFieldExternal.regFieldExternal8,
svg.isMemoryBlock .regFieldExternal.regFieldExternal8,
svg.isMessage .regFieldExternal.regFieldExternal8 {
    fill: peru;
}
svg.isRegister .regFieldExternal.regFieldExternal9,
svg.isMemoryBlock .regFieldExternal.regFieldExternal9,
svg.isMessage .regFieldExternal.regFieldExternal9 {
    fill: lightgray;
}
`;

  /*globals define */
  /*jslint plusplus:true, white:true, vars:true, regexp:true, nomen:true */
  /*jshint jquery:true, browser:true, funcscope:true, laxbreak:true, laxcomma:true */


  const name$j = "pcisig/regpict";


  if (!Number.prototype.radix) {
    /**
     }
     * object.radix(number, number, string)
     * Transform the number object to string in accordance with a scale of notation
     * If it is necessary the numeric string will aligned to right and filled by '0' character, by default
     *
     * @param  r number  Radix of scale of notation (it have to be greater or equal 2 and below or equal 36)
     * @param  n number  Width of numeric string
     * @param  c string  Padding chacracter (by default, '0')
     * @return  string  Numeric string
     * @access  public
     */
    Number.prototype.radix = function (r, n, c) {
      return this.toString(r).padding(-n, c);
    };
  }

  if (!Number.prototype.bin) {
    /**
     }
     * object.bin(number, string)
     * Transform the number object to string of binary presentation
     *
     * @param  n number  Width of numeric string
     * @param  c string  Padding chacracter (by default, '0')
     * @return  string  Numeric string
     * @access  public
     */
    Number.prototype.bin = function (n, c) {
      return this.radix(0x02, n, c);
    };
  }

  if (!Number.prototype.oct) {
    /**
     }
     * object.oct(number, string)
     * Transform the number object to string of octal presentation
     *
     * @param  n number  Width of numeric string
     * @param  c string  Padding chacracter (by default, '0')
     * @return  string  Numeric string
     * @access  public
     */
    Number.prototype.oct = function (n, c) {
      return this.radix(0x08, n, c);
    };
  }

  if (!Number.prototype.dec) {
    /**
     }
     * object.dec(number, string)
     * Transform the number object to string of decimal presentation
     *
     * @param  n number  Width of numeric string
     * @param  c string  Padding chacracter (by default, '0')
     * @return  string  Numeric string
     * @access  public
     */
    Number.prototype.dec = function (n, c) {
      return this.radix(0x0A, n, c);
    };
  }

  if (!Number.prototype.hexl) {
    /**
     }
     * object.hexl(number, string)
     * Transform the number object to string of hexadecimal presentation in lower-case of major characters (0-9 and a-f)
     *
     * @param  n number  Width of numeric string
     * @param  c string  Padding chacracter (by default, '0')
     * @return  string  Numeric string
     * @access  public
     */
    Number.prototype.hexl = function (n, c) {
      return this.radix(0x10, n, c);
    };
  }

  if (!Number.prototype.hex) {
    /**
     * object.hex(number, string)
     * Transform the number object to string of the hexadecimal presentation
     * in upper-case of major characters (0-9 and A-F)
     *
     * @param  n number  Width of numeric string
     * @param  c string  Padding chacracter (by default, '0')
     * @return  string  Numeric string
     * @access  public
     */
    Number.prototype.hex = function (n, c) {
      return this.radix(0x10, n, c).toUpperCase();
    };
  }

  if (!String.prototype.padding) {

    /**
     * object.padding(number, string)
     * Transform the string object to string of the actual width filling by the padding character (by default ' ')
     * Negative value of width means left padding, and positive value means right one
     *
     * @param  n number  Width of string
     * @param  c string  Padding chacracter (by default, ' ')
     * @return  string
     * @access  public
     */
    String.prototype.padding = function (n, c) {
      let val = this.valueOf();
      if (Math.abs(n) <= val.length) {
        return val;
      }
      let m = Math.max((Math.abs(n) - this.length) || 0, 0);
      let pad = Array(m + 1).join(String(c || " ").charAt(0));
      return (n < 0) ? pad + val : val + pad;
    };
  }

  if (!String.prototype.padLeft) {
    /**
     * object.padLeft(number, string)
     * Wrapper for object.padding
     * Transform the string object to string of the actual width adding the leading padding character (by default ' ')
     *
     * @param  n number  Width of string
     * @param  c string  Padding chacracter
     * @return  string
     * @access  public
     */
    String.prototype.padLeft = function (n, c) {
      return this.padding(-Math.abs(n), c);
    };
  }

  if (!String.prototype.alignRight) {
    /**
     * object.alignRight(number, string)
     * Wrapper for object.padding
     * Synonym for object.padLeft
     *
     * @param  n number  Width of string
     * @param  c string  Padding chacracter
     * @return  string
     * @access  public
     */
    String.prototype.alignRight = String.prototype.padLeft;
  }

  if (!String.prototype.padRight) {
    /**
     * object.padRight(number, string)
     * Wrapper for object.padding
     * Transform the string object to string of the actual width adding the trailing padding character (by default ' ')
     *
     * @param  n number  Width of string
     * @param  c string  Padding chacracter
     * @return  string
     * @access  public
     */
    String.prototype.padRight = function (n, c) {
      return this.padding(Math.abs(n), c);
    };
  }

  if (!String.prototype.alignRight) {
    /**
     * object.alignLeft(number, string)
     * Wrapper for object.padding
     * Synonym for object.padRight
     *
     * @param  number  Width of string
     * @param  string  Padding chacracter
     * @return  string
     * @access  public
     */
    String.prototype.alignLeft = String.prototype.padRight;
  }

  function pget(obj, prop, def) {
    if ((obj !== null) && obj.hasOwnProperty(prop) && (obj[prop] !== null)) {
      return obj[prop];
    }
    return def;
  }

  function choose_defaults(reg) {
    let json = {};
    json.preClass = String(pget(reg, "preClass", "hide"));
    json.width = Number(pget(reg, "width", 32));
    json.wordWidth = Number(pget(reg, "wordWidth", 32));
    json.debug = Boolean(pget(reg, "debug", false));
    json.defaultUnused = String(pget(reg, "defaultUnused", "RsvdP"));
    json.defaultAttr = String(pget(reg, "defaultAttr", "other"));
    json.cellWidth = Number(pget(reg, "cellWidth", 16));
    json.cellHeight = Number(pget(reg, "cellHeight", 32));
    json.cellInternalHeight = Number(pget(reg, "cellInternalHeight", 8));
    json.bracketHeight = Number(pget(reg, "bracketHeight", 4));
    json.cellTop = Number(pget(reg, "cellTop", 40));
    json.bitWidthPos = Number(pget(reg, "bitWidthPos", 20));
    json.figName = String(pget(reg, "figName", "???"));
    json.maxFigWidth = Number(pget(reg, "maxFigWidth", 624));   // 6.5 inches (assuming 96 px per inch)
    json.visibleLSB = Number(pget(reg, "visibleLSB", 0));
    json.visibleMSB = Number(pget(reg, "visibleMSB", json.width));

    json.isRegister = Boolean(pget(reg, "isRegister", true));   // default
    json.isMessage = Boolean(pget(reg, "isMessage", false));
    json.isMemoryBlock = Boolean(pget(reg, "isMemoryBlock", false));
    // isMessage, isMemoryBlock, and isRegister are mutually exclusive.
    // 1. isMessage has highest priority
    // 2. isMemoryBlock has middle priority
    // 3. isRegister has lowest priority and is the default
    if (json.isMessage) {
      json.isRegister = false;
      json.isMemoryBlock = false;
    } else if (json.isMemoryBlock) {
      json.isRegister = false;
      json.isMessage = false;
    } else {
      json.isRegister = true;
      json.isMemoryBlock = false;
      json.isMessage = false;
    }

    if (json.isRegister) {
      json.rowLabelTop = Number(pget(reg, "rowLabelTop", 20)); // top of text for regLabel
      json.cellValueTop = Number(pget(reg, "cellValueTop", 20)); // top of text for regFieldValueInternal
      json.cellBitValueTop = Number(pget(reg, "cellBitValueTop", 20)); // top of text for regFieldBitValue
      json.cellNameTop = Number(pget(reg, "cellNameTop", 16)); // top of text for regFieldNameInternal
    } else {
      json.rowLabelTop = Number(pget(reg, "rowLabelTop", 20)); // top of text for regLabel
      json.cellValueTop = Number(pget(reg, "cellValueTop", 28)); // top of text for regFieldValueInternal
      json.cellBitValueTop = Number(pget(reg, "cellBitValueTop", 28)); // top of text for regFieldBitValue
      json.cellNameTop = Number(pget(reg, "cellNameTop", 14)); // top of text for regFieldNameInternal
    }

    json.left_to_right = Boolean(pget(reg, "leftToRight", json.isMessage));
    json.forceFit = Boolean(pget(reg, "forceFit", (json.isMessage || json.isMemoryBlock)));
    json.figLeft = Number(pget(reg, "figLeft", json.left_to_right ? 96 : 40));

    json.fields = pget(reg, "fields", {}); // default to empty register
    let temp;

    if (json.visibleMSB < 0) {
      json.visibleMSB = 0;
    }
    if (json.visibleMSB > json.width) {
      json.visibleMSB = json.width;
    }
    if (json.visibleLSB < 0) {
      json.visibleLSB = 0;
    }
    if (json.visibleLSB > json.width) {
      json.visibleLSB = json.width;
    }

    //console.log("choose_defaults: width=" + json.width + " defaultUnused ='" + json.defaultUnused + "' cellWidth=" + json.cellWidth + " cellHeight=" + json.cellHeight + " cellInternalHeight=" + json.cellInternalHeight + " cellTop=" + json.cellTop + " bracketHeight=" + json.bracketHeight);
    //console.log("choose_defaults: fields=" + json.fields.toString());

    // sanitize field array to avoid subsequent problems
    for (let index in json.fields) {
      if (json.fields.hasOwnProperty(index)) {
        let item = json.fields[index];
        if (item.hasOwnProperty("msbit") || item.hasOwnProperty("msbyte")) {
          let byte = 0, bit = 0;
          if (item.hasOwnProperty("msbit")) {
            byte = Math.floor(item.msbit / 8);
            bit = item.msbit % 8;
          }
          if (item.hasOwnProperty("msbyte")) {
            byte = byte + item.msbyte;
          }
          item.msb = byte * 8 + (json.isMessage ? (7 - bit) : bit);
        }
        if (item.hasOwnProperty("lsbit") || item.hasOwnProperty("lsbyte")) {
          let byte = 0, bit = 0;
          if (item.hasOwnProperty("lsbit")) {
            byte = Math.floor(item.lsbit / 8);
            bit = item.lsbit % 8;
          }
          if (item.hasOwnProperty("lsbyte")) {
            byte = byte + item.lsbyte;
          }
          item.lsb = byte * 8 + (json.isMessage ? (7 - bit) : bit);
        }
        if (item.hasOwnProperty("msb") && !item.hasOwnProperty("lsb")) {
          item.lsb = item.msb;
        }
        if (item.hasOwnProperty("lsb") && !item.hasOwnProperty("msb")) {
          item.msb = item.lsb;
        }
        if (item.msb < item.lsb) {
          temp = item.lsb;
          item.lsb = item.msb;
          item.msb = temp;
        }
        if (!item.hasOwnProperty("lsbyte") || !item.hasOwnProperty("lsbit")) {
          item.lsbyte = Math.floor(item.lsb / 8);
          item.lsbit = item.lsb % 8;
        }
        if (!item.hasOwnProperty("msbyte") || !item.hasOwnProperty("msbit")) {
          item.msbyte = Math.floor(item.msb / 8);
          item.msbit = item.msb % 8;
        }
        if (!item.hasOwnProperty("isUnused")) {
          item.isUnused = false;
        }
        if (!item.hasOwnProperty("attr")) {
          item.attr = json.defaultAttr;
        }
        if (!item.hasOwnProperty("name")) {
          item.name = index;
        }
        if (!item.hasOwnProperty("value")) {
          item.value = "";
        }
        if (!item.hasOwnProperty("index")) {
          item.index = -1;  // no associated table row
        }
        json.fields[index] = item;
        //console.log("choose_defaults: field msb=" + item.msb + " lsb=" + item.lsb + " attr=" + item.attr + " isUnused=" + item.isUnused + " name='" + item.name + "' index=" + item.index);
      }
    }

    return json;
  }

  function draw_regpict(divsvg, svg, reg) {
    let reg2 = choose_defaults(reg);
    let width = reg2.width;
    //console.log("width=" + reg2.width);
    let wordWidth = reg2.wordWidth;
    let left_to_right = reg2.left_to_right;
    let forceFit = reg2.forceFit;
    let debug = reg2.debug;
    let preClass = reg2.preClass;
    let defaultUnused = reg2.defaultUnused;
    //let defaultAttr = reg2.defaultAttr;
    let cellWidth = reg2.cellWidth;
    let cellHeight = reg2.cellHeight;
    let cellInternalHeight = reg2.cellInternalHeight;
    let rowLabelTop = reg2.rowLabelTop;
    let cellValueTop = reg2.cellValueTop;
    let cellBitValueTop = reg2.cellBitValueTop;
    let cellNameTop = reg2.cellNameTop;
    let bracketHeight = reg2.bracketHeight;
    let cellTop = reg2.cellTop;
    let bitWidthPos = reg2.bitWidthPos;
    let figName = reg2.figName;
    let maxFigWidth = reg2.maxFigWidth;
    let figLeft = reg2.figLeft;
    let visibleLSB = reg2.visibleLSB;
    let visibleMSB = reg2.visibleMSB;
    let fields = reg2.fields;
    let isRegister = reg2.isRegister;
    let isMessage = reg2.isMessage;
    let isMemoryBlock = reg2.isMemoryBlock;
    let isMultiRow = isMessage || isMemoryBlock;

    let bitarray = [];  // Array indexed by bit # in register range 0:width
    // field[bitarray[N]] contains bit N
    // bitarray[N] == null for unused bits
    // bitarray[N] == 1000 for first bit outside register width

    let i, j;
    bitarray[width] = 1000; //???
    for (i = 0; i < width; i++) {
      bitarray[i] = null;
    }

    for (let index in fields) {
      if (fields.hasOwnProperty(index)) {
        for (i = fields[index].lsb; i <= fields[index].msb; i++) {
          bitarray[i] = index;
        }
      }
    }

    let lsb = -1;   // if >= 0, contains bit# of lsb of a string of unused bits
    for (i = 0; i <= width; ++i) {  // note: includes bitarray[width]
      if (lsb >= 0 && bitarray[i] !== null) {
        // first "used" bit after stretch of unused bits, invent an "unused" field
        let index = "_unused_" + (i - 1); // _unused_msb
        if (lsb !== (i - 1)) {
          index = index + "_" + lsb;  // _unused_msb_lsb
        }
        fields[index] = {
          "msb": (i - 1),
          "lsb": lsb,
          // "name": ((i - lsb) * 2 - 1) >= defaultUnused.length ? defaultUnused : defaultUnused[0].toUpperCase(), // use full name if if fits, else use 1st char
          "name": defaultUnused,
          "attr": defaultUnused.toLowerCase(),   // attribute is name
          "isUnused": true,
          "value": ""
        };
        for (j = lsb; j < i; j++) {
          bitarray[j] = index;
        }
        lsb = -1;
      }
      if (lsb < 0 && bitarray[i] === null) {
        // starting a string of unused bits
        lsb = i;
      }
    }

    function max(a, b) {
      return (a > b ? a : b);
    }

    function min(a, b) {
      return (a < b ? a : b);
    }

    // x position of left edge of bit i
    function leftOf(i) {
      let ret;
      let adj_bit = i;
      if (i >= 0) {
        if (i > visibleMSB) {
          adj_bit = visibleMSB;
        }
        if (i < visibleLSB) {
          adj_bit = visibleLSB;
        }
        if (left_to_right) {
          adj_bit = adj_bit - visibleLSB;
        } else {
          adj_bit = visibleMSB - adj_bit;
        }
        if (isMultiRow) {
          adj_bit = adj_bit % wordWidth; // modulo
          adj_bit = (!left_to_right && (adj_bit === 0)) ? wordWidth : adj_bit;
        }
      } else { // negative bit #, always to the right
        if (isMultiRow) {
          adj_bit = wordWidth - i - 0.5;
        } else {
          adj_bit = visibleMSB - visibleLSB - i - 0.5;
        }
      }
      ret = figLeft + cellWidth * (adj_bit - 0.5);
      if (debug) {
        console.log(i + " leftOf   left_to_right=" + left_to_right +
        " figLeft=" + figLeft +
        " cellWidth=" + cellWidth +
        " visibleLSB=" + visibleLSB +
        " visibleMSB=" + visibleMSB +
        " adj_bit=" + adj_bit +
        isMultiRow ? (" wordWidth=" + wordWidth) : "" +
          "\t--> ret=" + ret);
      }
      return ret;
    }

    // x position of right edge of bit i
    function rightOf(i) {
      let ret;
      let adj_bit = i;
      if (i >= 0) {
        if (i > visibleMSB) {
          adj_bit = visibleMSB;
        }
        if (i < visibleLSB) {
          adj_bit = visibleLSB;
        }
        if (left_to_right) {
          adj_bit = adj_bit - visibleLSB;
        } else {
          adj_bit = visibleMSB - adj_bit;
        }
        if (isMultiRow) {
          adj_bit = adj_bit % wordWidth; // modulo
          adj_bit = (!left_to_right && (adj_bit === 0)) ? wordWidth : adj_bit;
        }
      } else { // negative bit #, always to the right
        if (isMultiRow) {
          adj_bit = wordWidth - i - 0.5;
        } else {
          adj_bit = visibleMSB - visibleLSB - i - 0.5;
        }
      }
      ret = figLeft + cellWidth * (adj_bit + 0.5);
      if (debug) {
        console.log(i + " rightOf  left_to_right=" + left_to_right +
        " figLeft=" + figLeft +
        " cellWidth=" + cellWidth +
        " visibleLSB=" + visibleLSB +
        " visibleMSB=" + visibleMSB +
        " adj_bit=" + adj_bit +
        isMultiRow ? (" wordWidth=" + wordWidth) : "" +
          "\t--> ret=" + ret);
      }
      return ret;
    }

    // x position of middle of bit i
    function middleOf(i) {
      let ret;
      let adj_bit = i;
      if (i >= 0) {
        if (i > visibleMSB) {
          adj_bit = visibleMSB;
        }
        if (i < visibleLSB) {
          adj_bit = visibleLSB;
        }
        if (left_to_right) {
          adj_bit = adj_bit - visibleLSB;
        } else {
          adj_bit = visibleMSB - adj_bit;
        }
        if (isMultiRow) {
          adj_bit = adj_bit % wordWidth; // modulo
          adj_bit = (!left_to_right && (adj_bit === 0)) ? wordWidth : adj_bit;
        }
      } else { // negative bit #, always to the right
        if (isMultiRow) {
          adj_bit = wordWidth - i - 0.5;
        } else {
          adj_bit = visibleMSB - visibleLSB - i - 0.5;
        }
      }
      ret = figLeft + cellWidth * (adj_bit);
      if (debug) {
        console.log(i + " middleOf left_to_right=" + left_to_right +
        " figLeft=" + figLeft +
        " cellWidth=" + cellWidth +
        " visibleLSB=" + visibleLSB +
        " visibleMSB=" + visibleMSB +
        " adj_bit=" + adj_bit +
        isMultiRow ? (" wordWidth=" + wordWidth) : "" +
          "\t--> ret=" + ret);
      }
      return ret;
    }

    function rowOf(i) {
      return (isMultiRow && (i >= 0)) ? Math.floor(i / wordWidth) : 0;
    }

    if (debug) {
      console.log(JSON.stringify(reg2, null, " "));
      console.log(" forceFit=" + forceFit + " left_to_right=" + left_to_right);
    }
    $(divsvg).after(`<pre class="${preClass}">` + "\n" + JSON.stringify(reg2, null, " ") + "\n</pre>");

    let g, p, f, text;
    let nextBitLine = cellTop + cellHeight + 20; //76;
    let bitLineCount = 0;
    let max_text_width = 12 * 8;       // allow for 12 characters at 8px each

    if (isMemoryBlock) {
      // create header for memory block (31..0)
      let pos;
      let text_height = 18;            // Assume 18px: 1 row of text, 15px high
      g = svg.group();
      for (let b = 0; b < wordWidth; b++) {
        text = svg.text(g, middleOf(b), cellTop - 4,
          svg.createText().string(b), {
            "class_": "regBitNumMiddle"
          });
        if (debug) {
          console.log("bitnum-middle " + b + " at x=" + middleOf(b) + " y=" + (cellTop - 4));
        }
        pos = left_to_right ? leftOf(b) : rightOf(b);
        svg.line(g,
          pos, cellTop,
          pos, cellTop - (text_height * (((b % 8) === 0) ? 1.0 : 0.75)),
          {"class_": "regBitNumLine"});
      }
      pos = left_to_right ? rightOf(wordWidth - 1) : leftOf(wordWidth - 1);
      svg.line(g,
        pos, cellTop,
        pos, cellTop - text_height,
        {"class_": "regBitNumLine"});
      svg.text(g, (rightOf(-1.5) - 6),
        cellTop - 4,
        svg.createText().string("Byte Offset"),
        {"class_": "regRowTagRight rowTagByteOffset"});
    } else if (isMessage) {
      // create header for message (+0/+1/+2/+3 then 4 of 7..0)
      let pos;
      let text_height = 18;            // Assume 18px: 1 row of text, 15px high
      g = svg.group();
      for (let byte = 0; byte < wordWidth; byte += 8) {

        for (let bit = 0; bit < 8; bit++) {
          text = svg.text(g, middleOf(byte + bit), cellTop - 4,
            svg.createText().string(7 - bit), {
              "class_": "regBitNumMiddle"
            });
          if (debug) {
            console.log("bitnum-middle " + "+" + byte + "/" + bit + " at x=" + middleOf(bit + byte) + " y=" + (cellTop - 4));
          }
          pos = left_to_right ? leftOf(byte + bit) : rightOf(byte + bit);
          svg.line(g,
            pos, cellTop,
            pos, cellTop - (text_height * ((bit === 0) ? 1.75 : 0.75)),
            {"class_": "regBitNumLine"});
        }

        let byteHeight = cellTop - 4 - text_height;
        text = svg.text(g, leftOf(byte) + cellWidth * 4, byteHeight,
          svg.createText().string(`+${byte / 8}`), {
            "class_": "regByteNumMiddle"
          });
        if (debug) {
          console.log("bitnum-middle " + "+" + byte + " at x=" + leftOf(byte) + cellWidth * 4 + " y=" + byteHeight);
        }
      }
      pos = left_to_right ? rightOf(wordWidth - 1) : leftOf(wordWidth - 1);
      svg.line(g,
        pos, cellTop,
        pos, cellTop - (text_height * 1.75),
        {"class_": "regBitNumLine"});
    }

    for (let b2 = 0; b2 < width; b2++) {
      let b = (left_to_right ? width - b2 - 1 : b2);
      for (i in fields) {
        if (fields.hasOwnProperty(i)) {
          f = fields[i];
          let gAddClass = ["regFieldInternal", "regAttr_" + f.attr, "regLink"];

          if (b === f.lsb) {
            g = svg.group();
            if (isRegister) {
              // create header for register (msb and lsb of each field)
              //let bitnum_width;
              if (f.lsb === f.msb) {
                text = svg.text(g, middleOf(f.lsb), cellTop - 4,
                  svg.createText().string(f.lsb), {
                    "class_": "regBitNumMiddle"
                  });
                if (debug) {
                  console.log("bitnum-middle " + f.lsb + " at x=" + middleOf(f.lsb) + " y=" + (cellTop - 4));
                }
                /*bitnum_width = text.clientWidth;
                if (bitnum_width === 0) {
                    // bogus fix to guess width when clientWidth is 0 (e.g. IE10)
                    bitnum_width = String(f.lsb).length * 4; // Assume 4px per character on average
                }
                if ((bitnum_width + 2) > cellWidth) {
                    svg.change(text,
                               {
                                   x: middleOf(f.lsb),
                                   y: cellTop,
                                   transform: "rotate(270, " +
                                              middleOf(f.lsb) + ", " +
                                              (cellTop - 4) + ")",
                                   "class_": "regBitNumStart"
                               });
                    console.log("bitnum-middle " + f.lsb + " at x=" + middleOf(f.lsb) + " y=" + (cellTop - 4) + " rotate=270");
                }*/
              } else {
                let pos;
                let cls;
                let str;
                if (f.lsb < visibleLSB) {
                  if (left_to_right) {
                    gAddClass.push("regFieldOverflowMSB");
                    str = f.lsb + " ... " + visibleLSB;
                    pos = rightOf(f.lsb) - 2;
                    cls = "regBitNumEnd";
                  } else {
                    gAddClass.push("regFieldOverflowLSB");
                    str = visibleLSB + " ... " + f.lsb;
                    pos = leftOf(f.lsb) + 2;
                    cls = "regBitNumStart";
                  }
                } else {
                  str = f.lsb;
                  if (left_to_right) {
                    pos = leftOf(f.lsb) + 2;
                    cls = "regBitNumStart";
                  } else {
                    pos = rightOf(f.lsb) - 2;
                    cls = "regBitNumEnd";
                  }
                }
                text = svg.text(g, pos, cellTop - 4,
                  svg.createText().string(str), {"class_": cls});
                if (debug) {
                  console.log("bitnum-lsb " + f.lsb + " at x=" + pos + " y=" + (cellTop - 4) + " left_to_right=" + left_to_right);
                }
                /*bitnum_width = text.clientWidth;
                if (bitnum_width === 0) {
                    // bogus fix to guess width when clientWidth is 0 (e.g. IE10)
                    bitnum_width = String(f.lsb).length * 4; // Assume 4px per character on average
                }
                if ((bitnum_width + 2) > ((leftOf(f.msb) - rightOf(f.lsb)) / 2)) {
                     svg.change(text,
                               {
                                   x: middleOf(f.lsb),
                                   y: cellTop,
                                   transform: "rotate(270, " +
                                              rightOf(f.lsb) + ", " +
                                              (cellTop - 4) + ")",
                                   "class_": "regBitNumStart"
                               });
                    console.log("bitnum-right " + f.lsb + " at x=" + rightOf(f.lsb) + " y=" + (cellTop - 4) + " rotate=270");
                }*/
                if (f.msb > visibleMSB) {
                  if (left_to_right) {
                    gAddClass.push("regFieldOverflowLSB");
                    str = visibleMSB + " ... " + f.msb;
                    pos = leftOf(f.msb) + 2;
                    cls = "regBitNumStart";
                  } else {
                    gAddClass.push("regFieldOverflowMSB");
                    str = f.msb + " ... " + visibleMSB;
                    pos = rightOf(f.msb) - 2;
                    cls = "regBitNumEnd";
                  }
                } else {
                  str = f.msb;
                  if (left_to_right) {
                    pos = rightOf(f.msb) - 2;
                    cls = "regBitNumEnd";
                  } else {
                    pos = leftOf(f.msb) + 2;
                    cls = "regBitNumStart";
                  }
                }
                text = svg.text(g, pos, cellTop - 4,
                  svg.createText().string(str), {"class_": cls});
                if (debug) {
                  console.log("bitnum-msb " + f.msb + " at x=" + pos + " y=" + (cellTop - 4) + " left_to_right=" + left_to_right);
                }
                /*bitnum_width = text.clientWidth;
                if (bitnum_width === 0) {
                    // bogus fix to guess width when clientWidth is 0 (e.g. IE10)
                    bitnum_width = String(f.msb).length * 4; // Assume 4px per character on average
                }
                if ((bitnum_width + 2) > ((leftOf(f.msb) - rightOf(f.lsb)) / 2)) {
                    svg.change(text,
                               {
                                   x: middleOf(f.msb),
                                   y: cellTop,
                                   transform: "rotate(270, " +
                                              leftOf(f.msb) + ", " +
                                              (cellTop - 4) + ")",
                                   "class_": "regBitNumStart"
                               });
                    console.log("bitnum-left " + f.lsb + " at x=" + leftOf(f.lsb) + " y=" + (cellTop - 4) + " rotate=270");
                }*/
              }
              if (f.lsb >= visibleLSB) {
                let pos = (left_to_right ? leftOf(f.lsb) : rightOf(f.lsb));
                let text_height = 18;            // Assume 18px: 1 row of text, 15px high
                svg.line(g,
                  pos, cellTop,
                  pos, cellTop - (text_height * 0.75),
                  {"class_": (f.lsb === visibleLSB) ? "regBitNumLine" : "regBitNumLine_Hide"});
              }
              if (f.msb <= visibleMSB) {
                let pos = (left_to_right ? rightOf(f.msb) : leftOf(f.msb));
                let text_height = 18;            // Assume 18px: 1 row of text, 15px high
                svg.line(g,
                  pos, cellTop,
                  pos, cellTop - (text_height * 0.75),
                  {"class_": "regBitNumLine"});
              }
            }
            if (f.hasOwnProperty("addClass") && typeof f.addClass === "string") {
              gAddClass = gAddClass.concat(f.addClass.split(/\s+/));
            }
            if (f.isUnused) {
              gAddClass.push("regFieldUnused");
            }

            let startRow, endRow;
            startRow = rowOf(f.lsb);
            endRow = rowOf(f.msb);

            if (isMultiRow && startRow !== endRow) {
              let leftCol1, rightCol1;
              let leftCol2, rightCol2;
              let rightEdge;
              let leftEdge;
              if (left_to_right) { // if (isMessage)
                leftCol1 = leftOf(f.lsb);
                rightCol2 = rightOf(f.msb);

                leftCol2 = leftOf(0);
                rightCol1 = rightOf(wordWidth - 1);

                leftEdge = leftOf(0);
                rightEdge = rightOf(wordWidth - 1);
              } else { // if (isMemoryBlock)
                leftCol1 = leftOf(wordWidth - 1);
                rightCol2 = rightOf(0);

                leftCol2 = leftOf(f.msb);
                rightCol1 = rightOf(f.lsb);

                leftEdge = leftOf(wordWidth - 1);
                rightEdge = rightOf(0);
              }
              if (debug)
                console.log(`+++ field="${f.name}" leftCol1=${leftCol1} leftCol2=${leftCol2} leftEdge=${leftEdge} rightCol1=${rightCol1} rightCol2=${rightCol2} rightEdge=${rightEdge} startRow=${startRow} endRow=${endRow}`);
              let p = svg.createPath();
              p.move(leftCol1, cellTop + cellHeight * startRow);
              if (rightCol1 !== leftCol1)
                p.line(rightCol1 - leftCol1, 0, true);
              p.line(0, cellHeight, true);            // move down 1 row
              if ((startRow + 1) !== endRow) {
                if (rightEdge !== rightCol1)
                  p.line(rightEdge - rightCol1, 0, true);
                p.line(0, cellHeight * (endRow - startRow - 1), true);
                if (rightCol2 !== rightEdge)
                  p.line(rightCol2 - rightEdge, 0, true);
              } else {
                if (rightCol2 !== rightCol1)
                  p.line(rightCol2 - rightCol1, 0, true);
              }
              p.line(0, cellHeight, true);
              p.line(leftCol2 - rightCol2, 0, true);
              p.line(0, -cellHeight, true);
              if ((startRow + 1) !== endRow) {
                if (leftEdge !== leftCol2)
                  p.line(leftEdge - leftCol2, 0, true);
                p.line(0, -cellHeight * (endRow - startRow - 1), true);
                if (leftCol1 !== leftEdge)
                  p.line(leftCol1 - leftEdge, 0, true);
              } else {
                if (leftCol1 !== leftCol2)
                  p.line(leftCol1 - leftCol2, 0, true);
              }
              p.line(0, -cellHeight, true);   // move back to start col
              p.close();
              svg.path(g, p, {"class_": "regFieldBox"});
              svg.rect(g, leftCol1, cellTop + cellHeight * startRow, rightCol1 - leftCol1, cellHeight, 0, 0,
                {"class_": "regFieldBox", "style": "display: none"});
              svg.rect(g, leftCol2, cellTop + cellHeight * endRow, rightCol2 - leftCol2, cellHeight, 0, 0,
                {"class_": "regFieldBox", "style": "display: none"});
              for (j = 1; j <= (f.msb % wordWidth); j++) {
                let pos = (left_to_right ? leftOf(j) : rightOf(j));
                svg.line(g,
                  pos, cellTop + cellHeight - cellInternalHeight + cellHeight * endRow,
                  pos, cellTop + cellHeight + cellHeight * endRow,
                  {"class_": "regFieldBox"});
              }
            } else {
              let leftCol;
              let rightCol;
              leftCol = left_to_right ? leftOf(f.lsb) : leftOf(f.msb);
              rightCol = left_to_right ? rightOf(f.msb) : rightOf(f.lsb);
              svg.rect(g, leftCol, cellTop + cellHeight * startRow, rightCol - leftCol, cellHeight, 0, 0,
                {"class_": "regFieldBox"});
              for (j = f.lsb + 1; j <= f.msb; j++) {
                if ((j >= visibleLSB) && (j <= visibleMSB)) {
                  let pos = (left_to_right ? leftOf(j) : rightOf(j));
                  svg.line(g,
                    pos, cellTop + cellHeight - cellInternalHeight + cellHeight * startRow,
                    pos, cellTop + cellHeight + cellHeight * startRow,
                    {"class_": "regFieldBox"});
                }
              }
            }

            if (isRegister) {
              text = svg.text(g, (leftOf(f.msb) + rightOf(f.lsb)) / 2, cellTop - bitWidthPos,
                svg.createText().string((f.msb === f.lsb)
                  ? "1 bit"
                  : (f.msb - f.lsb + 1) + " bits"),
                {"class_": "regBitWidth"});
            }
            text = svg.text(g, (leftOf(f.msb) + rightOf(f.lsb)) / 2, cellTop + cellNameTop + cellHeight * (startRow + (endRow - startRow) / 2),
              svg.createText().string(f.name),
              {"class_": "regFieldName"});
            if ((!f.isUnused) && (f.lsb <= visibleMSB) && (f.msb >= visibleLSB)) {
              let $temp_dom = $("<span></span>").prependTo(divsvg);
              let unique_id = $temp_dom.makeID("regpict", (f.id ? f.id : (figName + "-" + f.name)));
              $temp_dom.remove();
              svg.change(g, {id: unique_id});
            }
            let hasValue = false;
            if ("value" in f) {
              if (Array.isArray(f.value) && f.value.length === (f.msb - f.lsb + 1)) {
                hasValue = true;
                for (i = 0; i < f.value.length; ++i) {
                  svg.text(g, (leftOf(f.lsb + i) + rightOf(f.lsb + i)) / 2,
                    cellTop + cellBitValueTop + cellHeight * startRow,
                    svg.createText().string(f.value[i]),
                    {
                      "class_": ("regFieldValue regFieldBitValue" +
                        " regFieldBitValue-" + i.toString() +
                        ((i === (f.value.length - 1)) ?
                          " regFieldBitValue-msb" : ""))
                    });
                }
              } else if ((typeof(f.value) === "string") || (f.value instanceof String)) {
                if (f.value.length > 0) {
                  hasValue = true;
                  svg.text(g, (leftOf(f.msb) + rightOf(f.lsb)) / 2,
                    cellTop + (f.msb === f.lsb ? cellBitValueTop : cellValueTop) + cellHeight * startRow,
                    svg.createText().string(f.value),
                    {"class_": "regFieldValue"});
                }
              } else {
                svg.text(g, (leftOf(f.msb) + rightOf(f.lsb)) / 2, cellTop + cellValueTop + cellHeight * startRow,
                  svg.createText().string("INVALID VALUE"),
                  {"class_": "svg_error"});
              }
            }
            let text_width = 0; // text.clientWidth;
            if (text_width === 0) {
              // bogus fix to guess width when clientWidth is 0 (e.g. IE10)
              text_width = f.name.length * 8; // Assume 8px per character on average for 15px height chars
            }
            let text_height = text.clientHeight;
            if (text_height === 0) {
              // bogus fix to guess width when clientHeight is 0 (e.g. IE10)
              text_height = 18;             // Assume 18px: 1 row of text, 15px high
            }
            let boxLeft = leftOf(left_to_right ? max(visibleLSB, f.lsb) : min(visibleMSB, f.msb));
            let boxRight = rightOf(left_to_right ? min(visibleMSB, f.msb) : max(visibleLSB, f.lsb));
            let boxTop = cellTop + cellHeight * startRow;
            if (debug) {
              console.log("field " + f.name +
                " msb=" + f.msb +
                " lsb=" + f.lsb +
                " attr=" + f.attr +
                " isUnused=" + f.isUnused +
                (("id" in f) ? f.id : "") +
                (hasValue ? " hasValue" : ""));
              console.log(" text.clientWidth=" + text.clientWidth +
                " text_width=" + text_width +
                " text.clientHeight=" + text.clientHeight +
                " text_height=" + text_height +
                " boxLeft=" + boxLeft +
                " boxRight=" + boxRight +
                " boxWidth=" + (boxRight - boxLeft) +
                " boxTop=" + boxTop);
            }
            /* if field has a specified value,
             the field name is too wide for the box,
             or the field name is too tall for the box */
            if ((f.lsb > visibleMSB) || (f.msb < visibleLSB)) {
              gAddClass[0] = "regFieldHidden";
            } else {
              if (!(forceFit || f.forceFit) && (hasValue ||
                ((text_width + 2) > (boxRight - boxLeft)) ||
                ((text_height + 2) > (cellHeight - cellInternalHeight)))) {
                if (text_width > max_text_width) {
                  max_text_width = text_width;
                }
                svg.change(text,
                  {
                    x: rightOf(-0.5),
                    y: nextBitLine,
                    "class_": "regFieldName"
                  });
                p = svg.createPath();
                p.move(boxLeft, cellTop + cellHeight * (startRow + 1));
                p.line(((boxRight - boxLeft) / 2), bracketHeight, true);
                p.line(boxRight, cellTop + cellHeight * (startRow + 1));
                svg.path(g, p,
                  {
                    "class_": "regBitBracket",
                    fill: "none"
                  });
                p = svg.createPath();
                p.move((boxLeft + (boxRight - boxLeft) / 2), cellTop + cellHeight * (startRow + 1) + bracketHeight);
                p.vert(nextBitLine - text_height / 4);
                p.horiz(rightOf(-0.4));
                svg.path(g, p,
                  {
                    "class_": "regBitLine",
                    fill: "none"
                  });
                gAddClass[0] = "regFieldExternal";
                gAddClass.push("regFieldExternal" + (bitLineCount < 2 ? "0" : "1"));
                nextBitLine += text_height + 2;
                bitLineCount = (bitLineCount + 1) % 4;
              }
            }
            if ((f.msb > visibleLSB) && (f.lsb < visibleLSB)) {
              if (left_to_right) {
                svg.text(g, leftOf(0) - 2, cellTop + cellNameTop + cellHeight * startRow,
                  svg.createText().string("..."),
                  {"class_": "regFieldExtendsLeft"});
              } else {
                svg.text(g, rightOf(0) + 2, cellTop + cellNameTop + cellHeight * startRow,
                  svg.createText().string("..."),
                  {"class_": "regFieldExtendsRight"});
              }
            }
            if ((f.msb > visibleMSB) && (f.lsb < visibleMSB)) {
              if (left_to_right) {
                svg.text(g, rightOf(f.msb) + 2, cellTop + cellNameTop + cellHeight * startRow,
                  svg.createText().string("..."),
                  {"class_": "regFieldExtendsRight"});
              } else {
                svg.text(g, leftOf(f.msb) - 2, cellTop + cellNameTop + cellHeight * startRow,
                  svg.createText().string("..."),
                  {"class_": "regFieldExtendsLeft"});
              }
            }
            svg.change(g, {"class_": gAddClass.join(" ")});
          }
        }
      }
    }

    if (isMultiRow) {
      let g2 = svg.group();
      for (let i = 0; i < width; i += wordWidth) {
        let rowLabel = isMemoryBlock ? ("+" + Math.floor(i / 8).hex(3, "0") + "h") :
          ("Byte " + (i / 8) + " â ");
        svg.text(g2, left_to_right ? (leftOf(0) - 8) : (rightOf(-1.5) + 2),
          cellTop + rowLabelTop + cellHeight * (i / wordWidth),
          svg.createText().string(rowLabel),
          {"class_": left_to_right ? "regRowTagLeft" : "regRowTagRight"});
      }
    }

    let scale = 1.0;
    max_text_width = max_text_width + rightOf(-1);
    if (isRegister && (maxFigWidth > 0) && (max_text_width > maxFigWidth)) {
      scale = maxFigWidth / max_text_width;
    }
    let svgClass = [
      (isMessage ? "isMessage" : (isMemoryBlock ? "isMemoryBlock" : "isRegister")),
      (left_to_right ? "isLeftToRight" : "isRightToLeft")];
    svg.configure({
      height: Math.ceil(scale * Math.ceil(nextBitLine + cellHeight * rowOf(width - 1))) + "",
      width: Math.ceil(scale * max_text_width) + "",
      viewBox: "0 0 " + max_text_width + " " + (Math.ceil(nextBitLine + cellHeight * rowOf(width - 1)) + ""),
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "class_": svgClass.join(" ")
    });
    return reg2;
  }

  function insert_unused_table_rows($tbl, json) {
    let last_lsb = json.width;
    let field_slot = [];
    let $tbody = $("tbody", $tbl).first();
    if ($tbody !== undefined) {
      //console.log("non-empty tbody");
      let rows = $tbody.children();
      if (rows !== undefined) {
        //console.log("rows.length=" + rows.length);
        //console.log("json=" + JSON.stringify(json, null, 2));
        // console.log(`Object.keys(json.fields).length=${Object.keys(json.fields).length}`);
        if (Object.keys(json.fields).length > 0) {
          Object.keys(json.fields).forEach(function (name) {
            let item = json.fields[name];
            // console.log(`field_slot[${item.msb}]=${JSON.stringify(item, null, 2)}`);
            field_slot[item.msb] = item;
          });
          for (let msb = json.width; msb >= 0; msb--) {
            let item = field_slot[msb];
            if (item !== undefined) {
              // console.log(`msb=${msb} item.index=${item.index} last_lsb=${last_lsb}`);
              if (msb < (last_lsb - 1)) {
                let bit_location = ((last_lsb - 1) === msb) ? `${msb + 1}` : `${last_lsb - 1}:${msb + 1}`;
                let new_row = `<tr><td>${bit_location}</td><td>${json.defaultUnused}</td><td>${json.defaultUnused}</td></tr>`;
                $(rows[item.index]).after(new_row);
                // console.log(`rows[${item.index}].after(${new_row})`);
              }
              last_lsb = item.lsb;
            }
          }
        }
        if (last_lsb > 0) {
          let bit_location = ((last_lsb - 1) === 1) ? "0" : `${last_lsb - 1}:0`;
          let new_row = `<tr><td>${bit_location}</td><td>${json.defaultUnused}</td><td>${json.defaultUnused}</td></tr>`;
          $(rows[0]).before(new_row);
          // console.log(`rows[0].before(${new_row})`);
          // console.log("$tbody=" + $tbody);
        }
      } else {
        let bit_location = ((last_lsb - 1) === 1) ? "0" : `${last_lsb - 1}:0`;
        let new_row = `<tr><td>${bit_location}</td><td>${json.defaultUnused}</td><td>${json.defaultUnused}</td></tr>`;
        $tbody.append(new_row);
        // console.log(`$tbody.append(${new_row})`);
      }
    }
  }

  function parse_table(json, $tbl) {
    let parsed = {fields: {}};
    let $tbody = $("tbody", $tbl).first();
    //console.log("pcisig_reg: tbody='" + $tbody.get(0).outerHTML);
    $tbody.children().each(function (index) {
      let $td = $(this).children();
      if ($td.length >= 3) {
        let bits = $td[0].textContent.trim();
        let desc = $td[1];
        let attr = $td[2].textContent.toLowerCase().trim();
        let lsb, msb, match;
        lsb = msb = -1;
        match = /^\s*(\d+)\s*(:\s*(\d+))?\s*$/.exec(bits);
        if (match) {
          msb = lsb = Number(match[1]);
          if ((typeof(match[3]) === "string") && (match[3] !== "")) {
            lsb = Number(match[3]);
          }
          if (lsb > msb) {
            msb = lsb;
            lsb = Number(match[1]);
          }
        }
        let fieldName;
        let $dfn = $("dfn:first", desc);
        if ($dfn.length === 0) {
          fieldName = /^\s*([-_\w]+)/.exec(desc.textContent);
          if (fieldName) {
            fieldName = fieldName[1]; // first word of text content
          } else {
            fieldName = "Bogus_" + desc.textContent.trim();
          }
        } else {
          $dfn = $dfn.first();
          fieldName = $dfn.text().trim();
          $dfn.addClass("field");
          const lt = $tbl.attr("id").replace(/^tbl-/, "");
          $dfn.attr("data-dfn-for", lt);
          $dfn.attr("data-dfn-type", "field");
          $dfn.last().makeID("field", lt + "-" + fieldName.toLowerCase());
        }
        let $val = $("span.value:first", desc);
        let value = "";
        if ($val.length === 1) {
          try {
            value = JSON.parse($val.text().trim());
          } catch (e) {
            $tbl.before("<p class=\"issue\">Invalid data-json attribute in next span.value</p>");
            $val.addclass("respec-error");
          }
        }
        let validAttr = /^(rw|rws|ro|ros|rw1c|rw1cs|rw1s|rw1ss|wo|wos|hardwired|fixed|hwinit|rsvd|rsvdp|rsvdz|reserved|ignored|ign|unused|other)$/i;
        if (!validAttr.test(attr)) {
          attr = "other";
        }
        let unusedAttr = /^(rsvd|rsvdp|rsvdz|reserved|ignored|ign|unused)$/i;
        let isUnused = !!unusedAttr.test(attr);
        // console.log("field: " + fieldName + " bits=\"" + bits + "\"  match=" + match + "\" lsb=" + lsb + " msb=" + msb + "  attr=" + attr + "  isUnused=" + isUnused);
        parsed.fields[fieldName] = {
          index: index,
          msb: msb,
          lsb: lsb,
          attr: attr,
          isUnused: isUnused,
          value: value
        };
      }
    });
    // console.log("parsed=" + JSON.stringify(parsed, null, 2));
    $.extend(true, json, parsed);
    // console.log("json=" + JSON.stringify(json, null, 2));
    return json;
  }

  function run$j(conf, doc, cb) {

    pub("start", "core/regpict");
    if (!(conf.noRegpictCSS)) {
      $(doc).find("head link").first().before($("<style id=\"regpict\"></style>").text(css));
    }
    let figNum = 1;
    $("figure.regipct-generated", doc).remove();
    $("table.register", doc).each(function () {
      let $tbl = $(this);
      let json = {};
      if ($tbl.attr("id")) {
        json.figName = $tbl.attr("id").replace(/^tbl-/, "");
      } else if ($tbl.attr("title")) {
        json.figName = $tbl.attr("title");
      } else if ($("caption", this)) {
        json.figName = $("caption", this).text();
      } else {
        json.figName = "unnamed-" + figNum;
        figNum++;
      }
      json.figName = json.figName.toLowerCase()
        .replace(/^\s+/, "")
        .replace(/\s+$/, "")
        .replace(/[^\-.0-9a-z_]+/ig, "-")
        .replace(/^-+/, "")
        .replace(/-+$/, "")
        .replace(/\.$/, ".x")
        .replace(/^([^a-z])/i, "x$1")
        .replace(/^$/, "generatedID");
      if (!$tbl.attr("id")) {
        $tbl.attr("id", "tbl-" + json.figName);
      }
      pub("start", "core/regpict table id='" + $tbl.attr("id") + "'");
      let temp = $tbl.attr("data-json");
      if (temp !== null && temp !== undefined && temp !== "") {
        let temp2 = {};
        try {
          temp2 = JSON.parse(temp);
          $.extend(true, json, temp2);
        } catch (e) {
          $tbl.before("<p class=\"issue\">Invalid data-json attribute in next table</p>");
          $tbl.addclass("respec-error");
        }
      }

      temp = $tbl.attr("data-width");
      if (temp !== null && temp !== undefined && temp !== "") {
        json.width = temp;
      }

      temp = $tbl.attr("data-unused");
      if (temp !== null && temp !== undefined && temp !== "") {
        json.defaultUnused = temp;
      }

      temp = $tbl.attr("data-href");
      if (temp !== null && temp !== undefined && temp !== "") {
        json.href = temp;
      }

      json.table = "#" + $tbl.attr("id");

      temp = $tbl.attr("data-register");
      if (temp !== null && temp !== undefined && temp !== "") {
        json.register = temp;
      }

      json = parse_table(json, $tbl);

      //console.log("regpict.table.register json = " + JSON.stringify(json, null, 2));

      // insert a figure before this table
      $tbl.before("<figure id=\"fig-" + json.table.replace(/^#tbl-/, "") + "\" class=\"regpict-generated\">"
        + "<div class=\"svg\"></div>"
        + "<figcaption>" + $("caption", $tbl).text() + "</figcaption>"
        + "</figure>");
      const $divsvg = $("div.svg", $tbl.prev()).last();
      $divsvg.last().svg(function (svg) {
        json = draw_regpict(this, svg, json);
      });
      $tbl.before(`<pre style="display: none;">${JSON.stringify(json, null, 2)}</pre>`);
      insert_unused_table_rows($tbl, json);
      pub("end", "core/regpict table id='" + $tbl.attr("id") + "'");
    });

    $("figure.register, figure.message, figure.capability", doc).each(
      function () {
        let $fig = $(this);
        $fig.hasClass("register");
        $fig.hasClass("message");
        $fig.hasClass("capability");
        $fig.hasClass("memoryBlock");
        let $tbl = undefined;
        let json = {};
        if ($fig.attr("id")) {
          json.figName = $fig.attr("id").replace(/^fig-/, "");
        } else if ($fig.attr("title")) {
          json.figName = $fig.attr("title");
        } else if ($("figcaption", this)) {
          json.figName = $("figcaption", this).text();
        } else {
          json.figName = "unnamed-" + figNum;
          figNum++;
        }
        json.figName = json.figName.toLowerCase()
          .replace(/^\s+/, "")
          .replace(/\s+$/, "")
          .replace(/[^\-.0-9a-z_]+/ig, "-")
          .replace(/^-+/, "")
          .replace(/-+$/, "")
          .replace(/\.$/, ".x")
          .replace(/^([^a-z])/i, "x$1")
          .replace(/^$/, "generatedID");
        if (!$fig.attr("id")) {
          $fig.attr("id", "fig-" + json.figName);
        }
        pub("start", "core/regpict figure.register id='" + $fig.attr("id") + "'");

        let temp = $fig.attr("data-json");
        if (temp !== null && temp !== undefined && temp !== "") {
          let temp2 = {};
          try {
            temp2 = JSON.parse(temp);
            $.extend(true, json, temp2);
          } catch (e) {
            $fig.before("<p class=\"issue\">Invalid data-json attribute in next figure.register</p>");
            $fig.addclass("respec-error");
          }
        }

        temp = $fig.attr("data-width");
        if (temp !== null && temp !== undefined && temp !== "") {
          json.width = temp;
        }

        temp = $fig.attr("data-wordWidth");
        if (temp !== null && temp !== undefined && temp !== "") {
          json.wordWidth = temp;
        }

        temp = $fig.attr("data-unused");
        if (temp !== null && temp !== undefined && temp !== "") {
          json.defaultUnused = temp;
        }

        temp = $fig.attr("data-href");
        if (temp !== null && temp !== undefined && temp !== "") {
          json.href = temp;
        }

        temp = $fig.attr("data-table");
        if (temp !== null && temp !== undefined && temp !== "") {
          json.table = temp;
        }

        temp = $fig.attr("data-register");
        if (temp !== null && temp !== undefined && temp !== "") {
          json.register = temp;
        }

        $("pre.json,div.json,span.json", $fig).each(function () {
          let temp2 = {};
          try {
            temp2 = JSON.parse(this.textContent);
            $.extend(true, json, temp2);
            $(this).hide();
          } catch (e) {
            $fig.before("<p class=\"issue\">Invalid JSON in pre.json, div.json, or span.json</p>");
            $(this).addclass("respec-error");
          }
        });

        if ($fig.hasClass("pcisig_reg") && json.hasOwnProperty("table")) {
          $tbl = $(json.table, doc);
          json = parse_table(json, $tbl);
        }

        // invent a div to hold the svg, if necessary
        let $divsvg = $("div.svg", this).last();
        if ($divsvg.length === 0) {
          let $cap = $("figcaption", this);
          if ($cap.length > 0) {
            //console.log("inserting div.svg before <figcaption>");
            $cap.before("<div class=\"svg\"></div>");
          } else {
            //console.log("inserting div.svg at end of <figure>");
            $(this).append("<div class=\"svg\"></div>");
          }
          $divsvg = $("div.svg", this).last();
        }

        function merge_json(result, me) {
          let $me = $(me);
          let parents = $me.attr("data-parents");
          if (parents !== null && parents !== undefined && parents !== "") {
            // console.log("parents = \"" + parents + "\"");
            parents = parents.split(/\s+/);
            let i;
            for (i = 0; i < parents.length; i++) {
              let $temp = $("#" + parents[i]);
              // console.log("merging: #" + parents[i]);
              if ($temp.length > 0) {
                // console.log("merge_json: adding \"" + $temp[0].textContent + "\"");
                merge_json(result, $temp[0]);
                //$.extend(true, result, JSON.parse($temp[0].textContent));
                // console.log("result=" + JSON.stringify(result, null, 2));
                $temp.hide();
              }
            }
          }
          // console.log("merge_json: adding \"" + me.textContent + "\"");
          let temp2 = {};
          try {
            temp2 = JSON.parse(me.textContent);
            $.extend(true, result, temp2);
            // console.log("result=" + JSON.stringify(result, null, 2));
            $(me).hide();
          } catch (e) {
            $tbl.before("<p class=\"issue\">Invalid JSON in next merge_json</p>");
            $(me).addclass("respec-error");
          }
        }

        let $render = $("pre.render,div.render,span.render", $fig);
        if ($render.length > 0) {
          $render.each(function (index) {
            let temp_json = {};
            $.extend(true, temp_json, json);
            merge_json(temp_json, this);
            //$(this).hide();
            $divsvg.last().makeID("svg", "render-" + index);
            $divsvg.last().svg(function (svg) {
              draw_regpict(this, svg, temp_json);
            });
            if (index < ($render.length - 1)) {
              $divsvg.after("<div class=\"svg\"></div>");
              $divsvg = $("div.svg", $fig).last();
            }
          });
        }
        // } else if (false) {//if (isMultiRow) {
        //   let wordLSB = 0;
        //   let width = Number(pget(json,"width", 32));
        //   let wordWidth = Number(pget(json,"wordWidth", 32));
        //   console.log(`isMultiRow=${isMultiRow} json.width=${json.width} width=${width} json.wordWidth=${json.wordWidth} wordWidth=${wordWidth}` + "\n");
        //   for (wordLSB = 0; wordLSB < width; wordLSB += wordWidth) {
        //     let temp_json = {};
        //     $.extend(temp_json, json);
        //     temp_json.visibleLSB = wordLSB;
        //     temp_json.visibleMSB = wordLSB + wordWidth - 1;
        //     console.log(`wordLSB=${wordLSB} temp_json.visibleLSB=${temp_json.visibleLSB} temp_json.visibleMSB=${temp_json.visibleMSB}` + "\n");
        //     $divsvg.last().svg(function (svg) {
        //       draw_regpict(this, svg, temp_json);
        //     });
        //     if (wordLSB + wordWidth < width) {
        //       // all but last iteration
        //       $divsvg.after("<div class=\"svg\"</div>");
        //       $divsvg = $("div.svg", $fig).last();
        //     }
        //   }
        // }
        else if (json !== null) {
          $divsvg.last().svg(function (svg) {
            draw_regpict(this, svg, json);
          });
        } else {
          pub("warn",
            "core/regpict: no register definition " + $fig.get(0).outerHTML);
        }
        if ($tbl !== undefined) {
          insert_unused_table_rows($tbl, choose_defaults(json));
        }
        pub("end", "core/regpict figure.register id='" + $fig.attr("id") + "'");
      });

    cb();
  }

  var regpict = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$j,
    run: run$j
  });

  // @ts-check
  // Module core/figure
  // Handles figures in the document.
  // Adds width and height to images, if they are missing.
  // Generates a Table of Figures wherever there is a #tof element.


  const name$i = "core/figures";

  const localizationStrings$6 = {
    en: {
      list_of_figures: "List of Figures",
      fig: "Figure ",
    },
    ja: {
      fig: "å³ ",
      list_of_figures: "å³ã®ãªã¹ã",
    },
    ko: {
      fig: "ê·¸ë¦¼ ",
      list_of_figures: "ê·¸ë¦¼ ëª©ë¡",
    },
    nl: {
      fig: "Figuur ",
      list_of_figures: "Lijst met figuren",
    },
    es: {
      fig: "Figura ",
      list_of_figures: "Lista de Figuras",
    },
    zh: {
      fig: "å¾ ",
      list_of_figures: "è§èä¸­åå«çå¾",
    },
    de: {
      fig: "Abbildung",
      list_of_figures: "Abbildungsverzeichnis",
    },
  };

  const l10n$6 = getIntlData(localizationStrings$6);

  function run$i() {
    const tof = collectFigures();

    // Create a Table of Figures if a section with id 'tof' exists.
    const tofElement = document.getElementById("tof");
    if (tof.length && tofElement) {
      decorateTableOfFigures(tofElement);
      tofElement.append(
        html`<h1>${l10n$6.list_of_figures}</h1>`,
        html`<ul class="tof">
        ${tof}
      </ul>`
      );
    }
  }

  /**
   * process all figures
   */
  function collectFigures() {
    /** @type {HTMLElement[]} */
    const tof = [];
    document.querySelectorAll("figure").forEach((fig, i) => {
      const caption = fig.querySelector("figcaption");

      if (caption) {
        decorateFigure(fig, caption, i);
        tof.push(getTableOfFiguresListItem(fig.id, caption));
      } else {
        const msg = "Found a `<figure>` without a `<figcaption>`.";
        showWarning(msg, name$i, { elements: [fig] });
      }
    });
    return tof;
  }

  /**
   * @param {HTMLElement} figure
   * @param {HTMLElement} caption
   * @param {number} i
   */
  function decorateFigure(figure, caption, i) {
    const title = caption.textContent;
    addId(figure, "fig", title);
    // set proper caption title
    wrapInner(caption, html`<span class="fig-title"></span>`);
    caption.prepend(
      html`<a class="self-link" href="#${figure.id}"
      >${l10n$6.fig}<bdi class="figno">${i + 1}</bdi></a
    >`,
      " "
    );
  }

  /**
   * @param {string} figureId
   * @param {HTMLElement} caption
   * @return {HTMLElement}
   */
  function getTableOfFiguresListItem(figureId, caption) {
    const tofCaption = caption.cloneNode(true);
    tofCaption.querySelectorAll("a").forEach(anchor => {
      renameElement(anchor, "span").removeAttribute("href");
    });
    return html`<li class="tofline">
    <a class="tocxref" href="${`#${figureId}`}">${tofCaption.childNodes}</a>
  </li>`;
  }

  /**
   * if it has a parent section, don't touch it
   * if it has a class of appendix or introductory, don't touch it
   * if all the preceding section siblings are introductory, make it introductory
   * if there is a preceding section sibling which is an appendix, make it appendix
   * @param {Element} tofElement
   */
  function decorateTableOfFigures(tofElement) {
    if (
      tofElement.classList.contains("appendix") ||
      tofElement.classList.contains("introductory") ||
      tofElement.closest("section")
    ) {
      return;
    }

    const previousSections = getPreviousSections(tofElement);
    if (previousSections.every(sec => sec.classList.contains("introductory"))) {
      tofElement.classList.add("introductory");
    } else if (previousSections.some(sec => sec.classList.contains("appendix"))) {
      tofElement.classList.add("appendix");
    }
  }

  var figures = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$i,
    run: run$i
  });

  // Module core/table
  // Handles tables in the document.
  // This is to enable the generation of a Table of Tables wherever there is a #tot element
  // to be found as well as normalise the titles of tables.


  const name$h = "core/tables";

  function run$h(conf, doc, cb) {

    // process all tables
    let tblMap = {},
      tot = [],
      num = 0;
    $("table > caption").each(function () {
      // set proper caption title
      let $cap = $(this),
        tit = $cap.text(),
        id = $cap.parent().makeID("tbl", tit);
      num++;
      $cap
        .wrapInner($("<span class='tbl-title'/>"))
        .prepend($("<span class='tbl-title-decoration'>&nbsp;</span>"))
        .prepend($("<span class='tblno'>" + num + "</span>"))
        .prepend($("<span class='tbl-tblno-decoration'>" + conf.l10n.tbl + "&nbsp;</span>"));
      tblMap[id] = $cap.contents();
      let $totCap = $cap.clone();
      $totCap.find("a").renameElement("span").attr("class", "formerLink").removeAttr("href");
      $totCap.find("dfn").renameElement("span");
      $totCap.find("[id]").removeAttr("id");
      $totCap.find("span.footnote").remove();   // footnotes are in the caption, not #tot
      $totCap.find("span.issue").remove();      // issues are in the caption, not #tot
      $totCap.find("span.respec-error").remove(); // errors are in the caption, not #tot
      $totCap.find("span.noToc").remove();      // explicitly not in #tot
      tot.push(
        $("<li class='totline'><a class='tocxref' href='#" + id + "'></a></li>")
          .find(".tocxref")
          .append($totCap.contents())
          .end()
      );

    });


    // Update all anchors with empty content that reference a table ID
    $("a[href]", doc).each(function () {
      let $a = $(this),
        id = $a.attr("href");
      if (!id) return;
      id = id.substring(1);
      if (tblMap[id]) {
        $a.addClass("tbl-ref");
        if ($a.html() === "") {
          let ref = tblMap[id].clone();
          ref.find("a").renameElement("span").attr("class", "formerLink").removeAttr("href");
          ref.find("dfn").renameElement("span");
          ref.find("[id]").removeAttr("id");
          ref.find("span.footnote").remove();   // footnotes are in the caption, not references
          ref.find("span.issue").remove();      // issues are in the caption, not references
          ref.find("span.respec-error").remove(); // errors are in the caption, not references
          ref.find("span.noToc").remove();      // explicitly not in refs
          $a.append(ref);
        }
      }
    });

    // Create a Table of Tables if a section with id 'tot' exists.
    let $tot = $("#tot", doc);
    if (tot.length && $tot.length) {
      // if it has a parent section, don't touch it
      // if it has a class of appendix or introductory, don't touch it
      // if all the preceding section siblings are introductory, make it introductory
      // if there is a preceding section sibling which is an appendix, make it appendix
      if (
        !$tot.hasClass("appendix") &&
        !$tot.hasClass("introductory") &&
        !$tot.parents("section").length
      ) {
        if (
          $tot.prevAll("section.introductory").length ===
          $tot.prevAll("section").length
        ) {
          $tot.addClass("introductory");
        } else if ($tot.prevAll("appendix").length) {
          $tot.addClass("appendix");
        }
      }
      $tot.append($("<h2>" + conf.l10n.table_of_tbl + "</h2>"));
      $tot.append($("<ul class='tot'/>"));
      let $ul = $tot.find("ul");
      while (tot.length) $ul.append(tot.shift());
    }
    cb();
  }

  var tables = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$h,
    run: run$h
  });

  // Module core/equation
  // Handles equations in the document. This encompasses two primary operations. One is
  // converting some old syntax to use the new HTML5 equation and figcaption elements
  // (this is undone by the unhtml5 plugin, but that will soon be phased out). The other
  // is to enable the generation of a Table of Equations wherever there is a #toe element
  // to be found as well as normalise the titles of equations.


  const name$g = "core/equations";

  function run$g(conf, doc, cb) {
    // process all equations
    let eqnMap = {},
      toe = [],
      num = 0;
    $("figure.equation").each(function() {
      let $eqn = $(this),
        $cap = $eqn.find("figcaption"),
        tit = $cap.text(),
        id = $eqn.makeID("eqn", tit);

      // set proper caption title
      num++;
      $cap
        .wrapInner($("<span class='eqn-title'/>"))
        .prepend($("<span class='eqn-title-decoration'>&nbsp;</span>"))
        .prepend($("<span class='eqnno'>" + num + "</span>"))
        .prepend($("<span class='eqn-eqnno-decoration'>" + conf.l10n.eqn + "&nbsp;</span>"));
      eqnMap[id] = $cap.contents();
      let $toeCap = $cap.clone();
      $toeCap.find("a").renameElement("span").attr("class", "formerLink").removeAttr("href");
      $toeCap.find("dfn").renameElement("span");
      $toeCap.find("[id]").removeAttr("id");
      $toeCap.find("span.footnote").remove();   // footnotes are in the caption, not #toe
      $toeCap.find("span.issue").remove();      // issues are in the caption, not #toe
      $toeCap.find("span.respec-error").remove(); // errors are in the caption, not #toe
      $toeCap.find("span.noToc").remove();      // explicitly not in #toe
      toe.push(
        $("<li class='toeline'><a class='tocxref' href='#" + id + "'></a></li>")
          .find(".tocxref")
          .append($toeCap.contents())
          .end()
      );
    });

    // Update all anchors with empty content that reference a equation ID
    $("a[href]", doc).each(function() {
      let $a = $(this),
        id = $a.attr("href");
      if (!id) return;
      id = id.substring(1);
      if (eqnMap[id]) {
        $a.addClass("eqn-ref");
        if ($a.html() === "") {
          let ref = eqnMap[id].clone();
          ref.find("a").renameElement("span").attr("class", "formerLink").removeAttr("href");
          ref.find("dfn").renameElement("span");
          ref.find("[id]").removeAttr("id");
          ref.find("span.footnote").remove();   // footnotes are in the caption, not references
          ref.find("span.issue").remove();      // issues are in the caption, not references
          ref.find("span.respec-error").remove(); // errors are in the caption, not references
          ref.find("span.noToc").remove();      // explicitly not in refs
          $a.append(ref);
        }
      }
    });

    // Create a Table of Equations if a section with id 'toe' exists.
    let $toe = $("#toe", doc);
    if (toe.length && $toe.length) {
      // if it has a parent section, don't touch it
      // if it has a class of appendix or introductory, don't touch it
      // if all the preceding section siblings are introductory, make it introductory
      // if there is a preceding section sibling which is an appendix, make it appendix
      if (
        !$toe.hasClass("appendix") &&
        !$toe.hasClass("introductory") &&
        !$toe.parents("section").length
      ) {
        if (
          $toe.prevAll("section.introductory").length ===
          $toe.prevAll("section").length
        ) {
          $toe.addClass("introductory");
        } else if ($toe.prevAll("appendix").length) {
          $toe.addClass("appendix");
        }
      }
      $toe.append($("<h2>" + conf.l10n.table_of_eqn + "</h2>"));
      $toe.append($("<ul class='toe'/>"));
      let $ul = $toe.find("ul");
      while (toe.length) $ul.append(toe.shift());
    }
    cb();
  }

  var equations = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$g,
    run: run$g
  });

  // Module pcisig/pre-dfn
  // Finds all <dfn> elements and adjust dfn-type attribute.

  const name$f = "pcisig/pre-dfn";

  function run$f(conf, doc, cb) {
    const dfnClass = ["dfn", "pin", "signal", "op", "opcode", "operation", "request", "response", "bit",
      "reply", "message", "msg", "command", "term", "field", "register",
      "regpict", "state", "value", "parameter", "argument"];

    $("dfn:not([data-dfn-type])", doc).each(function () {
      const $dfn = $(this);
      let tag = dfnClass[0];  // default "dfn"
      dfnClass.forEach(function (t) {
        if ($dfn.hasClass(t)) tag = t;
      });
      $dfn.attr("data-dfn-type", tag);   // core/dfn will convert this to data-dfn-type
    });
    cb();
  }

  var preDfn = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$f,
    run: run$f
  });

  /**
   * Validates MIME types strings.
   *
   * @type {DefinitionValidator} */
  function validateMimeType(text, type, elem, pluginName) {
    try {
      // Constructor can throw.
      const type = new MIMEType(text);
      if (type.toString() !== text) {
        throw new Error(`Input doesn't match its canonical form: "${type}".`);
      }
    } catch (error) {
      const msg = `Invalid ${type} "${text}": ${error.message}.`;
      const hint =
        "Check that the MIME type has both a type and a sub-type, and that it's in a canonical form (e.g., `text/plain`).";
      showError(msg, pluginName, { hint, elements: [elem] });
      return false;
    }
    return true;
  }

  /**
   * Validates the names of DOM attribute and elements.
   * @param {"element-attr" | "element"} type
   * @type {DefinitionValidator} */
  function validateDOMName(text, type, elem, pluginName) {
    try {
      switch (type) {
        case "element-attr":
          document.createAttribute(text);
          return true;
        case "element":
          document.createElement(text);
          return true;
      }
    } catch (err) {
      const msg = `Invalid ${type} name "${text}": ${err.message}`;
      const hint = `Check that the ${type} name is allowed per the XML's Name production for ${type}.`;
      showError(msg, pluginName, { hint, elements: [elem] });
    }
    return false;
  }

  /**
   * Validates common variable or other named thing in a spec, like event names.
   *
   * @type {DefinitionValidator}
   */
  function validateCommonName(text, type, elem, pluginName) {
    // Check a-z, maybe a dash and letters, case insensitive.
    // Also, no spaces.
    if (/^[a-z]+(-[a-z]+)*$/i.test(text)) {
      return true; // all good
    }
    const msg = `Invalid ${type} name "${text}".`;
    const hint = `Check that the ${type} name is allowed per the naming rules for this type.`;
    showError(msg, pluginName, { hint, elements: [elem] });
    return false;
  }

  /**
   * @type {DefinitionValidator} */
  function validateQuotedString(text, type, elem, pluginName) {
    if (text.startsWith(`"`) && text.endsWith(`"`)) {
      return validateCommonName(text.slice(1, -1), type, elem, pluginName);
    }
    const msg = `Invalid ${type} "${text}".`;
    const hint = `Check that the ${type} is quoted with double quotes.`;
    showError(msg, pluginName, { hint, elements: [elem] });
    return false;
  }

  // @ts-check

  /** @type {CaseInsensitiveMap<Set<HTMLElement>>} */
  const definitionMap = new CaseInsensitiveMap();

  /**
   * @param {HTMLElement} dfn A definition element to register
   * @param {string[]} names Names to register the element by
   */
  function registerDefinition(dfn, names) {
    for (const name of names) {
      if (!definitionMap.has(name)) {
        definitionMap.set(name, new Set());
      }
      definitionMap.get(name).add(dfn);
    }
  }

  // @ts-check
  // Module core/dfn
  // - Finds all <dfn> elements and populates definitionMap to identify them.


  const name$e = "core/dfn";

  /** @type {Map<string, { requiresFor: boolean, validator?: DefinitionValidator, associateWith?: string}>}  */
  const knownTypesMap = new Map([
    ["abstract-op", { requiresFor: false }],
    [
      "attr-value",
      {
        requiresFor: true,
        associateWith: "a markup attribute",
        validator: validateCommonName,
      },
    ],
    ["element", { requiresFor: false, validator: validateDOMName }],
    [
      "element-attr",
      {
        requiresFor: false,
        validator: validateDOMName,
      },
    ],
    [
      "element-state",
      {
        requiresFor: true,
        associateWith: "a markup attribute",
        validator: validateCommonName,
      },
    ],
    ["event", { requiresFor: false, validator: validateCommonName }],
    ["http-header", { requiresFor: false }],
    ["media-type", { requiresFor: false, validator: validateMimeType }],
    ["scheme", { requiresFor: false, validator: validateCommonName }],
    ["permission", { requiresFor: false, validator: validateQuotedString }],
  ]);

  const knownTypes = [...knownTypesMap.keys()];

  function run$e() {
    for (const dfn of document.querySelectorAll("dfn")) {
      const titles = getDfnTitles(dfn);
      registerDefinition(dfn, titles);

      // It's a legacy cite or redefining a something it doesn't own, so it gets no benefit.
      if (dfn.dataset.cite && /\b#\b/.test(dfn.dataset.cite)) {
        continue;
      }

      const [linkingText] = titles;
      computeType(dfn, linkingText);
      computeExport(dfn);

      // Only add `lt`s that are different from the text content and local-lts
      const localLt = (dfn.dataset.localLt || "").split("|").map(norm);
      const lt = titles.filter(t => !localLt.includes(t));
      if (lt.length > 1 || linkingText !== norm(dfn.textContent)) {
        dfn.dataset.lt = lt.join("|");
      }
    }
  }

  /**
   * @param {HTMLElement} dfn
   * @param {string} linkingText
   * */
  function computeType(dfn, linkingText) {
    let type = "";

    switch (true) {
      // class defined type (e.g., "<dfn class="element">)
      case knownTypes.some(name => dfn.classList.contains(name)):
        // First one wins
        type = [...dfn.classList].find(className => knownTypesMap.has(className));
        validateDefinition(linkingText, type, dfn);
        break;

      // Internal slots: attributes+ methods (e.g., [[some words]](with, optional, arguments))
      case slotRegex.test(linkingText):
        type = processAsInternalSlot(linkingText, dfn);
        break;
    }

    // Derive closest type
    if (!type && !dfn.matches("[data-dfn-type]")) {
      /** @type {HTMLElement} */
      const closestType = dfn.closest("[data-dfn-type]");
      type = closestType?.dataset.dfnType;
    }
    // only if we have type and one wasn't explicitly given.
    if (type && !dfn.dataset.dfnType) {
      dfn.dataset.dfnType = type;
    }
    // Finally, addContractDefaults() will add the type to the dfn if it's not there.
    // But other modules may end up adding a type (e.g., the WebIDL module)
  }

  // Deal with export/no export
  function computeExport(dfn) {
    switch (true) {
      // Error if we have both exports and no exports.
      case dfn.matches(".export.no-export"): {
        const msg = docLink`Declares both "${"[no-export]"}" and "${"[export]"}" CSS class.`;
        const hint = "Please use only one.";
        showError(msg, name$e, { elements: [dfn], hint });
        break;
      }

      // No export wins
      case dfn.matches(".no-export, [data-noexport]"):
        if (dfn.matches("[data-export]")) {
          const msg = docLink`Declares ${"[no-export]"} CSS class, but also has a "${"[data-export]"}" attribute.`;
          const hint = "Please chose only one.";
          showError(msg, name$e, { elements: [dfn], hint });
          delete dfn.dataset.export;
        }
        dfn.dataset.noexport = "";
        break;

      // If the author explicitly asked for it to be exported, so let's export it.
      case dfn.matches(":is(.export):not([data-noexport], .no-export)"):
        dfn.dataset.export = "";
        break;
    }
  }

  /**
   * @param {string} text
   * @param {string} type
   * @param {HTMLElement} dfn
   */
  function validateDefinition(text, type, dfn) {
    const entry = knownTypesMap.get(type);
    if (entry.requiresFor && !dfn.dataset.dfnFor) {
      const msg = docLink`Definition of type "\`${type}\`" requires a ${"[data-dfn-for]"} attribute.`;
      const { associateWith } = entry;
      const hint = docLink`Use a ${"[data-dfn-for]"} attribute to associate this with ${associateWith}.`;
      showError(msg, name$e, { hint, elements: [dfn] });
    }

    if (entry.validator) {
      entry.validator(text, type, dfn, name$e);
    }
  }

  /**
   *
   * @param {string} title
   * @param {HTMLElement} dfn
   */
  function processAsInternalSlot(title, dfn) {
    if (!dfn.dataset.hasOwnProperty("idl")) {
      dfn.dataset.idl = "";
    }

    // Automatically use the closest data-dfn-for as the parent.
    /** @type HTMLElement */
    const parent = dfn.closest("[data-dfn-for]");
    if (dfn !== parent && parent?.dataset.dfnFor) {
      dfn.dataset.dfnFor = parent.dataset.dfnFor;
    }

    // Assure that it's data-dfn-for= something.
    if (!dfn.dataset.dfnFor) {
      const msg = `Internal slot "${title}" must be associated with a WebIDL interface.`;
      const hint = docLink`Use a ${"[data-dfn-for]"} attribute to associate this dfn with a WebIDL interface.`;
      showError(msg, name$e, { hint, elements: [dfn] });
    }

    // Don't export internal slots by default, as they are not supposed to be public.
    if (!dfn.matches(".export, [data-export]")) {
      dfn.dataset.noexport = "";
    }

    // If it ends with a ), then it's method. Attribute otherwise.
    const derivedType = title.endsWith(")") ? "method" : "attribute";
    if (!dfn.dataset.dfnType) {
      return derivedType;
    }

    // Perform validation on the dfn's type.
    const allowedSlotTypes = ["attribute", "method"];
    const { dfnType } = dfn.dataset;
    if (!allowedSlotTypes.includes(dfnType) || derivedType !== dfnType) {
      const msg = docLink`Invalid ${"[data-dfn-type]"} attribute on internal slot.`;
      const prettyTypes = codedJoinOr(allowedSlotTypes, {
        quotes: true,
      });
      const hint = `The only allowed types are: ${prettyTypes}. The slot "${title}" seems to be a "${toMDCode(
      derivedType
    )}"?`;
      showError(msg, name$e, { hint, elements: [dfn] });
      return "dfn";
    }
    return dfnType;
  }

  var dfn = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$e,
    run: run$e
  });

  // @ts-check
  /**
   * Module core/data-cite
   *
   * Allows citing other specifications using anchor elements. Simply add
   * "data-cite" and key of the specification.
   *
   * This module links elements that have `data-cite` attributes by converting
   * `data-cite` to `href` attributes. `data-cite` attributes are added to markup
   * directly by the author as well as via other modules like core/xref.
   *
   * @module core/data-cite
   */

  const name$d = "core/data-cite";

  /**
   * An arbitrary constant value used as an alias to the current spec's shortname. It
   * exists to simplify code as passing `conf.shortName` everywhere gets clumsy.
   * @type {string}
   */
  const THIS_SPEC = "__SPEC__";

  /**
   * Gets the link properties for the given citation details.
   * @param {CiteDetails} citeDetails - The citation details.
   * @returns {Promise<LinkProps|null>} The link properties or null if not found.
   */
  async function getLinkProps(citeDetails) {
    const { key, frag, path, href: canonicalHref } = citeDetails;
    let href = "";
    let title = "";

    // This is just referring to this document
    if (key === THIS_SPEC) {
      href = document.location.href;
    } else {
      // Let's go look it up in spec ref...
      const entry = await resolveRef(key);
      if (!entry) {
        return null;
      }
      href = entry.href;
      title = entry.title;
    }

    if (canonicalHref) {
      // Xref gave us a canonical link, so let's use that.
      href = canonicalHref;
    } else {
      if (path) {
        // See: https://github.com/speced/respec/issues/1856#issuecomment-429579475
        const relPath = path.startsWith("/") ? `.${path}` : path;
        href = new URL(relPath, href).href;
      }
      if (frag) {
        href = new URL(frag, href).href;
      }
    }

    return { href, title };
  }

  /**
   * Links the given element with the provided link properties and citation details.
   * @param {HTMLElement} elem - The element to link.
   * @param {LinkProps} linkProps - The link properties.
   * @param {CiteDetails} citeDetails - The citation details.
   */
  function linkElem(elem, linkProps, citeDetails) {
    const { href, title } = linkProps;
    const wrapInCiteEl = !citeDetails.path && !citeDetails.frag;

    switch (elem.localName) {
      case "a": {
        const el = /** @type {HTMLAnchorElement} */ (elem);
        if (el.textContent === "" && el.dataset.lt !== "the-empty-string") {
          el.textContent = title;
        }
        el.href = href;
        if (wrapInCiteEl) {
          const cite = document.createElement("cite");
          el.replaceWith(cite);
          cite.append(el);
        }
        break;
      }
      case "dfn": {
        const anchor = document.createElement("a");
        anchor.href = href;
        anchor.dataset.cite = citeDetails.key;
        anchor.dataset.citePath = citeDetails.path;
        anchor.dataset.citeFrag = citeDetails.frag;
        if (!elem.textContent) {
          anchor.textContent = title;
          elem.append(anchor);
        } else {
          wrapInner(elem, anchor);
        }
        if (wrapInCiteEl) {
          const cite = document.createElement("cite");
          cite.append(anchor);
          elem.append(cite);
        }
        if ("export" in elem.dataset) {
          const msg = "Exporting a linked external definition is not allowed.";
          const hint = "Please remove the `data-export` attribute.";
          showError(msg, name$d, { hint, elements: [elem] });
          delete elem.dataset.export;
        }
        elem.classList.add("externalDFN");
        elem.dataset.noExport = "";
        break;
      }
    }
  }

  /**
   * @param {string} component
   * @return {(key: string) => string}
   */
  function makeComponentFinder(component) {
    return key => {
      const position = key.search(component);
      return position !== -1 ? key.substring(position) : "";
    };
  }

  const findFrag = makeComponentFinder("#");
  const findPath = makeComponentFinder("/");

  /**
   * Converts the given raw key to citation details.
   * @param {HTMLElement} elem - The element containing the citation details.
   * @returns {CiteDetails} The citation details.
   */
  function toCiteDetails(elem) {
    const { dataset } = elem;
    const { cite: rawKey, citeFrag, citePath, citeHref } = dataset;

    // The key is a fragment, resolve using the shortName as key
    if (rawKey.startsWith("#") && !citeFrag) {
      // Closes data-cite not starting with "#"
      /** @type {HTMLElement} */
      const closest = elem.parentElement.closest(
        `[data-cite]:not([data-cite^="#"])`
      );
      const { key: parentKey, isNormative: closestIsNormative } = closest
        ? toCiteDetails(closest)
        : { key: THIS_SPEC, isNormative: false };
      dataset.cite = closestIsNormative ? parentKey : `?${parentKey}`;
      dataset.citeFrag = rawKey.replace("#", ""); // the key is acting as a fragment
      return toCiteDetails(elem);
    }

    const frag = citeFrag ? `#${citeFrag}` : findFrag(rawKey);
    const path = citePath || findPath(rawKey).split("#")[0]; // path is always before "#"
    const { type } = refTypeFromContext(rawKey, elem);
    const isNormative = type === "normative";
    // key is before "/" and "#" but after "!" or "?" (e.g., ?key/path#frag)
    const hasPrecedingMark = /^[?|!]/.test(rawKey);
    const key = rawKey.split(/[/|#]/)[0].substring(Number(hasPrecedingMark));
    const details = { key, isNormative, frag, path, href: citeHref };
    return details;
  }

  /**
   * Runs the data-cite processing on elements with the data-cite attribute.
   */
  async function run$d() {
    /** @type {NodeListOf<HTMLElement>} */
    const elems = document.querySelectorAll(
      "dfn[data-cite]:not([data-cite='']), a[data-cite]:not([data-cite=''])"
    );

    await updateBiblio([...elems]);

    for (const elem of elems) {
      const originalKey = elem.dataset.cite;
      const citeDetails = toCiteDetails(elem);
      const linkProps = await getLinkProps(citeDetails);
      if (linkProps) {
        linkElem(elem, linkProps, citeDetails);
      } else {
        const msg = `Couldn't find a match for "${originalKey}"`;
        if (elem.dataset.matchedText) {
          elem.textContent = elem.dataset.matchedText;
        }
        showWarning(msg, name$d, { elements: [elem] });
      }
    }

    sub("beforesave", cleanup);
  }

  /**
   * Fetches and updates `biblio` with entries corresponding to the given elements.
   * @param {HTMLElement[]} elems - The elements requiring biblio entries.
   */
  async function updateBiblio(elems) {
    const promisesForBibEntries = elems.map(toCiteDetails).map(async entry => {
      const result = await resolveRef(entry.key);
      return { entry, result };
    });
    const bibEntries = await Promise.all(promisesForBibEntries);

    const missingBibEntries = bibEntries
      .filter(({ result }) => result === null)
      .map(({ entry: { key } }) => key);

    const newEntries = await updateFromNetwork(missingBibEntries);
    if (newEntries) {
      Object.assign(biblio, newEntries);
    }
  }

  /**
   * Cleans up the data-cite attributes from the document.
   * @param {Document} doc - The document to cleanup.
   */
  function cleanup(doc) {
    const attrToRemove = ["data-cite", "data-cite-frag", "data-cite-path"];
    const elems = doc.querySelectorAll("a[data-cite], dfn[data-cite]");
    elems.forEach(elem =>
      attrToRemove.forEach(attr => elem.removeAttribute(attr))
    );
  }

  var dataCite = /*#__PURE__*/Object.freeze({
    __proto__: null,
    THIS_SPEC: THIS_SPEC,
    name: name$d,
    run: run$d,
    toCiteDetails: toCiteDetails
  });

  // Module pcisig/link-to-dfn
  // Gives definitions in conf.definitionMap IDs and links <a> tags
  // to the matching definitions.
  // Modified from core/link-to-dfn.js to remove requirements that only data-for happens for webIDL

  const name$c = "pcisig/link-to-dfn";

  function ref_to(dfn) {
    const dfn_id = dfn.attr("id");
    return (dfn_id !== undefined) ? ("<a href=\"#" + encodeURIComponent(dfn_id) + "\">" + dfn_id + "</a>") : "";
  }

  function run$c(conf, doc, cb) {
    doc.normalize();
    let titles = {};
    Object.keys(conf.definitionMap).forEach(function (title) {
      titles[title] = {};
      conf.definitionMap[title].forEach(function (dfn) {
        if (dfn.attr("id") === undefined) {
          dfn.makeID("dfn", title);
        }
        const dfn_for = dfn.attr("data-dfn-for") || "";
        if (dfn_for in titles[title]) {
          // Only complain if the user provides 2 <dfn>s for the same term.
          const error_msg = "Duplicate definition of '" + (dfn_for ? dfn_for + "/" : "") + title + "' "
            + ref_to(dfn) + " and " + ref_to(titles[title][dfn_for]);
          pub("error", error_msg);
          dfn.after("<span class=\"respec-error\"> {{ " + error_msg + " }} </span>");
          // keep first definition
          return;
        }
        titles[title][dfn_for] = dfn;
      });
      if (conf.definitionMap[title].length === 1) {
        titles[title][""] = conf.definitionMap[title][0];    // don't require data-for unless it's ambiguous
      }

    });

    $("a:not([href]):not([data-cite]):not(.logo)").each(function () {
      let $ant = $(this);
      if ($ant.hasClass("externalDFN")) return;
      console.log("link-to-dfn:" + $ant.html());
      let linkTargets = $ant.linkTargets();
      let foundDfn = linkTargets.some(function (target) {
        console.log("  linkTarget.title = '" + target.title + "' linkTarget.for_='" + target.for_ + "'");
        if (titles[target.title] && titles[target.title][target.for_]) {
          let dfn = titles[target.title][target.for_];
          if (dfn[0].dataset.cite) {
            $ant[0].dataset.cite = dfn[0].dataset.cite;
          } else {
            const frag = "#" + encodeURIComponent(dfn.prop("id"));
            $ant.attr("href", frag).addClass("internalDFN");
          }
          // add a bikeshed style indication of the type of link
          if (!$ant.attr("data-link-type")) {
            $ant.attr("data-link-type", "dfn");
          }
          // If a definition is <code>, links to it should
          // also be <code>.
          //
          // Note that contents().length===1 excludes
          // definitions that have either other text, or other
          // whitespace, inside the <dfn>.
          if (
            dfn.closest("code,pre").length ||
            (dfn.contents().length === 1 && dfn.children("code").length === 1)
          ) {
            // only add code to IDL when the definition matches
            const term = $ant[0].textContent.trim();
            const isIDL = dfn[0].dataset.hasOwnProperty("idl");
            const isSameText = isIDL
              ? dfn[0].dataset.title === term
              : dfn[0].textContent.trim() === term;
            if (isIDL && !isSameText) {
              return true;
            }
            $ant.wrapInner("<code></code>");
          }
          return true;
        }
        return false;
      });

      if (!foundDfn) {
        let link_for = linkTargets[0].for_;
        let title = linkTargets[0].title;
        this.classList.add("respec-offending-element");
        this.title = "Linking error: no matching &lt;dfn&gt;";
        const error_msg = "Found linkless <a> element " +
          (link_for ? "for '" + link_for + "' " : "") +
          "with text '" +
          title +
          "' but no matching <dfn>.";
        pub("warn", error_msg);
        $ant.makeID("error", error_msg);
        console.warn("Linkless element:", $ant[0]);
        //console.warn("Linkless Element Reference: "$("<span class=\"respec-error\"><a href=\"#" + $ant.attr("id") + "\">" + $ant.attr("id") + "</a></span>"));
      }
    });

    run$d().then(function () {
      // done linking, so clean up
      function attrToDataAttr(name) {
        return function (elem) {
          let value = elem.getAttribute(name);
          elem.removeAttribute(name);
          elem.setAttribute("data-" + name, value);
        };
      }

      let forList = doc.querySelectorAll("*[for]");
      Array.prototype.forEach.call(forList, attrToDataAttr("for"));

      let dfnForList = doc.querySelectorAll("*[dfn-for]");
      Array.prototype.forEach.call(dfnForList, attrToDataAttr("dfn-for"));

      let linkForList = doc.querySelectorAll("*[link-for]");
      Array.prototype.forEach.call(linkForList, attrToDataAttr("link-for"));

      if (conf.addDefinitionMap) {
        pub("start", "core/dfn/addDefinitionMap");
        let $mapsec = $("<section id='definition-map' class='introductory appendix'><h2>Definition Map</h2></section>").appendTo($("body"));
        let $tbody = $("<table class='data'><thead><tr><th>dfn</th><th>data-dfn-type</th><th>data-dfn-for</th><th>id</th></tr></thead><tbody/></table>").appendTo($mapsec).children("tbody");
        Object.keys(conf.definitionMap).sort().forEach(function (k) {
          conf.definitionMap[k].forEach(function (f) {
            $("<tr>" +
              "<td class='long'>" + k + "</td>" +
              "<td class='long'>" + f.attr("data-dfn-type") + "</td>" +
              "<td class='long'>" + f.attr("data-dfn-for") + "</td>" +
              "<td class='long'><a href=\"" + "#" + f.attr("id") + "\">" + f.attr("id") + "</a></td>" +
              "</tr>").appendTo($tbody);
          });
        });
      }

      if (conf.addDefinitionMap2) {
        let $mapsec2 = $("<section id='definition-map-2' class='introductory appendix'><h2>Definition Map 2</h2></section>").appendTo($("body"));
        let $tbody2 = $("<table class='data'><thead><tr><th>dfn</th><th>data-dfn-for</th><th>id</th></tr></thead><tbody/></table>").appendTo($mapsec2).children("tbody");
        Object.keys(titles).sort().forEach(function (title) {
          Object.keys(titles[title]).forEach(function (for_) {
            let item = titles[title][for_];
            $("<tr>" +
              "<td class='long'>" + title + "</td>" +
              "<td class='long'>" + for_ + "</td>" +
              "<td class='long'><a href=\"" + "#" + item.attr("id") + "\">" + item.attr("id") + "</a></td>" +
              "</tr>").appendTo($tbody2);
          });
        });
        pub("end", "core/dfn/addDefinitionMap");
      }

      cb();
    })
    ;
  }

  var linkToDfn = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$c,
    run: run$c
  });

  // @ts-check
  // Module core/contrib
  // Fetches names of contributors from github and uses them to fill
  // in the content of elements with key identifiers:
  // #gh-contributors: people whose PR have been merged.
  // Spec editors get filtered out automatically.
  const name$b = "core/contrib";

  async function run$b(conf) {
    const ghContributors = document.getElementById("gh-contributors");
    if (!ghContributors) {
      return;
    }

    if (!conf.github) {
      const msg = docLink`Requested list of contributors from GitHub, but ${"[github]"} configuration option is not set.`;
      showError(msg, name$b);
      return;
    }

    const editors = conf.editors.map(editor => editor.name);
    const apiURL = `${conf.github.apiBase}/${conf.github.fullName}/`;
    await showContributors(editors, apiURL);
  }

  /**
   * Show list of contributors in #gh-contributors
   * @param {string[]} editors
   * @param {string} apiURL
   */
  async function showContributors(editors, apiURL) {
    const elem = document.getElementById("gh-contributors");
    if (!elem) return;

    elem.textContent = "Fetching list of contributors...";
    const contributors = await getContributors();
    if (contributors !== null) {
      toHTML$1(contributors, elem);
    } else {
      elem.textContent = "Failed to fetch contributors.";
    }

    async function getContributors() {
      const { href: url } = new URL("contributors", apiURL);
      try {
        const res = await fetchAndCache(url);
        if (!res.ok) {
          throw new Error(
            `Request to ${url} failed with status code ${res.status}`
          );
        }
        /** @type {Contributor[]} */
        const contributors = await res.json();
        return contributors.filter(
          user =>
            !editors.includes(user.name || user.login) &&
            !user.login.includes("[bot]")
        );
      } catch (error) {
        const msg = "Error loading contributors from GitHub.";
        showError(msg, name$b, { cause: error });
        return null;
      }
    }
  }

  /**
   * @typedef {{ name?: string, login: string }} Contributor
   * @param {Contributor[]} contributors
   * @param {HTMLElement} element
   */
  function toHTML$1(contributors, element) {
    const sortedContributors = contributors.sort((a, b) => {
      const nameA = a.name || a.login;
      const nameB = b.name || b.login;
      return nameA.toLowerCase().localeCompare(nameB.toLowerCase());
    });

    if (element.tagName === "UL") {
      html(element)`${sortedContributors.map(
      ({ name, login }) =>
        `<li><a href="https://github.com/${login}">${name || login}</a></li>`
    )}`;
      return;
    }

    const names = sortedContributors.map(user => user.name || user.login);
    element.textContent = joinAnd(names);
  }

  var contrib = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$b,
    run: run$b
  });

  // @ts-check
  // Module core/fix-headers
  // Make sure that all h1-h6 headers (that are first direct children of sections) are actually
  // numbered at the right depth level. This makes it possible to just use any of them (conventionally
  // h2) with the knowledge that the proper depth level will be used

  const name$a = "core/fix-headers";

  function run$a() {
    [...document.querySelectorAll("section:not(.introductory)")]
      .map(sec => sec.querySelector("h1, h2, h3, h4, h5, h6"))
      .filter(h => h)
      .forEach(heading => {
        const depth = Math.min(getParents(heading, "section").length + 1, 6);
        renameElement(heading, `h${depth}`);
      });
  }

  function getParents(el, selector) {
    const parents = [];
    while (el != el.ownerDocument.body) {
      if (el.matches(selector)) parents.push(el);
      el = el.parentElement;
    }
    return parents;
  }

  var fixHeaders = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$a,
    run: run$a
  });

  // @ts-check
  // Module core/structure
  //  Handles producing the ToC and numbering sections across the document.


  const lowerHeaderTags = ["h2", "h3", "h4", "h5", "h6"];

  const name$9 = "core/structure";

  const localizationStrings$5 = {
    en: {
      toc: "Table of Contents",
      back_to_top: "Back to Top",
    },
    zh: {
      toc: "åå®¹å¤§çº²",
      back_to_top: "è¿åé¡¶é¨",
    },
    ko: {
      toc: "ëª©ì°¨",
      back_to_top: "ë§¨ ìë¡",
    },
    ja: {
      toc: "ç®æ¬¡",
      back_to_top: "åé ­ã«æ»ã",
    },
    nl: {
      toc: "Inhoudsopgave",
      back_to_top: "Terug naar boven",
    },
    es: {
      toc: "Tabla de Contenidos",
      back_to_top: "Volver arriba",
    },
    de: {
      toc: "Inhaltsverzeichnis",
      back_to_top: "ZurÃ¼ck nach oben",
    },
    cs: {
      toc: "Obsah",
      back_to_top: "ZpÄt na zaÄÃ¡tek",
    },
  };

  const l10n$5 = getIntlData(localizationStrings$5);

  /**
   * @typedef {object} SectionInfo
   * @property {string} secno
   * @property {string} title
   *
   * Scans sections and generate ordered list element + ID-to-anchor-content dictionary.
   * @param {Section[]} sections the target element to find child sections
   * @param {number} maxTocLevel
   */
  function scanSections(sections, maxTocLevel, { prefix = "" } = {}) {
    let appendixMode = false;
    let lastNonAppendix = 0;
    let index = 1;
    if (prefix.length && !prefix.endsWith(".")) {
      prefix += ".";
    }
    if (sections.length === 0) {
      return null;
    }
    /** @type {HTMLElement} */
    const ol = html`<ol class="toc"></ol>`;
    for (const section of sections) {
      if (section.isAppendix && !prefix && !appendixMode) {
        lastNonAppendix = index;
        appendixMode = true;
      }
      let secno = section.isIntro
        ? ""
        : appendixMode
          ? appendixNumber(index - lastNonAppendix + 1)
          : prefix + index;
      const level = secno.split(".").length;
      if (level === 1) {
        secno += ".";
        // if this is a top level item, insert
        // an OddPage comment so html2ps will correctly
        // paginate the output
        section.header.before(document.createComment("OddPage"));
      }

      if (!section.isIntro) {
        index += 1;
        section.header.prepend(html`<bdi class="secno">${secno} </bdi>`);
      }

      if (level <= maxTocLevel) {
        const id = section.header.id || section.element.id;
        const item = createTocListItem(section.header, id);
        const sub = scanSections(section.subsections, maxTocLevel, {
          prefix: secno,
        });
        if (sub) {
          item.append(sub);
        }
        ol.append(item);
      }
    }
    return ol;
  }

  /**
   * Convert a number to spreadsheet like column name.
   * For example, 1=A, 26=Z, 27=AA, 28=AB and so on..
   * @param {number} num
   */
  function appendixNumber(num) {
    let s = "";
    while (num > 0) {
      num -= 1;
      s = String.fromCharCode(65 + (num % 26)) + s;
      num = Math.floor(num / 26);
    }
    return s;
  }

  /**
   * @typedef {object} Section
   * @property {Element} element
   * @property {Element} header
   * @property {string} title
   * @property {boolean} isIntro
   * @property {boolean} isAppendix
   * @property {Section[]} subsections
   *
   * @param {Element} parent
   */
  function getSectionTree(parent) {
    /** @type {NodeListOf<HTMLElement>} */
    const sectionElements = parent.querySelectorAll(":scope > section");
    /** @type {Section[]} */
    const sections = [];

    for (const section of sectionElements) {
      const noToc = section.classList.contains("notoc");
      if (!section.children.length || noToc) {
        continue;
      }
      const header = section.children[0];
      if (!lowerHeaderTags.includes(header.localName)) {
        continue;
      }
      const title = header.textContent;
      addId(section, null, title);
      sections.push({
        element: section,
        header,
        title,
        isIntro: Boolean(section.closest(".introductory")),
        isAppendix: section.classList.contains("appendix"),
        subsections: getSectionTree(section),
      });
    }
    return sections;
  }

  /**
   * @param {Element} header
   * @param {string} id
   */
  function createTocListItem(header, id) {
    const anchor = html`<a href="${`#${id}`}" class="tocxref" />`;
    anchor.append(...header.cloneNode(true).childNodes);
    filterHeader(anchor);
    return html`<li class="tocline">${anchor}</li>`;
  }

  /**
   * Replaces any child <a> and <dfn> with <span>.
   * @param {HTMLElement} h
   */
  function filterHeader(h) {
    h.querySelectorAll("a").forEach(anchor => {
      const span = renameElement(anchor, "span");
      span.className = "formerLink";
      span.removeAttribute("href");
    });
    h.querySelectorAll("dfn").forEach(dfn => {
      const span = renameElement(dfn, "span");
      span.removeAttribute("id");
    });
  }

  function run$9(conf) {
    if ("maxTocLevel" in conf === false) {
      conf.maxTocLevel = Infinity;
    }

    renameSectionHeaders();

    // makeTOC
    if (!conf.noTOC) {
      skipFromToC();
      const sectionTree = getSectionTree(document.body);
      const result = scanSections(sectionTree, conf.maxTocLevel);
      if (result) {
        createTableOfContents(result);
      }
    }

    // See core/dfn-index
    pub("toc");
  }

  function renameSectionHeaders() {
    const headers = getNonintroductorySectionHeaders();
    if (!headers.length) {
      return;
    }
    headers.forEach(header => {
      const depth = Math.min(parents(header, "section").length + 1, 6);
      const h = `h${depth}`;
      if (header.localName !== h) {
        renameElement(header, h);
      }
    });
  }

  function getNonintroductorySectionHeaders() {
    return [
      ...document.querySelectorAll(
        "section:not(.introductory) :is(h1,h2,h3,h4,h5,h6):first-child"
      ),
    ].filter(elem => !elem.closest("section.introductory"));
  }

  /**
   * Skip descendent sections from appearing in ToC using data-max-toc.
   */
  function skipFromToC() {
    /** @type {NodeListOf<HTMLElement>} */
    const sections = document.querySelectorAll("section[data-max-toc]");
    for (const section of sections) {
      const maxToc = parseInt(section.dataset.maxToc, 10);
      if (maxToc < 0 || maxToc > 6 || Number.isNaN(maxToc)) {
        const msg = "`data-max-toc` must have a value between 0-6 (inclusive).";
        showError(msg, name$9, { elements: [section] });
        continue;
      }

      // `data-max-toc=0` is equivalent to adding a ".notoc" to current section.
      if (maxToc === 0) {
        section.classList.add("notoc");
        continue;
      }

      // When `data-max-toc=2`, we skip all ":scope > section > section" from ToC
      // i.e., at Â§1, we will keep Â§1.1 but not Â§1.1.1
      // Similarly, `data-max-toc=1` will keep Â§1, but not Â§1.1
      const sectionToSkipFromToC = section.querySelectorAll(
        `:scope > ${Array.from({ length: maxToc }, () => "section").join(" > ")}`
      );
      for (const el of sectionToSkipFromToC) {
        el.classList.add("notoc");
      }
    }
  }

  /**
   * @param {HTMLElement} ol
   */
  function createTableOfContents(ol) {
    if (!ol) {
      return;
    }
    const nav = html`<nav id="toc"></nav>`;
    const h2 = html`<h2 class="introductory">${l10n$5.toc}</h2>`;
    addId(h2);
    nav.append(h2, ol);
    const ref =
      document.getElementById("toc") ||
      document.getElementById("sotd") ||
      document.getElementById("abstract");
    if (ref) {
      if (ref.id === "toc") {
        ref.replaceWith(nav);
      } else {
        ref.after(nav);
      }
    }

    const link = html`<p role="navigation" id="back-to-top">
    <a href="#title"><abbr title="${l10n$5.back_to_top}">&uarr;</abbr></a>
  </p>`;
    document.body.append(link);
  }

  var structure = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$9,
    run: run$9
  });

  // @ts-check
  // Module core/informative
  // Mark specific sections as informative, based on CSS

  const name$8 = "core/informative";

  const localizationStrings$4 = {
    en: {
      informative: "This section is non-normative.",
    },
    nl: {
      informative: "Dit onderdeel is niet normatief.",
    },
    ko: {
      informative: "ì´ ë¶ë¶ì ë¹ê·ë²ì ìëë¤.",
    },
    ja: {
      informative: "ãã®ç¯ã¯ä»æ§ã«ã¯å«ã¾ãã¾ããï¼",
    },
    de: {
      informative: "Dieser Abschnitt ist nicht normativ.",
    },
    zh: {
      informative: "æ¬ç« èä¸åå«è§èæ§åå®¹ã",
    },
    cs: {
      informative: "Tato sekce nenÃ­ normativnÃ­.",
    },
  };

  const l10n$4 = getIntlData(localizationStrings$4);

  function run$8() {
    Array.from(document.querySelectorAll("section.informative"))
      .map(informative => informative.querySelector("h2, h3, h4, h5, h6"))
      .filter(heading => heading)
      .forEach(heading => {
        heading.after(html`<p><em>${l10n$4.informative}</em></p>`);
      });
  }

  var informative = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$8,
    run: run$8
  });

  // @ts-check
  // Module core/id-headers
  // All headings are expected to have an ID, unless their immediate container has one.
  // This is currently in core though it comes from a W3C rule. It may move in the future.

  const name$7 = "core/id-headers";

  const localizationStrings$3 = {
    en: {
      /**
       *
       * @param {"Appendix" | "Section"} sectionType
       */
      permalinkLabel(sectionType, sectionNumber) {
        let label = `Permalink for${
        !sectionNumber ? " this" : ""
      } ${sectionType}`;
        if (sectionNumber) {
          label += ` ${norm(sectionNumber.textContent)}`;
        }
        return label;
      },
    },
  };
  const l10n$3 = getIntlData(localizationStrings$3);

  function run$7(conf) {
    /** @type {NodeListOf<HTMLElement>} */
    const headings = document.querySelectorAll(
      `section:not(.head,#abstract,#sotd) h2, h3, h4, h5, h6`
    );
    for (const h of headings) {
      // prefer for ID: heading.id > parentElement.id > newly generated heading.id
      let id = h.id;
      if (!id) {
        addId(h);
        id = h.parentElement.id || h.id;
      }
      if (!conf.addSectionLinks) continue;
      const label = l10n$3.permalinkLabel(
        h.closest(".appendix") ? "Appendix" : "Section",
        h.querySelector(":scope > bdi.secno")
      );
      const wrapper = html`<div class="header-wrapper"></div>`;
      h.replaceWith(wrapper);
      const selfLink = html`<a
      href="#${id}"
      class="self-link"
      aria-label="${label}"
    ></a>`;
      wrapper.append(h, selfLink);
    }
  }

  var idHeaders = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$7,
    run: run$7
  });

  // Module pcisig/fig-tbl-eqn-numbering
  // Find figure numbers and adjust them to include the chapter number.
  // Edit the Table of Figures as well.
  // This happens as a distinct pass for two reasons:
  // 1. core/figures runs before core/structure and thus doesn't know Chapter and Appendix numbers
  // 2. A second pass means that this plugin is not part of the src/core.


  const name$6 = "pcisig/fig-tbl-eqn-numbering";

  function run$6(conf, doc, cb) {
    if (conf.numberByChapter) {
      let $secs = $("body > section[data-secno]", doc);
      let figNumMap = new Map();
      let tblNumMap = new Map();
      let eqnNumMap = new Map();
      for (let i = 0; i < $secs.length; i++) {
        let $sec = $($secs[i], doc);
        let secno = $sec.attr("data-secno");
        let first;

        // Process Figure Captions, populating figNumMap
        first = 0;
        $("figcaption > span.figno", $sec).each(function () {
            let $figno_elem = $(this);
            let figno = parseInt($figno_elem.text(), 10);
            if (first === 0) first = figno;
            let new_figno = secno + "-" + (figno - first + 1);
            figNumMap.set(figno, new_figno);
            $figno_elem.text(new_figno);
          }
        );

        // Process Table Captions, populating tblNumMap
        first = 0;
        $("caption > span.tblno", $sec).each(function () {
            let $tblno_elem = $(this);
            let tblno = parseInt($tblno_elem.text(), 10);
            if (first === 0) first = tblno;
            let new_tblno = secno + "-" + (tblno - first + 1);
            tblNumMap.set(tblno, new_tblno);
            $tblno_elem.text(new_tblno);
          }
        );

        // Process Eqnure Captions, populating eqnNumMap
        first = 0;
        $("figcaption > span.eqnno", $sec).each(function () {
            let $eqnno_elem = $(this);
            let eqnno = parseInt($eqnno_elem.text(), 10);
            if (first === 0) first = eqnno;
            let new_eqnno = secno + "-" + (eqnno - first + 1);
            eqnNumMap.set(eqnno, new_eqnno);
            $eqnno_elem.text(new_eqnno);
          }
        );
      }

      // Convert Figure References using figNumMap
      $("a.fig-ref > span.figno", doc).each(function () {
        let old_num = parseInt($(this).text(), 10);
        if (figNumMap.has(old_num)) {
          $(this).text(figNumMap.get(old_num));
        }
      });
      // Convert List of Figures using figNumMap
      $("li.tofline > a.tocxref > span.figno", doc).each(function () {
        let old_num = parseInt($(this).text(), 10);
        if (figNumMap.has(old_num)) {
          $(this).text(figNumMap.get(old_num));
        }
      });

      // Convert Table References using tblNumMap
      $("a.tbl-ref > span.tblno", doc).each(function () {
        let old_num = parseInt($(this).text(), 10);
        if (tblNumMap.has(old_num)) {
          $(this).text(tblNumMap.get(old_num));
        }
      });
      // Convert List of Tables using tblNumMap
      $("li.totline > a.tocxref > span.tblno", doc).each(function () {
        let old_num = parseInt($(this).text(), 10);
        if (tblNumMap.has(old_num)) {
          $(this).text(tblNumMap.get(old_num));
        }
      });

      // Convert Equation References using eqnNumMap
      $("a.eqn-ref > span.eqnno", doc).each(function () {
        let old_num = parseInt($(this).text(), 10);
        if (eqnNumMap.has(old_num)) {
          $(this).text(eqnNumMap.get(old_num));
        }
      });
      // Convert List of Equations using eqnNumMap
      $("li.toeline > a.tocxref > span.eqnno", doc).each(function () {
        let old_num = parseInt($(this).text(), 10);
        if (eqnNumMap.has(old_num)) {
          $(this).text(eqnNumMap.get(old_num));
        }
      });
    }
    cb();
  }

  var figTblEqnNumbering = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$6,
    run: run$6
  });

  // Module w3c/aria
  // Adds wai-aria landmarks and roles to entire document.
  // Introduced by Shane McCarron (shane@aptest.com) from the W3C PFWG
  const name$5 = "w3c/aria";
  function run$5(conf, doc, cb) {
    // ensure head section is labeled
    if (!doc.body.hasAttribute("id")) {
      doc.body.setAttribute("id", "respecDocument");
    }
    var head = document.querySelector("div.head");
    if (head) {
      head.setAttribute("role", "contentinfo");
      head.setAttribute("id", "respecHeader");
    }
    var toc = doc.querySelector("#toc ol:first-of-type");
    if (toc) {
      // ensure toc is labeled
      toc.setAttribute("role", "directory");
    }
    // mark issues and notes with heading
    var noteCount = 1;
    var issueCount = 1;
    var ednoteCount = 1;
    var impnoteCount = 1;
    Array.from(
      doc.querySelectorAll(".impnote-title, .note-title, .ednote-title, .issue-title")
    ).forEach(function(element) {
      var $element = $(element);
      var isIssue = element.classList.contains("issue-title");
      var isEdNote = element.classList.contains("ednote-title");
      var isImpnote = element.classList.contains("impnote-title");
      var level = $element.parents("section").length + 2;
      element.setAttribute("aria-level", level);
      element.setAttribute("role", "heading");
      if (isIssue) {
        $element.makeID("h", "issue" + issueCount++);
      } else if (isEdNote) {
        $element.makeID("h", "ednote" + ednoteCount++);
      } else if (isImpnote) {
        $element.makeID("h", "impnote" + impnoteCount++);
      } else {
        $element.makeID("h", "note" + noteCount++);
      }
    });
    cb();
  }

  var aria = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$5,
    run: run$5
  });

  /*globals define*/
  /*jshint browser:true, jquery:true, laxcomma:true */


  const name$4 = "pcisig/xref-map";

  function run$4(conf, doc, cb) {

    if (conf.addXrefMap) {
      let $refs = $("a.tocxref", doc);
      if ($refs.length > 0) {
        let $mapsec = $("<section id='xref-map' class='introductory appendix'><h2>Section, Figure, Table, and Equation ID Map</h2></section>").appendTo($("body"));
        let $tbody = $("<table class='data'><thead><tr><th>Number</th><th>Name</th><th>ID</th></tr></thead><tbody/></table>").appendTo($mapsec).children("tbody");

        $refs.each(function () {
          let number = ($(".secno, .figno, .tblno, .eqnno", this).text()
            .replace(/ /g, "&nbsp;").replace(/-/g, "&#8209;"));
          let id = $(this).attr("href");
          let name = $(".sect-title, .fig-title, .tbl-title, .eqn-title", this).text();
          $("<tr><td>" + number + "</td>" +
            "<td class='long'>" + name + "</td>" +
            "<td class='long'><a href=\"" + id + "\">" + id.substr(1) + "</a></td></tr>").appendTo($tbody);
        });
      }
    }
    cb();
  }

  var xrefMap = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$4,
    run: run$4
  });

  // @ts-check
  // Module ui/about-respec
  // A simple about dialog with pointer to the help

  const localizationStrings$2 = {
    en: {
      about_respec: "About",
    },
    zh: {
      about_respec: "å³äº",
    },
    nl: {
      about_respec: "Over",
    },
    ja: {
      about_respec: "ããã«ã¤ãã¦",
    },
    de: {
      about_respec: "Ãber",
    },
    cs: {
      about_respec: "O aplikaci",
    },
  };
  const l10n$2 = getIntlData(localizationStrings$2);

  // window.respecVersion is added at build time (see tools/builder.js)
  window.respecVersion = window.respecVersion || "Developer Edition";
  const div = document.createElement("div");
  const render = html.bind(div);
  const button = ui.addCommand(
    `${l10n$2.about_respec} ${window.respecVersion}`,
    show,
    "Ctrl+Shift+Alt+A",
    "â¹ï¸"
  );

  function show() {
    const entries = [];
    if ("getEntriesByType" in performance) {
      performance
        .getEntriesByType("measure")
        .sort((a, b) => b.duration - a.duration)
        .map(({ name, duration }) => {
          const humanDuration =
            duration > 1000
              ? `${Math.round(duration / 1000.0)} second(s)`
              : `${duration.toFixed(2)} milliseconds`;
          return { name, duration: humanDuration };
        })
        .map(perfEntryToTR)
        .forEach(entry => {
          entries.push(entry);
        });
    }
    render`
  <p>
    ReSpec is a document production toolchain, with a notable focus on W3C specifications.
  </p>
  <p>
    <a href='https://respec.org/docs'>Documentation</a>,
    <a href='https://github.com/speced/respec/issues'>Bugs</a>.
  </p>
  <table border="1" width="100%" hidden="${entries.length ? false : true}">
    <caption>
      Loaded plugins
    </caption>
    <thead>
      <tr>
        <th>
          Plugin Name
        </th>
        <th>
          Processing time
        </th>
      </tr>
    </thead>
    <tbody>${entries}</tbody>
  </table>
`;
    ui.freshModal(`${l10n$2.about_respec} - ${window.respecVersion}`, div, button);
  }

  function perfEntryToTR({ name, duration }) {
    const moduleURL = `https://github.com/speced/respec/blob/develop/src/${name}.js`;
    return html`
    <tr>
      <td><a href="${moduleURL}">${name}</a></td>
      <td>${duration}</td>
    </tr>
  `;
  }

  var aboutRespec = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

  // @ts-check
  // Module ui/save-html
  // Saves content to HTML when asked to

  const name$3 = "ui/save-html";

  const localizationStrings$1 = {
    en: {
      save_snapshot: "Export",
    },
    nl: {
      save_snapshot: "Bewaar Snapshot",
    },
    ja: {
      save_snapshot: "ä¿å­ãã",
    },
    de: {
      save_snapshot: "Exportieren",
    },
    zh: {
      save_snapshot: "å¯¼åº",
    },
  };
  const l10n$1 = getIntlData(localizationStrings$1);

  const downloadLinks = [
    {
      id: "respec-save-as-html",
      ext: "html",
      title: "HTML",
      type: "text/html",
      get href() {
        return rsDocToDataURL(this.type);
      },
    },
    {
      id: "respec-save-as-xml",
      ext: "xhtml",
      title: "XML",
      type: "application/xml",
      get href() {
        return rsDocToDataURL(this.type);
      },
    },
    {
      id: "respec-save-as-epub",
      ext: "epub",
      title: "EPUB 3",
      type: "application/epub+zip",
      get href() {
        // Create and download an EPUB 3.2 version of the content
        // Using the EPUB 3.2 conversion service set up at labs.w3.org/r2epub
        // For more details on that service, see https://github.com/iherman/respec2epub
        const epubURL = new URL("https://labs.w3.org/r2epub/");
        epubURL.searchParams.append("respec", "true");
        epubURL.searchParams.append("url", document.location.href);
        return epubURL.href;
      },
    },
  ];

  /**
   * @param {typeof downloadLinks[0]} details
   */
  function toDownloadLink(details, conf) {
    const { id, href, ext, title, type } = details;
    const date = concatDate(conf.publishDate || new Date());
    const filename = [conf.specStatus, conf.shortName || "spec", date].join("-");
    return html`<a
    href="${href}"
    id="${id}"
    download="${filename}.${ext}"
    type="${type}"
    class="respec-save-button"
    onclick=${() => ui.closeModal()}
    >${title}</a
  >`;
  }

  function run$3(conf) {
    const saveDialog = {
      async show(button) {
        await document.respec.ready;
        const div = html`<div class="respec-save-buttons">
        ${downloadLinks.map(details => toDownloadLink(details, conf))}
      </div>`;
        ui.freshModal(l10n$1.save_snapshot, div, button);
      },
    };

    const supportsDownload = "download" in HTMLAnchorElement.prototype;
    let button;
    if (supportsDownload) {
      button = ui.addCommand(l10n$1.save_snapshot, show, "Ctrl+Shift+Alt+S", "ð¾");
    }

    function show() {
      if (!supportsDownload) return;
      saveDialog.show(button);
    }
  }

  /**
   * @param {*} _
   * @param {string} mimeType
   */
  function exportDocument(_, mimeType) {
    const msg =
      "Exporting via ui/save-html module's `exportDocument()` is deprecated and will be removed.";
    const hint = "Use core/exporter `rsDocToDataURL()` instead.";
    showWarning(msg, name$3, { hint });
    return rsDocToDataURL(mimeType);
  }

  var saveHtml = /*#__PURE__*/Object.freeze({
    __proto__: null,
    exportDocument: exportDocument,
    name: name$3,
    run: run$3
  });

  // @ts-check
  /**
   * Module core/data-tests
   *
   * Allows specs to link to test files in a test suite, by adding `details` of where
   * particular tests for a testable assertion can be found.
   *
   * `data-tests` takes a space separated list of URLs, e.g. data-test="foo.html bar.html".
   *
   * Docs: https://respec.org/doc/#data-tests
   */
  const localizationStrings = {
    en: {
      missing_test_suite_uri: docLink`Found tests in your spec, but missing ${"[testSuiteURI]"} in your ReSpec config.`,
      tests: "tests",
      test: "test",
    },
    ja: {
      missing_test_suite_uri: docLink`ãã®ä»æ§åã«ãã¹ãã®é ç®ãæ¤åºãã¾ãããï¼ReSpec ã®è¨­å®ã« ${"[testSuiteURI]"} ãè¦ã¤ããã¾ããï¼`,
      tests: "ãã¹ã",
      test: "ãã¹ã",
    },
    de: {
      missing_test_suite_uri: docLink`Die Spezifikation enthÃ¤lt Tests, aber in der ReSpec-Konfiguration ist keine ${"[testSuiteURI]"} angegeben.`,
      tests: "Tests",
      test: "Test",
    },
    zh: {
      missing_test_suite_uri: docLink`æ¬è§èä¸­åå«æµè¯ï¼ä½å¨ ReSpec éç½®ä¸­ç¼ºå° ${"[testSuiteURI]"}ã`,
      tests: "æµè¯",
      test: "æµè¯",
    },
  };

  const l10n = getIntlData(localizationStrings);

  const name$2 = "core/data-tests";

  function toListItem(href) {
    const emojiList = [];
    const [testFile] = new URL(href).pathname.split("/").reverse();
    const testParts = testFile.split(".");
    let [testFileName] = testParts;

    const isSecureTest = testParts.find(part => part === "https");
    if (isSecureTest) {
      const requiresConnectionEmoji = document.createElement("span");
      requiresConnectionEmoji.textContent = "ð";
      requiresConnectionEmoji.setAttribute(
        "aria-label",
        "requires a secure connection"
      );
      requiresConnectionEmoji.setAttribute("title", "Test requires HTTPS");
      testFileName = testFileName.replace(".https", "");
      emojiList.push(requiresConnectionEmoji);
    }

    const isManualTest = testFileName
      .split(".")
      .join("-")
      .split("-")
      .find(part => part === "manual");
    if (isManualTest) {
      const manualPerformEmoji = document.createElement("span");
      manualPerformEmoji.textContent = "ðª";
      manualPerformEmoji.setAttribute(
        "aria-label",
        "the test must be run manually"
      );
      manualPerformEmoji.setAttribute("title", "Manual test");
      testFileName = testFileName.replace("-manual", "");
      emojiList.push(manualPerformEmoji);
    }

    const testList = html`
    <li>
      <a href="${href}">${testFileName}</a>
      ${emojiList}
    </li>
  `;
    return testList;
  }

  function run$2(conf) {
    /** @type {NodeListOf<HTMLElement>} */
    const elems = document.querySelectorAll("[data-tests]");
    const testables = [...elems].filter(elem => elem.dataset.tests);

    if (!testables.length) {
      return;
    }
    if (!conf.testSuiteURI) {
      showError(l10n.missing_test_suite_uri, name$2);
      return;
    }

    for (const elem of testables) {
      const tests = elem.dataset.tests.split(/,/gm).map(url => url.trim());
      const testURLs = toTestURLs(tests, conf.testSuiteURI, elem);
      handleDuplicates(testURLs, elem);
      const details = toHTML(testURLs);
      elem.append(details);
    }
  }

  /**
   * @param {string[]} tests
   * @param {string} testSuiteURI
   * @param {HTMLElement} elem
   */
  function toTestURLs(tests, testSuiteURI, elem) {
    return tests
      .map(test => {
        try {
          return new URL(test, testSuiteURI).href;
        } catch {
          const msg = docLink`Invalid URL in ${"[data-tests]"} attribute: ${test}.`;
          showWarning(msg, name$2, { elements: [elem] });
        }
      })
      .filter(href => href);
  }

  /**
   * @param {string[]} testURLs
   * @param {HTMLElement} elem
   */
  function handleDuplicates(testURLs, elem) {
    const duplicates = testURLs.filter(
      (link, i, self) => self.indexOf(link) !== i
    );
    if (duplicates.length) {
      const msg = docLink`Duplicate tests found in the ${"[data-tests]"} attribute.`;
      const tests = codedJoinAnd(duplicates, { quotes: true });
      const hint = docLink`To fix, remove duplicates from ${"[data-tests]"}: ${tests}.`;
      showWarning(msg, name$2, { hint, elements: [elem] });
    }
  }

  /**
   * @param {string[]} testURLs
   */
  function toHTML(testURLs) {
    const uniqueList = [...new Set(testURLs)];
    const details = html`
    <details class="respec-tests-details removeOnSave">
      <summary>tests: ${uniqueList.length}</summary>
      <ul>
        ${uniqueList.map(toListItem)}
      </ul>
    </details>
  `;
    return details;
  }

  var dataTests = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$2,
    run: run$2
  });

  const name$1 = "core/include-final-config";

  function run$1(conf, doc, cb) {

    const script = doc.createElement("script");
    script.id = "finalUserConfig";
    script.type = "application/json";
    script.innerHTML = JSON.stringify(conf, null, 2);
    doc.head.appendChild(script);
    cb();
  }

  var includeFinalConfig = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$1,
    run: run$1
  });

  // Module pcisig/empty-references
  // Find references with empty content and invent content.
  // This must run AFTER structure.js


  const name = "pcisig/empty-references";

  function run(conf, doc, cb) {
    // Update all anchors with empty content that are not in a table of contents
    $("a[href^='#']:empty():not(.tocxref)", doc).each(function() {
      let $a = $(this),
        id = $a.attr("href"),
        was = $a.attr("data-was");
      if (id) {
        $a.addclass('respec-error');
        $a.append("[["+ id);
        if (was) $a.append(" data-was=\"" + was + "\"");
        $a.append("]]");
      }
    });

    cb();
  }

  var emptyReferences = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name,
    run: run
  });

  return pcisig;

})();
//# sourceMappingURL=respec-pcisig.js.map
