<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <title>
      Presentation API
    </title>
    <script src='/node_modules/requirejs/require.js' data-main='/js/profile-w3c-common' async class='remove'></script>
    </script>
    <script class="remove">
    var respecConfig = {
        specStatus: 'ED',
        edDraftURI: 'https://w3c.github.io/presentation-api/',
        shortName:  'presentation-api',
        editors: [
          {
            w3cid: 68454,
            name: 'Mark Foltz',
            company: 'Google',
            mailto: 'mfoltz@google.com'
          },
          {
            w3cid: 63802,
            name: 'Dominik RÃ¶ttsches',
            company: 'Intel',
            note: 'until April 2015'
          }
        ],
        previousMaturity: 'WD',
        previousPublishDate: '2015-07-01',
        otherLinks: [
          {
            key: 'Version history',
            data: [
              {
                value: 'GitHub w3c/presentation-api/commits',
                href: 'https://github.com/w3c/presentation-api/commits/'
              }
            ]
          },
          {
            key: 'Participate',
            data: [
              {
                value: 'GitHub w3c/presentation-api',
                href: 'https://github.com/w3c/presentation-api/'
              },
              {
                value: 'File an issue',
                href: 'https://github.com/w3c/presentation-api/issues/new'
              },
              {
                value: 'Open issues',
                href: 'https://github.com/w3c/presentation-api/issues/'
              },
              {
                value: 'Mailing-list (public-secondscreen@w3.org)',
                href: 'https://lists.w3.org/Archives/Public/public-secondscreen/'
              }
            ]
          }
        ],
        sotdAfterWGinfo: true,
        wg: 'Second Screen Presentation Working Group',
        wgURI: 'http://www.w3.org/2014/secondscreen/',
        wgPublicList: 'public-secondscreen',
        wgPatentURI: 'http://www.w3.org/2004/01/pp-impl/74168/status',
        issueBase: "https://www.github.com/w3c/presentation-api/issues/",
        // TODO: Uncomment when https://github.com/w3c/presentation-api/issues/228 is fixed
        // githubAPI: "https://api.github.com/repos/w3c/presentation-api"
      };
    </script>
    <style>
    /* Note formatting taken from HTML5 spec */
    .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    .note em, .warning em, .note i, .warning i { font-style: normal; }
    p.note, div.note { padding: 0.5em 2em; }
    span.note { padding: 0 2em; }
    .note p:first-child { margin-top: 0; }
    .note p:last-child { margin-bottom: 0; }
    p.note:before { content: 'NOTE: '; }
    .non-normative { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    p.non-normative:before { content: 'Non-normative: '; font-weight: bolder;}
    p.non-normative, div.non-normative { padding: 0.5em 2em; }


    /* Pre.idl formatting taken from HTML5 spec */
    pre.idl { border: solid thin #d3d3d3; background: #FCFCFC; color: black; padding: 0.5em 1em; position: relative; }
    pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
    pre.idl::before { content: "IDL"; font: bold small sans-serif;
    padding: 0.5em; background: white; position: absolute; top: 0;
    margin: -1px 0 0 -4em; width: 1.5em; border: thin solid;
    border-radius: 0 0 0 0.5em }

    /* .example idl formatting taken from HTML5 nightly spec */
    .example {
        display: block;
        color: #222222;
        background: #FCFCFC;
        border-left-style: solid;
        border-color: #c0c0c0;
        border-left-width: 0.25em;
        margin-left: 1em;
        padding-left: 1em;
        padding-bottom: 0.5em;
    }

    .algorithm li {
        margin-bottom: 0.5em;
    }

    .interface dd, .parameters dt {
        margin-bottom: 0.5em;
    }

    code { color: orangered; }
    table { border-collapse: collapse; border-style: hidden hidden none hidden; }
    table thead, table tbody { border-bottom: solid; }
    table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
    dfn { font-weight: bolder; font-style: normal; }
    .copyright { font-size: small; }
    .issue[id^='issue-'] > *:not([role='heading']) { display: none; }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        This specification defines an API to enable web content to access
        external presentation-type displays and use them for presenting web
        content.
      </p>
    </section>
    <section id="sotd">
      <p>
        Since publication as Working Draft on <a href=
        "https://www.w3.org/TR/2015/WD-presentation-api-20151013/">13 October
        2015</a>, the Working Group has refined the interfaces and
        significantly improved all procedures. Security and privacy
        considerations have been completed based on feedback and interactions
        with other W3C groups. The Working Group intends to publish a Candidate
        Recommendation soon and seeks wide review of this document. Horizontal
        reviews and feedback from early experimentations and developers willing
        to use this specification are encouraged.
      </p>
      <p>
        Some open issues remain, including on ways to pass the language
        settings from the controller to the presentation and on whether the
        messaging channel should expose a congestion control mechanism; please
        check the group's <a href=
        "https://github.com/w3c/presentation-api/issues">issue tracker</a> on
        GitHub for a complete list of open issues.
      </p>
    </section>
    <section class="informative">
      <h2>
        Introduction
      </h2>
      <p>
        This specification aims to make <a>presentation displays</a> such as
        projectors or connected TVs, available to the Web and takes into
        account displays that are attached using wired (HDMI, DVI, or similar)
        and wireless technologies (Miracast, Chromecast, DLNA, AirPlay, or
        similar).
      </p>
      <p>
        Devices with limited screen size lack the ability to show content to a
        larger audience, for example, a group of colleagues in a conference
        room, or friends and family at home. Showing content on an external
        large <a>presentation display</a> helps to improve the perceived
        quality and impact of the presented content.
      </p>
      <p>
        At its core, this specification enables an exchange of messages between
        a page that acts as the <a>controller</a> and another page that
        represents the <a data-lt="receiving browsing context">presentation</a>
        shown in the <a>presentation display</a>. How the messages are
        transmitted is left to the UA in order to allow the use of
        <a>presentation display</a> devices that can be attached in a wide
        variety of ways. For example, when a <a>presentation display</a> device
        is attached using HDMI or Miracast, the same UA that acts as the
        <a>controller</a> renders the <a data-lt=
        "receiving browsing context">presentation</a>. Instead of displaying
        the <a data-lt="receiving browsing context">presentation</a> in another
        window on the same device, however, it can use whatever means the
        operating system provides for using the external <a>presentation
        displays</a>. In such a case, both the <a>controller</a> and
        <a data-lt="receiving browsing context">presentation</a> run on the
        same UA and the operating system is used to route the <a>presentation
        display</a> output to the <a>presentation display</a>. This is commonly
        referred to as the <dfn><b id="1-ua">1-UA</b></dfn> case. This
        specification imposes no requirements on the <a>presentation
        display</a> devices connected in such a manner.
      </p>
      <p>
        If the <a>presentation display</a> is able to render HTML documents and
        communicate with the <a>controller</a>, the <a>controller</a> does not
        need to render the <a data-lt=
        "receiving browsing context">presentation</a>. In this case, the UA
        acts as a proxy that requests the <a>presentation display</a> to show
        and render the <a data-lt="receiving browsing context">presentation</a>
        itself. This is commonly referred to as the <b id="2-ua">2-UA</b> case.
        This way of attaching to displays could be enhanced in the future by
        defining a standard protocol for delivering these types of messages
        that display devices could choose to implement.
      </p>
      <p>
        The API defined here is intended to be used with UAs that attach to
        <a>presentation display</a> devices through any of the above means.
      </p>
    </section>
    <section id="use-cases-and-requirements">
      <h2>
        Use cases and requirements
      </h2>
      <p>
        Use cases and requirements are captured in a separate <a href=
        "https://github.com/w3c/presentation-api/blob/gh-pages/uc-req.md">Presentation
        API Use Cases and Requirements</a> document.
      </p>
    </section>
    <section id="conformance">
      <p>
        Requirements phrased in the imperative as part of algorithms (such as
        "strip any leading space characters" or "return false and terminate
        these steps") are to be interpreted with the meaning of the key word
        ("MUST", "SHOULD", "MAY", etc.) used in introducing the algorithm.
      </p>
      <p>
        Conformance requirements phrased as algorithms or specific steps may be
        implemented in any manner, so long as the result is equivalent. (In
        particular, the algorithms defined in this specification are intended
        to be easy to follow, and not intended to be performant.)
      </p>
      <section>
        <h3>
          Conformance Classes
        </h3>
        <p>
          This specification describes the conformance criteria for two classes
          of <dfn data-lt="user agent">user agents</dfn>.
        </p>
        <dl>
          <dt>
            <dfn>Controlling user agent</dfn>
          </dt>
          <dd>
            <p>
              Web browsers that conform to the specifications of a
              <a>controlling user agent</a> must be able to start and control
              presentations by providing a <a>controlling browsing context</a>
              as described in this specification. This context implements the
              <a><code>Presentation</code></a>,
              <a><code>PresentationConnection</code></a>,
              <a><code>PresentationConnectionAvailableEvent</code></a>, and
              <a><code>PresentationRequest</code></a> interfaces.
            </p>
          </dd>
          <dt>
            <dfn>Receiving user agent</dfn>
          </dt>
          <dd>
            <p>
              Web browsers that conform to the specifications of a <a>receiving
              user agent</a> must be able to render presentations by providing
              a <a>receiving browsing context</a> as described in this
              specification. This context implements the
              <a><code>Presentation</code></a>,
              <a><code>PresentationConnection</code></a>,
              <a><code>PresentationConnectionAvailableEvent</code></a>, and
              <a><code>PresentationReceiver</code></a> interfaces.
            </p>
          </dd>
        </dl>
        <p>
          One user agent may act both as a <a>controlling user agent</a> and as
          a <a>receiving user agent</a>, if it provides both browsing contexts
          and implements all of their required interfaces. This can happen when
          the same user agent is able to host the <a>controlling browsing
          context</a> and the <a>receiving browsing context</a> for a
          presentation, as in the <a>1-UA</a> implementation of the API.
        </p>
        <p>
          Conformance requirements phrased against a <a>user agent</a> apply
          either to a <a>controlling user agent</a>, a <a>receiving user
          agent</a> or to both classes, depending on the context.
        </p>
      </section>
    </section>
    <section>
      <h2>
        Terminology
      </h2>
      <p>
        The terms <dfn><a href=
        "http://www.w3.org/TR/html5/browsers.html#browsing-context">browsing
        context</a></dfn>, <dfn><a href=
        "https://www.w3.org/TR/html5/browsers.html#nested-browsing-contexts">nested
        browsing context</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html5/webappapis.html#event-handlers">event
        handler</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html5/webappapis.html#event-handler-event-type">event
        handler event type</a></dfn>, <dfn data-lt="fire|fires"><a href=
        "http://www.w3.org/TR/html5/infrastructure.html#concept-event-fire">firing
        an event</a></dfn>, <dfn data-lt="fire a simple event"><a href=
        "http://www.w3.org/TR/html5/webappapis.html#fire-a-simple-event">firing
        a simple event</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html5/browsers.html#navigate">navigate</a></dfn>,
        <dfn><a href=
        "http://www.w3.org/TR/html5/webappapis.html#queue-a-task">queue a
        task</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html5/infrastructure.html#concept-events-trusted">
        trusted event</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html5/browsers.html#allowed-to-show-a-popup">allowed
        to show a popup</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html5/browsers.html#top-level-browsing-context">top-level
        browsing context</a></dfn>, <dfn><a href=
        "https://www.w3.org/TR/html5/browsers.html#unload-a-document">unload a
        document</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html5/browsers.html#session-history">session
        history</a></dfn>, <dfn><a href=
        "https://www.w3.org/TR/html5/browsers.html#sandboxing-flag-set">sandboxing
        flag set</a></dfn>, <dfn><a href=
        "https://www.w3.org/TR/html5/browsers.html#active-sandboxing-flag-set">active
        sandboxing flag set</a></dfn>, <dfn><a href=
        "https://www.w3.org/TR/html5/browsers.html#parse-a-sandboxing-directive">
        parse a sandboxing directive</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html5/browsers.html#sandboxed-auxiliary-navigation-browsing-context-flag">
        sandboxed auxiliary navigation browsing context flag</a></dfn>,
        <dfn><a href=
        "http://www.w3.org/TR/html5/browsers.html#sandboxed-top-level-navigation-browsing-context-flag">
        sandboxed top-level navigation browsing context flag</a></dfn>, and
        <dfn><a href=
        "http://www.w3.org/TR/html5/webappapis.html#settings-object">settings
        object</a></dfn> are defined in [[!HTML5]].
      </p>
      <p>
        The term <dfn><a href=
        "http://www.w3.org/TR/html51/infrastructure.html#in-parallel">in
        parallel</a></dfn> is defined in [[!HTML51]].
      </p>
      <p>
        This document provides interface definitions using the Web IDL standard
        ([[!WEBIDL]]). The terms <dfn><a href=
        "https://heycam.github.io/webidl/#idl-promise">Promise</a></dfn>,
        <dfn><a href=
        "http://heycam.github.io/webidl/#idl-ArrayBuffer">ArrayBuffer</a></dfn>,
        <dfn><a href=
        "http://heycam.github.io/webidl/#idl-ArrayBufferView">ArrayBufferView</a></dfn>
        are defined in [[!WEBIDL]].
      </p>
      <p>
        The <dfn>term</dfn> throw in this specification is used as defined in
        [[!WEBIDL]]. The following exception names are defined by WebIDL and
        used by this specification:
      </p>
      <ul>
        <li>
          <dfn><code>AbortError</code></dfn>
        </li>
        <li>
          <dfn><code>InvalidAccessError</code></dfn>
        </li>
        <li>
          <dfn><code>NotFoundError</code></dfn>
        </li>
        <li>
          <dfn><code>NotSupportedError</code></dfn>
        </li>
        <li>
          <dfn><code>OperationError</code></dfn>
        </li>
        <li>
          <dfn><code>SecurityError</code></dfn>
        </li>
        <li>
          <dfn><code>SyntaxError</code></dfn>
        </li>
      </ul>
      <p>
        The terms <dfn data-lt="resolve"><a href=
        "http://www.w3.org/2001/tag/doc/promises-guide#resolve-promise">resolving
        a Promise</a></dfn>, and <dfn data-lt="reject"><a href=
        "http://www.w3.org/2001/tag/doc/promises-guide#reject-promise">rejecting
        a Promise</a></dfn> are used as explained in [[!PROMGUIDE]].
      </p>
      <p>
        The term <dfn><a href="https://url.spec.whatwg.org/#url">URL</a></dfn>
        is defined in the WHATWG URL standard [[!URL]].
      </p>
      <p>
        The term <dfn><a href=
        "http://dev.w3.org/2006/webapi/FileAPI/#blob">Blob</a></dfn> is defined
        in the File API specification [[!FILEAPI]].
      </p>
      <p>
        The term <dfn><a href=
        "http://w3c.github.io/webrtc-pc/#idl-def-RTCDataChannel">RTCDataChannel</a></dfn>
        is defined in the WebRTC API specification [[WEBRTC]].
      </p>
      <p>
        The term <dfn><a href=
        "http://tools.ietf.org/html/rfc6265#section-4.2">cookie store</a></dfn>
        is defined in RFC 6265 [[COOKIES]].
      </p>
      <p>
        The terms <dfn data-lt="permission|permissions"><a href=
        "https://w3c.github.io/permissions/#idl-def-Permission">permission</a></dfn>
        and <dfn><a href=
        "https://w3c.github.io/permissions/#idl-def-PermissionState">permission
        state</a></dfn> are defined in [[PERMISSIONS]].
      </p>
      <p>
        The term <dfn data-lt="database|databases"><a href=
        "http://www.w3.org/TR/IndexedDB/#database-concept">database</a></dfn>
        is defined in [[INDEXEDDB]].
      </p>
      <p>
        The terms <dfn><a href=
        "http://www.w3.org/TR/webstorage/#the-localstorage-attribute"><code>localStorage</code></a></dfn>
        and <dfn><a href=
        "http://www.w3.org/TR/webstorage/#the-sessionstorage-attribute"><code>sessionStorage</code></a></dfn>
        are defined in [[WEBSTORAGE]].
      </p>
      <p>
        The terms <dfn><a href=
        "https://www.w3.org/TR/mixed-content/#potentially-secure-origin">potentially
        secure</a></dfn>, <dfn><a href=
        "https://w3c.github.io/webappsec-mixed-content/#a-priori-authenticated-url">
        a priori unauthenticated URL</a></dfn>, and <dfn><a href=
        "https://w3c.github.io/webappsec-mixed-content/#categorize-settings-object">
        prohibits mixed security contexts algorithm</a></dfn> are defined in
        [[!MIXED-CONTENT]].
      </p>
      <p>
        The term <dfn><a href="http://www.dial-multiscreen.org/">DIAL</a></dfn>
        is defined in [[DIAL]].
      </p>
    </section>
    <section>
      <h2>
        Examples
      </h2>
      <p>
        This section shows example codes that highlight the usage of main
        features of the Presentation API. In these examples,
        <code>controller.html</code> implements the controller and
        <code>presentation.html</code> implements the presentation. Both pages
        are served from the domain <code>http://example.org</code>
        (<code>http://example.org/controller.html</code> and
        <code>http://example.org/presentation.html</code>). These examples
        assume that the controlling page is managing one presentation at a
        time. Please refer to the comments in the code examples for further
        details.
      </p>
      <section>
        <h3>
          Monitor availability of presentation displays example
        </h3>
        <pre class="example highlight">
&lt;!-- controller.html --&gt;
&lt;button id="presentBtn" style="display: none;"&gt;Present&lt;/button&gt;
&lt;script&gt;
  // The Present button is visible if at least one presentation display is available
  var presentBtn = document.getElementById("presentBtn");
  // It is also possible to use relative presentation URL e.g. "presentation.html"
  var presUrl = "http://example.com/presentation.html";
  // show or hide present button depending on display availability
  var handleAvailabilityChange = function(available) {
    presentBtn.style.display = available ? "inline" : "none";
  };
  // Promise is resolved as soon as the presentation display availability is
  // known.
  var request = new PresentationRequest(presUrl);
  request.getAvailability().then(function(availability) {
    // availability.value may be kept up-to-date by the controlling UA as long
    // as the availability object is alive. It is advised for the web developers
    // to discard the object as soon as it's not needed.
    handleAvailabilityChange(availability.value);
    availability.onchange = function() { handleAvailabilityChange(this.value); };
  }).catch(function() {
    // Availability monitoring is not supported by the platform, so discovery of
    // presentation displays will happen only after request.start() is called.
    // Pretend the devices are available for simplicity; or, one could implement
    // a third state for the button.
    handleAvailabilityChange(true);
  });
&lt;/script&gt;
</pre>
      </section>
      <section>
        <h3>
          Starting a new presentation example
        </h3>
        <pre class="example highlight">
&lt;!-- controller.html --&gt;
&lt;script&gt;
  presentBtn.onclick = function () {
    // Start new presentation.
    request.start()
      // The connection to the presentation will be passed to setConnection on
      // success.
      .then(setConnection);
      // Otherwise, the user canceled the selection dialog or no screens were
      // found.
  };
&lt;/script&gt;
</pre>
      </section>
      <section>
        <h3>
          Reconnect to a presentation example
        </h3>
        <pre class="example highlight">
&lt;!-- controller.html --&gt;
&lt;button id="reconnectBtn" style="display: none;"&gt;Reconnect&lt;/button&gt;
&lt;script&gt;
  var reconnect = function () {
    // read presId from localStorage if exists
    var presId = localStorage["presId"];
    // presId is mandatory when reconnecting to a presentation.
    if (!!presId) {
      request.reconnect(presId)
        // The new connection to the presentation will be passed to
        // setConnection on success.
        .then(setConnection);
        // No connection found for presUrl and presId, or an error occurred.
    }
  };
  // On navigation of the controller, reconnect automatically.
  document.addEventListener("DOMContentLoaded", reconnect);
  // Or allow manual reconnection.
  reconnectBtn.onclick = reconnect;
&lt;/script&gt;
</pre>
      </section>
      <section>
        <h3>
          Presentation initation by the controlling UA example
        </h3>
        <pre class="example highlight">
&lt;!-- controller.html --&gt;
&lt;!-- Setting presentation.defaultRequest allows the page to specify the
     PresentationRequest to use when the controlling UA initiates a
     presentation. --&gt;
&lt;script&gt;
  navigator.presentation.defaultRequest = new PresentationRequest(defaultUrl);
  navigator.presentation.defaultRequest.onconnectionavailable = function(evt) {
    setConnection(evt.connection);
  };
&lt;/script&gt;

</pre>
      </section>
      <section>
        <h3>
          Monitor connection's state and exchange data example
        </h3>
        <pre class="example highlight">
&lt;!-- controller.html --&gt;
&lt;button id="disconnectBtn" style="display: none;"&gt;Disconnect&lt;/button&gt;
&lt;button id="terminateBtn" style="display: none;"&gt;Stop&lt;/button&gt;
&lt;script&gt;
  var connection;

  // The Disconnect and Stop buttons are visible if there is a connected presentation
  var disconnectBtn = document.getElementById("disconnectBtn");
  var stopBtn = document.getElementById("stopBtn");
  stopBtn.onclick = function () { connection &amp;&amp; connection.terminate(); };

  var setConnection = function (theConnection) {
    // Disconnect from existing presentation, if any
    close();
    // Set the new connection and save the presentation ID
    connection = theConnection;
    localStorage["presId"] = connection.id;

    // monitor connection's state
    connection.onconnect = function () {
      // Allow the user to disconnect from or terminate the presentation
      disconnectBtn.style.display = "inline";
      stopBtn.style.display = "inline";
      reconnectBtn.style.display = "none";

      // register message handler
      this.onmessage = function (message) {
        console.log("receive message", message.data);
      };
      // send initial message to presentation page
      this.send("say hello");
    };
    connection.onclose = reset;
    connection.onterminate = function () {
      // remove presId from localStorage if exists
      delete localStorage["presId"];
      // Reset the UI
      reset();
    };
  };

  var reset = function () {
    connection = null;
    disconnectBtn.style.display = "none";
    stopBtn.style.display = "none";
    reconnectBtn.style.display = localStorage["presId"] ? "inline" : "none";
  };

  var close = function () { connection &amp;&amp; connection.close(); };
  disconnectBtn.onclick = close;
&lt;/script&gt;
</pre>
      </section>
      <section>
        <h3>
          Monitor available connection(s) and say hello
        </h3>
        <pre class="example highlight">
&lt;!-- receiver.html --&gt;
&lt;script&gt;
  var addConnection = function(connection) {
    connection.onconnect = function () {
      this.onmessage = function (message) {
        if (message.data == "say hello")
          this.send("hello");
      };
    };
  };

  navigator.presentation.receiver.connectionList.then(function (list) {
    list.connections.map(function (connection) {
      addConnection(connection);
    });
    list.connections.onconnectionavailable = function (connections) {
      addConnection(connections[connections.length - 1]);
    };
  });
&lt;/script&gt;
</pre>
      </section>
    </section>
    <section>
      <h2>
        API
      </h2>
      <section>
        <h3>
          Common idioms
        </h3>
        <p>
          A <dfn lt="presentation display|presentation displays">presentation
          display</dfn> refers to an external screen available to the user
          agent via an implementation specific connection technology.
        </p>
        <p>
          A <dfn lt=
          "presentation connection|presentation connections">presentation
          connection</dfn> is an object relating a <a>controlling browsing
          context</a> to its <a>receiving browsing context</a> and enables
          two-way-messaging between them. Each <a>presentation connection</a>
          has a <dfn>presentation connection state</dfn>, a <dfn lt=
          "presentation identifier|presentation identifiers">presentation
          identifier</dfn> to distinguish it from other <a>presentations</a>,
          and a <dfn>presentation URL</dfn> that is a <a>URL</a> used to create
          or resume the <a>presentation</a>. A <dfn>valid presentation
          identifier</dfn> consists of alphanumeric ASCII characters only and
          is at least 16 characters long.
        </p>
        <p>
          A <dfn lt=
          "controlling browsing context|controlling browsing contexts">controlling
          browsing context</dfn> (or <dfn>controller</dfn> for short) is a
          <a>browsing context</a> that has connected to a <a>presentation</a>
          by calling <code><a for="PresentationRequest">start</a>()</code> or
          <code><a for="PresentationRequest">reconnect</a>()</code>, or
          received a <a>presentation connection</a> via a <a for=
          "PresentationRequest">connectionavailable</a> event.
        </p>
        <p>
          The <dfn data-lt=
          "receiving browsing context|receiving browsing contexts">receiving
          browsing context</dfn> (or <dfn for="idiom" data-lt=
          "presentations">presentation</dfn> for short) is the browsing context
          responsible for rendering to a <a>presentation display</a>. A
          <a>receiving browsing context</a> can reside in the same user agent
          as the <a>controlling browsing context</a> or a different one. A
          <a>receiving browsing context</a> is created by following the steps
          to <a>create a receiving browsing context</a>.
        </p>
        <p>
          In a procedure, the <dfn>destination browsing context</dfn> is the
          <a>receiving browsing context</a> when the procedure is initiated at
          the <a>controlling browsing context</a>, or the <a>controlling
          browsing context</a> if it is initiated at the <a>receiving browsing
          context</a>.
        </p>
        <p>
          The <dfn>set of controlled presentations</dfn>, initially empty,
          contains the <a>presentation connections</a> created by the
          <a>controlling browsing contexts</a> for the <a>controlling user
          agent</a> (or a specific user profile within that user agent). The
          <a>set of controlled presentations</a> is represented by a list of
          <a>PresentationConnection</a> objects that represent the underlying
          <a>presentation connections</a>. Several
          <a>PresentationConnection</a> objects may share the same
          <a>presentation URL</a> and <a>presentation identifier</a> in that
          set, but there can be only one <a>PresentationConnection</a> with a
          specific <a>presentation URL</a> and <a>presentation identifier</a>
          for a given <a>controlling browsing context</a>.
        </p>
        <p>
          The <dfn>set of presentation controllers</dfn>, initially empty,
          contains the <a>presentation connections</a> created by a
          <a>receiving browsing context</a> for the <a>receiving user
          agent</a>. The <a>set of presentation controllers</a> is represented
          by a list of <a>PresentationConnection</a> objects that represent the
          underlying <a>presentation connections</a>. All <a>presentation
          connections</a> in this set share the same <a>presentation URL</a>
          and <a>presentation identifier</a>.
        </p>
      </section>
      <section>
        <h3>
          Interface <code>Presentation</code>
        </h3>
        <pre class="idl">
          partial interface Navigator {
            [SameObject] readonly attribute Presentation? presentation;
          };

          interface Presentation {
          };
        </pre>
        <p>
          The <dfn for="Navigator"><code>presentation</code></dfn> attribute is
          used to retrieve an instance of the <a><code>Presentation</code></a>
          interface. If <a>presentation is disabled</a>, the attribute MUST
          return null. Otherwise, it MUST return the
          <a><code>Presentation</code></a> instance.
        </p>
        <section>
          <h4>
            Controlling user agent
          </h4>
          <pre class="idl idl-controlling-ua">
            partial interface Presentation {
              attribute PresentationRequest? defaultRequest;
            };
          </pre>
          <p>
            In a <a>controlling user agent</a>, the <dfn for=
            "Presentation"><code>defaultRequest</code></dfn> attribute MUST
            return the <a>default presentation request</a> if any,
            <code>null</code> otherwise. In a <a>receiving browsing
            context</a>, it MUST return <code>null</code>.
          </p>
          <p>
            If set by the <a>controller</a>, the value of the <a for=
            "Presentation">defaultRequest</a> attribute SHOULD be used by the
            <a>controlling user agent</a> as the <dfn>default presentation
            request</dfn> for that controller. When the <a>controlling user
            agent</a> wishes to initiate a <a>PresentationConnection</a> on the
            controller's behalf, it MUST <a>start a presentation</a> using the
            <a>default presentation request</a> for the <a>controller</a> (as
            if the controller had called <code>defaultRequest.start()</code>).
          </p>
          <p>
            The <a>controlling user agent</a> SHOULD initiate presentation
            using the <a>default presentation request</a> only when the user
            has expressed an intention to do so, for example by clicking a
            button in the browser.
          </p>
          <div class="note">
            Not all <a data-lt="controlling user agent">controlling user
            agents</a> may support initiation of a presentation connection via
            the browser chrome. In this case, setting
            <code>defaultRequest</code> would have no effect.
          </div>
          <div class="issue">
            It should be clear that user-intiated presentation via the user
            agent may have pre-selected the presentation display. In this case
            step 6 of <a>start a presentation</a> is optional. It may be
            cleaner to define a separate set of steps for initiating a default
            presentation.
          </div>
        </section>
        <section>
          <h4>
            Receiving user agent
          </h4>
          <pre class="idl idl-receiving-ua">
            partial interface Presentation {
              [SameObject] readonly attribute PresentationReceiver? receiver;
            };
          </pre>
          <p>
            In a <a>receiving user agent</a>, the <dfn for=
            "Presentation"><code>receiver</code></dfn> attribute MUST return
            the <a><code>PresentationReceiver</code></a> instance associated
            with the <a>receiving browsing context</a> and created by the
            <a>receiving user agent</a> when the <a>receiving browsing
            context</a> is created. In any other <a>browsing context</a>, it
            MUST return <code>null</code>.
          </p>
          <p>
            A user agent that is a <a>receiving user agent</a> but not a
            <a>controlling user agent</a> MUST always return <code>null</code>
            for the <a for="Presentation">defaultRequest</a> attribute. It MUST
            treat setting the <a for="Presentation">defaultRequest</a>
            attribute as a no-op.
          </p>
          <p>
            A user agent that is a <a>controlling user agent</a> but not a
            <a>receiving user agent</a> MUST always return <code>null</code>
            for the <a for="Presentation">receiver</a> attribute.
          </p>
        </section>
      </section>
      <section>
        <h3>
          Interface <a><code>PresentationRequest</code></a>
        </h3>
        <pre class="idl">
          [Constructor(DOMString url)]
          interface PresentationRequest : EventTarget {
            Promise&lt;PresentationConnection&gt; start();
            Promise&lt;PresentationConnection&gt; reconnect(DOMString presentationId);
            Promise&lt;PresentationAvailability&gt; getAvailability();

            attribute EventHandler onconnectionavailable;
          };


</pre>
        <p>
          A <a><code>PresentationRequest</code></a> object is associated with a
          request to initiate or reconnect to a presentation made by a
          <a>controlling browsing context</a>. The
          <a><code>PresentationRequest</code></a> object MUST be implemented in
          a <a>controlling browsing context</a> provided by a <a>controlling
          user agent</a>.
        </p>
        <p>
          When a <a><code>PresentationRequest</code></a> is constructed, the
          given <code>url</code> MUST be used as the <dfn>presentation request
          URL</dfn> which is the <a>presentation URL</a> for the
          <a><code>PresentationRequest</code></a> instance.
        </p>
        <section>
          <h4>
            Constructing a <code>PresentationRequest</code>
          </h4>
          <p>
            When the <code>PresentationRequest</code> constructor is called,
            the <a>controlling user agent</a> MUST run these steps:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>url</var>, the <a>presentation request URL</a>
            </dd>
            <dt>
              Output
            </dt>
            <dd>
              A <code>PresentationRequest</code> object
            </dd>
          </dl>
          <ol>
            <li>Resolve <var>url</var> relative to the API base URL specified
            by the entry <a>settings object</a>, and let
            <var>presentationUrl</var> be the resulting absolute URL, if any.
            </li>
            <li>If the resolve a URL algorithm failed, then throw a
            <a>SyntaxError</a> exception and abort the remaining steps.
            </li>
            <li>Construct a new <code>PresentationRequest</code> object with
            <var>presentationUrl</var> as the constructor argument and return
            it.
            </li>
          </ol>
        </section>
        <section>
          <h4>
            Starting a presentation
          </h4>
          <p>
            When the <code><dfn for="PresentationRequest">start</dfn></code>
            method is called, the <a>user agent</a> MUST run the following
            steps to <dfn>start a presentation</dfn>:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>presentationRequest</var>, the
              <code>PresentationRequest</code> object
            </dd>
            <dd>
              <var>presentationUrl</var>, the <a>presentation request URL</a>
            </dd>
            <dt>
              Output
            </dt>
            <dd>
              A <a>Promise</a>
            </dd>
          </dl>
          <ol>
            <li>If the algorithm isn't <a>allowed to show a popup</a>, return a
            <a>Promise</a> rejected with an <a>InvalidAccessError</a> exception
            and abort these steps.
            </li>
            <li>Using the document's <a>settings object</a>, run the
            <a>prohibits mixed security contexts algorithm</a>.
            </li>
            <li>If the result of the algorithm is <code>"Prohibits Mixed
            Security Contexts"</code> and <var>presentationUrl</var> is an <a>
              a priori unauthenticated URL</a>, then return a <a>Promise</a>
              rejected with a <a>SecurityError</a>.
            </li>
            <li>If there is already an unsettled <a>Promise</a> from a previous
            call to <code>start</code> for the same <a>controlling browsing
            context</a>, return a <a>Promise</a> rejected with an
            <a>OperationError</a> exception and abort all remaining steps.
            </li>
            <li>Let <var>P</var> be a new <a>Promise</a>.
            </li>
            <li>Return <var>P</var>, but continue running these steps in
            parallel.
            </li>
            <li>If the <a>user agent</a> is not <a data-lt=
            "monitor the list of available presentation displays">monitoring
            the list of available presentation displays</a>, run the steps to
            <a>monitor the list of available presentation displays</a> <a>in
            parallel</a>.
            </li>
            <li>Request user permission for the use of a <a>presentation
            display</a> and selection of one presentation display.
            </li>
            <li>If either of the following is true:
              <ol>
                <li>The <a>list of available presentation displays</a> is empty
                and will remain so before the request for user permission is
                completed.
                </li>
                <li>No member in the <a>list of available presentation
                displays</a> is a <a>compatible presentation display</a> for
                <var>presentationUrl</var>.
                </li>
              </ol>Then run the following steps:
              <ol>
                <li>
                  <a>Reject</a> <var>P</var> with a <a>NotFoundError</a>
                  exception.
                </li>
                <li>Abort all remaining steps.
                </li>
              </ol>
            </li>
            <li>If the user <em>denied permission</em> to use a display, reject
            <var>P</var> with an <a>AbortError</a> exception, and abort all
            remaining steps.
            </li>
            <li>Otherwise, the user <em>granted permission</em> to use a
            display; let <var>D</var> be that display.
            </li>
            <li>Let <var>I</var> be a new <a>valid presentation identifier</a>
            unique among all <a>presentation identifiers</a> for known
            <a>presentation connections</a> in the <a>set of controlled
            presentations</a>.
            </li>
            <li>Create a new <a>PresentationConnection</a> <var>S</var>.
            </li>
            <li>Set the <a>presentation identifier</a> of <var>S</var> to <var>
              I</var>.
            </li>
            <li>Set the <a>presentation URL</a> of <var>S</var> to
            <var>presentationUrl</var>.
            </li>
            <li>Set the <a>presentation connection state</a> of <var>S</var> to
            <a for="PresentationConnectionState">connecting</a>.
            </li>
            <li>Add <var>S</var> to the <a>set of controlled presentations</a>.
            </li>
            <li>
              <a>Resolve</a> <var>P</var> with <var>S</var>.
            </li>
            <li>
              <a>Queue a task</a> to <a>fire</a> a <a>trusted event</a> with
              the name <a for="PresentationRequest">connectionavailable</a>,
              that uses the <a>PresentationConnectionAvailableEvent</a>
              interface, with the <a for=
              "PresentationConnectionAvailableEvent">connection</a> attribute
              initialized to <var>S</var>, at <var>presentationRequest</var>.
              The event must not bubble, must not be cancelable, and has no
              default action.
            </li>
            <li>If any of the following steps fails, abort all remaining steps
            and <a>close the presentation connection</a> <var>S</var> with
            <a for="PresentationConnectionClosedReason">error</a> as
            <var>closeReason</var>, and a human readable message describing the
            failure as <var>closeMessage</var>.
            </li>
            <li>
              <a>Create a receiving browsing context</a> on <var>D</var> and
              let <var>R</var> be the result.
            </li>
            <li>
              <a>Navigate</a> <var>R</var> to <var>presentationUrl</var>.
            </li>
            <li>
              <a>Establish a presentation connection</a> with <var>S</var>.
            </li>
          </ol>
          <div class="note">
            The details of implementing the permission request and display
            selection are left to the user agent; for example it may show the
            user a dialog and allow the user to select an available display
            (granting permission), or cancel the selection (denying
            permission). Implementers are encouraged to show the user whether
            an available display is currently in use, to facilitate
            presentations that can make use of multiple displays.
          </div>
          <div class="note">
            The <var>presentationUrl</var> should name a resource accessible to
            the local or a remote user agent. This specification defines
            behavior for <var>presentationUrl</var> using the <code>http</code>
            or <code>https</code> schemes; behavior for other schemes is not
            defined by this specification.
          </div>
        </section>
        <section>
          <h4>
            Reconnecting to a presentation
          </h4>
          <p>
            When the <code><dfn for=
            "PresentationRequest">reconnect</dfn>(presentationId)</code> method
            is called on a <code>PresentationRequest</code>
            <var>presentationRequest</var>, the <a>user agent</a> MUST run the
            following steps to <dfn>reconnect to a presentation</dfn>:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>presentationRequest</var>, the <a>PresentationRequest</a>
              object that <code><a for=
              "PresentationRequest">reconnect</a>()</code> was called on.
            </dd>
            <dd>
              <var>presentationId</var>, a <a>presentation identifier</a>
            </dd>
            <dt>
              Output
            </dt>
            <dd>
              <var>P</var>, a <a>Promise</a>
            </dd>
          </dl>
          <ol>
            <li>Let <var>P</var> be a new <a>Promise</a>.
            </li>
            <li>Using the document's <a>settings object</a>, run the
            <a>prohibits mixed security contexts algorithm</a>.
            </li>
            <li>If the result of the algorithm is <code>"Prohibits Mixed
            Security Contexts"</code> and the <a>presentation request URL</a>
            of <var>presentationRequest</var> is an <a>a priori unauthenticated
            URL</a>, then reject <var>P</var> with a <a>SecurityError</a>.
            </li>
            <li>Return <var>P</var>, but continue running these steps in
            parallel.
            </li>
            <li>Search the <a>set of controlled presentations</a> for a
            <a>PresentationConnection</a> that meets the following criteria:
            its <a>controlling browsing context</a> is the current <a>browsing
            context</a>, its <a>presentation connection state</a> is not
              <a for="PresentationConnectionState">terminated</a>, its
              <a>presentation URL</a> is equal to the <a>presentation request
              URL</a> of <var>presentationRequest</var>, and its
              <a>presentation identifier</a> is equal to
              <var>presentationId</var>.
            </li>
            <li>If such a <a>PresentationConnection</a> exists, run the
            following steps:
              <ol>
                <li>Let <var>S</var> be that <a>PresentationConnection</a>.
                </li>
                <li>
                  <a>Resolve</a> <var>P</var> with <var>S</var>.
                </li>
                <li>If the <a>presentation connection state</a> of <var>S</var>
                is <a for="PresentationConnectionState">connecting</a> or
                <a for="PresentationConnectionState">connected</a>, then abort
                all remaining steps.
                </li>
                <li>Set the <a>presentation connection state</a> of
                <var>S</var> to <a for=
                "PresentationConnectionState">connecting</a>.
                </li>
                <li>
                  <a>Establish a presentation connection</a> with <var>S</var>.
                </li>
                <li>Abort all remaining steps.
                </li>
              </ol>
            </li>
            <li>Search the <a>set of controlled presentations</a> for the first
            <a>PresentationConnection</a> that meets the following criteria:
            its <a>presentation connection state</a> is not <a for=
            "PresentationConnectionState">terminated</a>, its <a>presentation
            URL</a> is equal to the <a>presentation request URL</a> of
            <var>presentationRequest</var>, and its <a>presentation
            identifier</a> is equal to <var>presentationId</var>.
            </li>
            <li>If such a <a>PresentationConnection</a> exists, run the
            following steps:
              <ol>
                <li>Create a new <a>PresentationConnection</a> <var>S</var>.
                </li>
                <li>Set the <a>presentation identifier</a> of <var>S</var> to
                <var>presentationId</var>.
                </li>
                <li>Set the <a>presentation URL</a> of <var>S</var> to the <a>
                  presentation request URL</a> of
                  <var>presentationRequest</var>.
                </li>
                <li>Set the <a>presentation connection state</a> of
                <var>S</var> to <a for=
                "PresentationConnectionState">connecting</a>.
                </li>
                <li>Add <var>S</var> to the <a>set of controlled
                presentations</a>.
                </li>
                <li>
                  <a>Resolve</a> <var>P</var> with <var>S</var>.
                </li>
                <li>
                  <a>Queue a task</a> to <a>fire</a> a <a>trusted event</a>
                  with the name <a for=
                  "PresentationRequest">connectionavailable</a>, that uses the
                  <a>PresentationConnectionAvailableEvent</a> interface, with
                  the <a for=
                  "PresentationConnectionAvailableEvent">connection</a>
                  attribute initialized to <var>S</var>, at
                  <var>presentationRequest</var>. The event must not bubble,
                  must not be cancelable, and has no default action.
                </li>
                <li>
                  <a>Establish a presentation connection</a> with <var>S</var>.
                </li>
                <li>Abort all remaining steps.
                </li>
              </ol>
            </li>
            <li>
              <a>Reject</a> <var>P</var> with a <a>NotFoundError</a> exception.
            </li>
          </ol>
          <div class="issue">
            If no matching presentation is found, we could leave the Promise
            pending in case a matching presentation is started in the future.
          </div>
        </section>
        <section>
          <h4>
            Event Handlers
          </h4>
          <p>
            The following are the event handlers (and their corresponding event
            handler event types) that must be supported, as event handler IDL
            attributes, by objects implementing the <a>PresentationRequest</a>
            interface:
          </p>
          <table dfn-for="PresentationRequest">
            <thead>
              <tr>
                <th>
                  Event handler
                </th>
                <th>
                  Event handler event type
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <dfn><code>onconnectionavailable</code></dfn>
                </td>
                <td>
                  <dfn><code>connectionavailable</code></dfn>
                </td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section>
        <h3>
          Interface <code>PresentationAvailability</code>
        </h3>
        <pre class="idl">
          interface PresentationAvailability : EventTarget {
            readonly attribute boolean value;

            attribute EventHandler onchange;
          };

</pre>
        <p>
          A <a><code>PresentationAvailability</code></a> object is associated
          with available <a>presentation displays</a> and represents the
          <dfn>presentation display availability</dfn> for a presentation
          request. If the <a>controlling user agent</a> can <a>monitor the list
          of available presentation displays</a> in the background (without a
          pending request to <code><a for=
          "PresentationRequest">start</a>()</code>), the
          <a><code>PresentationAvailability</code></a> object MUST be
          implemented in a <a>controlling browsing context</a>.
        </p>
        <p>
          The <dfn for="PresentationAvailability">value</dfn> attribute MUST
          return the last value it was set to. The value is updated by the
          <a>monitor the list of available presentation displays</a> algorithm.
        </p>
        <p>
          The <dfn for="PresentationAvailability">onchange</dfn> attribute is
          an <a>event handler</a> whose corresponding <a>event handler event
          type</a> is <dfn><code>change</code></dfn>.
        </p>
        <section>
          <h4>
            The set of availability objects
          </h4>
          <p>
            The <a>user agent</a> MUST keep track of the <dfn>set of
            availability objects</dfn> requested through the <code><a for=
            "PresentationRequest">getAvailability</a>()</code> method. The
            <a>set of availability objects</a> is represented as a set of
            tuples <em>(<var>A</var>, <var>availabilityUrl</var>)</em>,
            initially empty, where:
          </p>
          <ol>
            <li>
              <var>A</var> is a live <a>PresentationAvailability</a> object;
            </li>
            <li>
              <var>availabilityUrl</var> is the parameter passed to
              <code><a for="PresentationRequest">getAvailability</a>()</code>
              to create <var>A</var>.
            </li>
          </ol>
        </section>
        <section>
          <h4>
            The list of available presentation displays
          </h4>
          <p>
            The <a>user agent</a> MUST keep a <dfn>list of available
            presentation displays</dfn>. This current list of <a>presentation
            displays</a> may be used for starting new presentations, and is
            populated based on an implementation specific discovery mechanism.
            It is set to the most recent result of the algorithm to <a>monitor
            the list of available presentation displays</a>.
          </p>
          <p>
            While there are live <a>PresentationAvailability</a> objects, the
            <a>user agent</a> MAY <a>monitor the list of available presentation
            displays</a> continuously, so that pages can use the <a for=
            "PresentationAvailability">value</a> property of a
            <a>PresentationAvailability</a> object to offer presentation only
            when there are available displays. However, the <a>user agent</a>
            may not support continuous availability monitoring; for example,
            because of platform or power consumption restrictions. In this case
            the <a>Promise</a> returned by <code><a for=
            "PresentationRequest">getAvailability</a>()</code> MUST be
            <a data-lt="reject">rejected</a> and the algorithm to <a>monitor
            the list of available presentation displays</a> will only run as
            part of the <a>start a presentation</a> algorithm.
          </p>
          <p>
            When there are no live <a>PresentationAvailability</a> objects
            (that is, the <a>set of availability objects</a> is empty), user
            agents SHOULD NOT <a>monitor the list of available presentation
            displays</a> to satisfy the <a href=
            "https://github.com/w3c/presentation-api/blob/gh-pages/uc-req.md#nf-req01-power-saving-friendly">
            power saving non-functional requirement</a>. To further save power,
            the <a>user agent</a> MAY also keep track of whether the page
            holding a <a>PresentationAvailability</a> object is in the
            foreground. Using this information, implementation specific
            discovery of <a>presentation displays</a> can be resumed or
            suspended.
          </p>
          <p>
            Some <a>presentation displays</a> may only be able to display a
            subset of Web content because of functional, security or hardware
            limitations. Examples are set-top boxes, smart TVs or networked
            speakers capable of rendering only audio. We say that such a
            display is a <dfn>compatible presentation display</dfn> for a
            <a>presentation request URL</a> if the <a>user agent</a> can
            reasonably guarantee that the presentation of the URL on that
            display will succeed.
          </p>
        </section>
        <section>
          <h4>
            Getting the <a>presentation displays</a> availability information
          </h4>
          <p>
            When the <code><dfn for=
            "PresentationRequest">getAvailability</dfn>()</code> method is
            called, the user agent MUST run the following steps:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>presentationUrl</var>, the <a>presentation request URL</a>
            </dd>
            <dt>
              Output
            </dt>
            <dd>
              <var>P</var>, a <a>Promise</a>
            </dd>
          </dl>
          <ol>
            <li>Let <var>P</var> be a new <a>Promise</a>.
            </li>
            <li>Return <var>P</var>, but continue running these steps <a>in
            parallel</a>.
            </li>
            <li>If the user agent is unable to <a>monitor the list of available
            presentation displays</a> for the entire duration of the
            <a>controlling browsing context</a> (e.g., because the user has
            disabled this feature), then:
              <ol>
                <li>
                  <a>Resolve</a> <var>P</var> with a new
                  <code>PresentationAvailability</code> object with its
                  <code>value</code> property set to <code>false</code>.
                </li>
                <li>Abort all the remaining steps.
                </li>
              </ol>
            </li>
            <li>If the user agent is unable to continuously <a>monitor the list
            of available presentation displays</a> but can find presentation
            displays in order to start a connection, then:
              <ol>
                <li>
                  <a>Reject</a> <var>P</var> with a <a>NotSupportedError</a>
                  exception.
                </li>
                <li>Abort all the remaining steps.
                </li>
              </ol>
            </li>
            <li>Let <var>A</var> be a new <code>PresentationAvailability</code>
            object with its <code>value</code> property set to
            <code>false</code> if the <a>list of available presentation
            displays</a> is empty or none of them is a <a>compatible
            presentation display</a>, <code>true</code> otherwise.
            </li>
            <li>Create a tuple <em>(<var>A</var>,
            <var>presentationUrl</var>)</em> and add it to the <a>set of
            availability objects</a>.
            </li>
            <li>Run the algorithm to <a>monitor the list of available
            presentation displays</a>.
            </li>
            <li>
              <a>Resolve</a> <var>P</var> with <var>A</var>.
            </li>
          </ol>
        </section>
        <section>
          <h4>
            Monitoring the list of available presentation displays
          </h4>
          <p>
            If the <a>set of availability objects</a> is non-empty, or there is
            a pending request to <a for="PresentationRequest" data-lt=
            "start">start a presentation</a>, the <a>user agent</a> MUST
            <dfn>monitor the list of available presentation displays</dfn> by
            running the following steps.
          </p>
          <ol link-for="PresentationAvailability">
            <li>Retrieve available presentation displays (using an
            implementation specific mechanism) and let <var>newDisplays</var>
            be this list.
            </li>
            <li>For each member <em>(<var>A</var>,
            <var>availabilityUrl</var>)</em> of the <a>set of availability
            objects</a>:
              <ol>
                <li>Set <var>previousAvailability</var> to the value of
                <var>A</var>'s <a>value</a> property.
                </li>
                <li>Let <var>newAvailability</var> be <code>true</code> if
                <var>newDisplays</var> is not empty and at least one display in
                <var>newDisplays</var> is a <a>compatible presentation
                display</a> for <var>availabilityUrl</var>. Otherwise, set
                <var>newAvailability</var> to <code>false</code>.
                </li>
                <li>If <var>previousAvailability</var> is not equal to
                <var>newAvailability</var>, then <a>queue a task</a> to run the
                following steps:
                  <ol>
                    <li>Set <var>A</var>'s <a>value</a> property to
                    <var>newAvailability</var>.
                    </li>
                    <li>
                      <a>Fire a simple event</a> named <a>change</a> at
                      <var>A</var>.
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>Set the <a>list of available presentation displays</a> to the
            value of <var>newDisplays</var>.
            </li>
          </ol>
          <p>
            When a <a>PresentationAvailability</a> object is no longer alive
            (i.e., is eligible for garbage collection), the <a>user agent</a>
            SHOULD run the following steps:
          </p>
          <ol>
            <li>Find and remove any entry <em>(<var>A</var>,
            <var>availabilityUrl</var>)</em> in the <a>set of availability
            objects</a> for the newly deceased <var>A</var>.
            </li>
            <li>If the <a>set of availability objects</a> is now empty and
            there is no pending request to <a for="PresentationRequest"
              data-lt="start">start a presentation</a>, cancel any pending task
              to <a>monitor the list of available presentation displays</a> for
              power saving purposes.
            </li>
          </ol>
          <div class="note">
            The mechanism used to monitor <a>presentation displays</a>
            availability and determine the compatibility of a <a>presentation
            display</a> with a given URL is left to the user agent.
          </div>
        </section>
        <section>
          <h4>
            Interface <code>PresentationConnectionAvailableEvent</code>
          </h4>
          <pre class="idl">
            [Constructor(DOMString type, PresentationConnectionAvailableEventInit eventInitDict)]
            interface PresentationConnectionAvailableEvent : Event {
              [SameObject] readonly attribute PresentationConnection connection;
            };

            dictionary PresentationConnectionAvailableEventInit : EventInit {
              required PresentationConnection connection;
            };


</pre>
          <p>
            A <a>controlling user agent</a> <a>fires</a> a <a>trusted event</a>
            named <a for="PresentationRequest">connectionavailable</a> on a
            <a>PresentationRequest</a> when a connection associated with the
            object is created. It is fired at the <a>PresentationRequest</a>
            instance, using the <a>PresentationConnectionAvailableEvent</a>
            interface, with the <a for=
            "PresentationConnectionAvailableEvent">connection</a> attribute set
            to the <a><code>PresentationConnection</code></a> object that was
            created. The event is fired for each connection that is created for
            the <a>controller</a>, either by the <a>controller</a> calling
            <code>start()</code> or <code>reconnect()</code>, or by the
            <a>controlling user agent</a> creating a connection on the
            controller's behalf via <a for=
            "Presentation"><code>defaultRequest</code></a>.
          </p>
          <p>
            A <a>receiving user agent</a> <a>fires</a> a <a>trusted event</a>
            named <a for="PresentationConnectionList">connectionavailable</a>
            on a <a>PresentationReceiver</a> when an incoming connection is
            created. It is fired at the <a>PresentationConnectionList</a>
            instance associated with the <a>PresentationReceiver</a> instance,
            using the <a>PresentationConnectionAvailableEvent</a> interface,
            with the <a for=
            "PresentationConnectionAvailableEvent">connection</a> attribute set
            to the <a><code>PresentationConnection</code></a> object that was
            created. The event is fired for all connections that are created
            when <a>monitoring incoming presentation connections</a>.
          </p>
        </section>
      </section>
      <section>
        <h3>
          Interface <code>PresentationConnection</code>
        </h3>
        <p>
          Each <a>presentation connection</a> is represented by a
          <a>PresentationConnection</a> object. Both the <a>controlling user
          agent</a> and <a>receiving user agent</a> MUST implement
          <a>PresentationConnection</a>.
        </p>
        <pre class="idl">
          enum PresentationConnectionState { "connecting", "connected", "closed", "terminated" };
          enum BinaryType { "blob", "arraybuffer" };

          interface PresentationConnection : EventTarget {
            readonly attribute DOMString? id;
            readonly attribute PresentationConnectionState state;
            void close();
            void terminate();
            attribute EventHandler onconnect;
            attribute EventHandler onclose;
            attribute EventHandler onterminate;

            // Communication
            attribute BinaryType binaryType;
            attribute EventHandler onmessage;
            void send (DOMString message);
            void send (Blob data);
            void send (ArrayBuffer data);
            void send (ArrayBufferView data);
          };

</pre>
        <div dfn-for="PresentationConnection" link-for=
        "PresentationConnection">
          <p>
            The <dfn><code>id</code></dfn> attribute specifies the
            <a>presentation connection</a>'s <a>presentation identifier</a>.
          </p>
          <p>
            The <dfn><code>state</code></dfn> attribute represents the
            <a>presentation connection</a>'s current state. It can take one of
            the values of <a>PresentationConnectionState</a> depending on the
            connection state:
          </p>
          <ul dfn-for="PresentationConnectionState">
            <li>
              <dfn>connecting</dfn> means that the user agent is attempting to
              <a>establish a presentation connection</a> with the
              <a>destination browsing context</a>. This is the initial state
              when a <a>PresentationConnection</a> object is created.
            </li>
            <li>
              <dfn>connected</dfn> means that the <a>presentation
              connection</a> is established and communication is possible.
            </li>
            <li>
              <dfn>closed</dfn> means that the <a>presentation connection</a>
              has been closed, or could not be opened. It may be re-opened
              through a call to <code><a for=
              "PresentationRequest">reconnect</a>()</code>. No communication is
              possible.
            </li>
            <li>
              <dfn>terminated</dfn> means that the <a>receiving browsing
              context</a> has been terminated. Any <a>presentation
              connection</a> to that <a>presentation</a> is also terminated and
              cannot be re-opened. No communication is possible.
            </li>
          </ul>
          <p>
            When the <code><dfn>close</dfn>()</code> method is called on a
            <a>PresentationConnection</a> <var>S</var>, the <a>user agent</a>
            MUST <a>start closing the presentation connection</a> <var>S</var>
            with <a for="PresentationConnectionClosedReason">closed</a> as
            <var>closeReason</var> and an empty message as
            <var>closeMessage</var>.
          </p>
          <p>
            When the <code><dfn>terminate</dfn>()</code> method is called on a
            <a>PresentationConnection</a> <var>S</var> in a <a>controlling
            browsing context</a>, the <a>user agent</a> MUST run the algorithm
            to <a>terminate a presentation in a controlling browsing
            context</a> using <var>S</var>.
          </p>
          <p>
            When the <code>terminate()</code> method is called on a
            <a>PresentationConnection</a> <var>S</var> in a <a>receiving
            browsing context</a>, the <a>user agent</a> MUST run the algorithm
            to <a>terminate a presentation in a controlling browsing
            context</a> using <var>S</var>.
          </p>
          <p>
            When a <a>PresentationConnection</a> object is created, its
            <a>binaryType</a> IDL attribute MUST be set to the string
            "<a link-for="BinaryType">arraybuffer</a>". On getting, it MUST
            return the last value it was set to. On setting, the user agent
            MUST set the IDL attribute to the new value.
          </p>
          <div class="note">
            The <a>binaryType</a> attribute allows authors to control how
            binary data is exposed to scripts. By setting the attribute to
            "<dfn dfn-for="BinaryType">blob</dfn>", binary data is returned in
            <code>Blob</code> form; by setting it to "<dfn dfn-for=
            "BinaryType">arraybuffer</dfn>", it is returned in
            <code>ArrayBuffer</code> form. The attribute defaults to
            "<code>arraybuffer</code>". This attribute has no effect on data
            sent in a string form.
          </div>
          <p>
            When the <code><dfn>send</dfn>()</code> method is called on a
            <a>PresentationConnection</a> <var>S</var>, the <a>user agent</a>
            MUST run the algorithm to <a>send a message</a> through
            <var>S</var>.
          </p>
          <p>
            When a <a>PresentationConnection</a> object <var>S</var> is
            discarded (because the document owning it is navigating or is
            closed) while the <a>presentation connection state</a> of
            <var>S</var> is <a for="PresentationConnectionState">connecting</a>
            or <a for="PresentationConnectionState">connected</a>, the <a>user
            agent</a> SHOULD <a>start closing the presentation connection</a>
            <var>S</var> with <a for=
            "PresentationConnectionClosedReason">wentaway</a> as
            <var>closeReason</var> and an empty <var>closeMessage</var>.
          </p>
          <p>
            If the <a>user agent</a> receives a signal from the <a>destination
            browsing context</a> that a <a>PresentationConnection</a>
            <var>S</var> is to be closed, it SHOULD <a>close the presentation
            connection</a> <var>S</var> with <a for=
            "PresentationConnectionClosedReason">closed</a> or <a for=
            "PresentationConnectionClosedReason">wentaway</a> as
            <var>closeReason</var> and an empty <var>closeMessage</var>.
          </p>
        </div>
        <section>
          <h4>
            Establishing a presentation connection
          </h4>
          <p>
            When the <a>user agent</a> is to <dfn>establish a presentation
            connection</dfn> using a <a>presentation connection</a>, it MUST
            run the following steps:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>presentationConnection</var>, the
              <code>PresentationConnection</code> object that is to be
              connected. The <a>presentation connection state</a> of
              <var>presentationConnection</var> must be <a for=
              "PresentationConnectionState">connecting</a>.
            </dd>
          </dl>
          <ol>
            <li>Connect <var>presentationConnection</var> to the <a>receiving
            browsing context</a>.
            </li>
            <li>If connection completes successfully, <a>queue a task</a> to
            run the following steps:
              <ol>
                <li>Set the <a>presentation connection state</a> of
                <var>presentationConnection</var> to <a for=
                "PresentationConnectionState">connected</a>.
                </li>
                <li>
                  <a>Fire a simple event</a> named <a class=
                  "PresentationConnectionEvent">connect</a> at
                  <var>presentationConnection</var>.
                </li>
              </ol>
            </li>
          </ol>
          <div class="note">
            The mechanism that is used to present on the remote display and
            connect the <a>controlling browsing context</a> with the presented
            document is an implementation choice of the user agent. The
            connection must provide a two-way messaging abstraction capable of
            carrying <code>DOMString</code> payloads in a reliable and in-order
            fashion as described in the <a>Send a Message</a> and <a>Receive a
            Message</a> steps below.
          </div>
          <div class="note">
            If the connection step does not complete successfully, the user
            agent may choose to re-execute the Presentation Connection
            algorithm at a later time.
          </div>
        </section>
        <section>
          <h4>
            Sending a message through <code>PresentationConnection</code>
          </h4>
          <div class="note">
            No specific transport for the connection between the <a>controlling
            browsing context</a> and the <a>receiving browsing context</a> is
            mandated, except that for multiple calls to <code><a for=
            "PresentationConnection">send</a>()</code> it has to be ensured
            that messages are delivered to the other end reliably and in
            sequence. The transport should function equivalently to an
            <a><code>RTCDataChannel</code></a> in reliable mode.
          </div>
          <p>
            Let <dfn>presentation message data</dfn> be the payload data to be
            transmitted between two browsing contexts. Let <dfn>presentation
            message type</dfn> be the type of that data, one of
            <code>text</code> or <code>binary</code>.
          </p>
          <p>
            When the <a>user agent</a> is to <dfn data-lt="send-algorithm">send
            a message</dfn> through a <a>presentation connection</a>, it MUST
            run the following steps:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>presentationConnection</var>, the <a>presentation
              connection</a> connected to the other browsing context
            </dd>
            <dd>
              <var>messageOrData</var>, the <a>presentation message data</a> to
              send to the other browsing context
            </dd>
          </dl>
          <ol link-for="PresentationConnection">
            <li>If the <a>state</a> property of
            <var>presentationConnection</var> is not <a for=
            "PresentationConnectionState">connected</a>, throw an
            <code>InvalidStateError</code> exception.
            </li>
            <li>If the <a>closing procedure</a> of
            <var>presentationConnection</var> has started, then abort these
            steps.
            </li>
            <li>Let <a>presentation message type</a> <var>messageType</var> be
            <code>binary</code> if <var>messageOrData</var> is of type
            <code>ArrayBuffer</code>, <code>ArrayBufferView</code>, or
            <code>Blob</code>. Let <var>messageType</var> be <code>text</code>
            if <var>messageOrData</var> is of type <code>DOMString</code>.
            </li>
            <li>Using an implementation specific mechanism, transmit the
            contents of <var>messageOrData</var> as the <a>presentation message
            data</a> and <var>messageType</var> as the <a>presentation message
            type</a> to the <a>destination browsing context</a>.
            </li>
            <li>If the previous step encounters an unrecoverable error, then
            abruptly <a>close the presentation connection</a>
            <var>presentationConnection</var> with <a for=
            "PresentationConnectionClosedReason">error</a> as
            <var>closeReason</var>, and a <var>closeMessage</var> describing
            the error encountered.
            </li>
          </ol>
          <div class="note">
            <p>
              To assist applications in recovery from an error sending a
              message through a <a>presentation connection</a>, the user agent
              should include details of which attempt failed in
              <var>closeMessage</var>. Example renditions of
              <var>closeMessage</var>:
            </p>
            <ul>
              <li>
                <code>Unable to send message: "hello"</code> for
                <code>DOMString</code> messages, where <code>"hello"</code> is
                the first 256 characters of the failed message.
              </li>
              <li>
                <code>Unable to send binary message</code> for
                <code>ArrayBuffer</code>, <code>ArrayBufferView</code> and
                <code>Blob</code> messages.
              </li>
            </ul>
          </div>
        </section>
        <section>
          <h4>
            Receiving a message through <code>PresentationConnection</code>
          </h4>
          <p>
            When the <a>user agent</a> has received a transmission from the
            remote side consisting of <a>presentation message data</a> and
            <a>presentation message type</a>, it MUST run the following steps
            to <dfn data-lt="receive-algorithm">receive a message</dfn> through
            a <code>PresentationConnection</code>:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>presentationConnection</var>, the <a>presentation
              connection</a> receiving the message
            </dd>
            <dd>
              <var>messageType</var>, the <a>presentation message type</a> of
              the message
            </dd>
            <dd>
              <var>messageData</var>, the <a>presentation message data</a> of
              the message
            </dd>
          </dl>
          <ol link-for="PresentationConnection">
            <li>If the <a>state</a> property of
            <var>presentationConnection</var> is not <a for=
            "PresentationConnectionState">connected</a>, abort these steps.
            </li>
            <li>Let <var>event</var> be a newly created <a>trusted event</a>
            that uses the <code>MessageEvent</code> interface, with the event
            type <a>message</a>, which does not bubble, is not cancelable, and
            has no default action.
            </li>
            <li>Initialize the <var>event</var>'s data attribute as follows:
              <ol>
                <li>If <var>messageType</var> is <code>text</code>, then
                initialize <var>event</var>'s <code>data</code> attribute to
                <var>messageData</var> with type <code>DOMString</code>.
                </li>
                <li>If <var>messageType</var> is <code>binary</code>, and
                <a>binaryType</a> attribute is set to "<a link-for=
                "BinaryType">blob</a>", then initialize <var>event</var>'s
                <code>data</code> attribute to a new <code>Blob</code> object
                with <var>messageData</var> as its raw data.
                </li>
                <li>If <var>messageType</var> is <code>binary</code>, and
                <a>binaryType</a> attribute is set to "<a link-for=
                "BinaryType">arraybuffer</a>", then initialize
                <var>event</var>'s <code>data</code> attribute to a new <code>
                  ArrayBuffer</code> object whose contents are
                  <var>messageData</var>.
                </li>
              </ol>
            </li>
            <li>
              <a>Queue a task</a> to <a>fire</a> <var>event</var> at
              <var>presentationConnection</var>.
            </li>
          </ol>
          <p>
            If the <a>user agent</a> encounters an unrecoverable error while
            <a data-lt="receive-algorithm">receiving a message</a> through
            <var>presentationConnection</var>, it SHOULD abruptly <a>close the
            presentation connection</a> <var>presentationConnection</var> with
            <a for="PresentationConnectionClosedReason">error</a> as
            <var>closeReason</var>, and a human readable description of the
            error encountered as <var>closeMessage</var>.
          </p>
        </section>
        <section>
          <h4>
            Interface <code>PresentationConnectionClosedEvent</code>
          </h4>
          <pre class="idl">
            enum PresentationConnectionClosedReason { "error", "closed", "wentaway" };

            [Constructor(DOMString type, PresentationConnectionClosedEventInit eventInitDict)]
            interface PresentationConnectionClosedEvent : Event {
              readonly attribute PresentationConnectionClosedReason reason;
              readonly attribute DOMString message;
            };

            dictionary PresentationConnectionClosedEventInit : EventInit {
              required PresentationConnectionClosedReason reason;
              DOMString message;
            };


</pre>
          <p>
            A <code>PresentationConnectionClosedEvent</code> is fired when a
            <a>presentation connection</a> enters a <a for=
            "PresentationConnectionState">closed</a> state. The
            <code>reason</code> attribute provides the reason why the
            connection was closed:
          </p>
          <ul dfn-for="PresentationConnectionClosedReason">
            <li>
              <dfn>error</dfn> means that the mechanism for connecting or
              communicating with a presentation entered an unrecoverable error.
            </li>
            <li>
              <dfn>closed</dfn> means that either the <a>controlling browsing
              context</a> or the <a>receiving browsing context</a> that were
              connected by the <code>PresentationConnection</code> called
              <code>close()</code>.
            </li>
            <li>
              <dfn>wentaway</dfn> means that the browser closed the connection,
              for example, because the browsing context that owned the
              connection navigated or was discarded.
            </li>
          </ul>
          <p>
            When the <code>reason</code> attribute is <a for=
            "PresentationConnectionClosedReason">error</a>, the user agent
            SHOULD set the error message to a human readable description of how
            the communication channel encountered an error.
          </p>
        </section>
        <section>
          <h4>
            Closing a <code>PresentationConnection</code>
          </h4>
          <p>
            When the <a>user agent</a> is to <dfn data-lt=
            "start closing the presentation connection|closing procedure">start
            closing a presentation connection</dfn>, it MUST do the following:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>presentationConnection</var>, the <a>presentation
              connection</a> to be closed
            </dd>
            <dd>
              <var>closeReason</var>, the
              <a>PresentationConnectionClosedReason</a> describing why the
              connection is to be closed
            </dd>
            <dd>
              <var>closeMessage</var>, a human-readable message with details of
              why the connection was closed.
            </dd>
          </dl>
          <ol>
            <li>If the <a>presentation connection state</a> of
            <var>presentationConnection</var> is not <a for=
            "PresentationConnectionState">connecting</a> or <a for=
            "PresentationConnectionState">connected</a> then abort the
            remaining steps.
            </li>
            <li>Set the <a>presentation connection state</a> of
            <var>presentationConnection</var> to <a for=
            "PresentationConnectionState">closed</a>.
            </li>
            <li>Start to signal to the <a>destination browsing context</a> the
            intention to close the corresponding
            <code>PresentationConnection</code>, passing the
            <var>closeReason</var> to that context. The user agent does not
            need to wait for acknowledgement that the corresponding
            <code>PresentationConnection</code> was actually closed before
            proceeding to the next step.
            </li>
            <li>If <var>closeReason</var> is not <a for=
            "PresentationConnectionClosedReason">wentaway</a>, then locally run
            the steps to <a>close the presentation connection</a> with
            <var>presentationConnection</var>, <var>closeReason</var>, and
            <var>closeMessage</var>.
            </li>
          </ol>
          <p>
            When the <a>user agent</a> is to <dfn data-lt=
            "close the presentation connection">close a presentation
            connection</dfn>, it MUST do the following:
          </p>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>presentationConnection</var>, the <a>presentation
              connection</a> to be closed
            </dd>
            <dd>
              <var>closeReason</var>, the
              <a>PresentationConnectionClosedReason</a> describing why the
              connection is to be closed
            </dd>
            <dd>
              <var>closeMessage</var>, a human-readable message with details of
              why the connection was closed.
            </dd>
          </dl>
          <ol>
            <li>If there is a pending <a>close the presentation connection</a>
            task for <var>presentationConnection</var>, or a <a>close the
            presentation connection</a> task has already run for
            <var>presentationConnection</var>, then abort the remaining steps.
            </li>
            <li>
              <a>Queue a task</a> to run the following steps:
              <ol>
                <li>If the <a>presentation connection state</a> of
                <var>presentationConnection</var> is not <a for=
                "PresentationConnectionState">connecting</a>, <a for=
                "PresentationConnectionState">connected</a>, or <a for=
                "PresentationConnectionState">closed</a>, then abort the
                remaining steps.
                </li>
                <li>If the <a>presentation connection state</a> of
                <var>presentationConnection</var> is not <a for=
                "PresentationConnectionState">closed</a>, set it to <a for=
                "PresentationConnectionState">closed</a>.
                </li>
                <li>
                  <a>Fire</a> a <a>trusted event</a> with the name <a for=
                  "PresentationConnectionEvent">close</a>, that uses the
                  <a>PresentationConnectionClosedEvent</a> interface, with the
                  <a for="PresentationConnectionClosedEvent">reason</a>
                  attribute initialized to <var>closeReason</var> and the
                  <a for="PresentationConnectionClosedEvent">message</a>
                  attribute initialized to <var>closeMessage</var>, at
                  <var>presentationConnection</var>. The event must not bubble,
                  must not be cancelable, and has no default action.
                </li>
              </ol>
            </li>
          </ol>
          <div class="issue" data-number="240">
            Refine this procedure to specify handling of messages in-flight
            when the connection is being closed.
          </div>
        </section>
        <section>
          <h4>
            Terminating a presentation in a controlling browsing context
          </h4>
          <p>
            When a <a>controlling user agent</a> is to <dfn data-lt=
            "terminate-algorithm-controlling">terminate a presentation in a
            controlling browsing context</dfn> using <var>connection</var>, it
            MUST run the following steps:
          </p>
          <ol>
            <li>If the <a>presentation connection state</a> of
            <var>connection</var> is not <a for="PresentationConnectionState">
              connected</a>, then abort these steps.
            </li>
            <li>Otherwise, for each <var>known connection</var> in the <a>set
            of controlled presentations</a> in the <a>controlling user
            agent</a>:
              <ol>
                <li>If the <a>presentation identifier</a> of <var>known
                connection</var> and <var>connection</var> are equal, and the
                <a>presentation connection state</a> of <var>known
                connection</var> is <a for=
                "PresentationConnectionState">connected</a>, then <a>queue a
                task</a> to run the following steps:
                  <ol>
                    <li>Set the <a>presentation connection state</a> of
                    <var>known connection</var> to <a for=
                    "PresentationConnectionState">terminated</a>.
                    </li>
                    <li>
                      <a>Fire a simple event</a> named <a for=
                      "PresentationConnectionEvent">terminate</a> at <var>known
                      connection</var>.
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>
              <dfn>Send a termination request</dfn> for the presentation to its
              <a>receiving user agent</a> using an implementation specific
              mechanism.
            </li>
          </ol>
        </section>
        <section>
          <h4>
            Terminating a presentation in a receiving browsing context
          </h4>
          <p>
            When any of the following occur, the <a>receiving user agent</a>
            MUST <a>terminate a presentation in a receiving browsing
            context</a>:
          </p>
          <ol>
            <li>The <a>receiving user agent</a> is to <a>unload a document</a>
            corresponding to the <a>receiving browsing context</a>, e.g. in
            response to a call to <code>window.close()</code> in the
            <a>top-level browsing context</a> or to a request to
            <a>navigate</a> that context to a new resource.
            </li>
            <li>The user requests to terminate the presentation via the
            <a>receiving user agent</a>.
              <p class="note">
                This could happen by an explicit user action, or as a policy of
                the user agent. For example, the <a>receiving user agent</a>
                could be configured to terminate presentations that have no
                <a>PresentationConnection</a> objects whose <a>presentation
                connection state</a> is in the <a link-for=
                "PresentationConnectionState">connected</a> state after 30
                minutes.
              </p>
            </li>
            <li>A <a>controlling user agent</a> <a data-lt=
            "send a termination request">sends a termination request</a> to the
            <a>receiving user agent</a> for that presentation.
            </li>
          </ol>
          <p>
            When a <a>receiving user agent</a> is to <dfn data-lt=
            "terminate-algorithm-receiving">terminate a presentation in a
            receiving browsing context</dfn>, it MUST run the following steps:
          </p>
          <ol>
            <li>Let <var>P</var> be the presentation to be terminated.
            </li>
            <li>If there is a <a>receiving browsing context</a> for
            <var>P</var>, and it has a document for <var>P</var> that is not
            unloaded, <a>unload a document</a> corresponding to that
            <a>browsing context</a>.
            </li>
            <li>For each <var>connection</var> in the <a>set of presentation
            controllers</a> that were created for <var>P</var>, <a>queue a
            task</a> to run the following steps:
              <ol>
                <li>If the <a>presentation connection state</a> of
                <var>connection</var> is not <a for=
                "PresentationConnectionState">connected</a>, then abort the
                following steps.
                </li>
                <li>
                  <a>Send a termination confirmation</a> for <var>P</var> using
                  an implementation specific mechanism to the <a>controlling
                  user agent</a> that owns the <a>destination browsing
                  context</a> for <var>connection</var>.
                  <p class="note">
                    Only one termination confirmation needs to be sent per
                    <a>controlling user agent</a>.
                  </p>
                </li>
              </ol>
            </li>
          </ol>
        </section>
        <section>
          <h4>
            Handling a termination confirmation in a controlling user agent
          </h4>
          <p>
            When a <a>receiving user agent</a> is to <dfn>send a termination
            confirmation</dfn> for a presentation <var>P</var>, and that
            confirmation was received by a <a>controlling user agent</a>, the
            <a>controlling user agent</a> SHOULD run the following steps:
          </p>
          <ol>
            <li>For each <var>connection</var> in the <a>set of controlled
            presentations</a> that was connected to <var>P</var>, <a>queue a
            task</a> to run the following steps:
              <ol>
                <li>If the <a>presentation connection state</a> of
                <var>connection</var> is not <a for=
                "PresentationConnectionState">connected</a>, then abort the
                following steps.
                </li>
                <li>Set the <a>presentation connection state</a> of
                <var>connection</var> to <a for="PresentationConnectionState">
                  terminated</a>.
                </li>
                <li>
                  <a>Fire a simple event</a> named <a for=
                  "PresentationConnectionEvent">terminate</a> at
                  <var>connection</var>.
                </li>
              </ol>
            </li>
          </ol>
        </section>
        <section>
          <h4>
            Event Handlers
          </h4>
          <p>
            The following are the event handlers (and their corresponding event
            handler event types) that must be supported, as event handler IDL
            attributes, by objects implementing the
            <a>PresentationConnection</a> interface:
          </p>
          <table dfn-for="PresentationConnection">
            <thead>
              <tr>
                <th>
                  Event handler
                </th>
                <th>
                  Event handler event type
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <dfn><code>onmessage</code></dfn>
                </td>
                <td>
                  <dfn><code>message</code></dfn>
                </td>
              </tr>
              <tr>
                <td>
                  <dfn><code>onconnect</code></dfn>
                </td>
                <td>
                  <dfn><code>connect</code></dfn>
                </td>
              </tr>
              <tr>
                <td>
                  <dfn><code>onclose</code></dfn>
                </td>
                <td>
                  <dfn for=
                  "PresentationConnectionEvent"><code>close</code></dfn>
                </td>
              </tr>
              <tr>
                <td>
                  <dfn><code>onterminate</code></dfn>
                </td>
                <td>
                  <dfn for=
                  "PresentationConnectionEvent"><code>terminate</code></dfn>
                </td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section>
        <h3>
          Interface <a><code>PresentationReceiver</code></a>
        </h3>
        <pre class="idl">
          interface PresentationReceiver {
            [SameObject] readonly attribute Promise&lt;PresentationConnectionList&gt; connectionList;
          };


</pre>
        <p>
          The <a>PresentationReceiver</a> interface allows a <a>receiving
          browsing context</a> to access the <a data-lt=
          "controlling browsing context">controlling browsing contexts</a> and
          communicate with them. The <a>PresentationReceiver</a> interface MUST
          be implemented in a <a>receiving browsing context</a> provided by a
          <a>receiving user agent</a>.
        </p>
        <p>
          On getting, the <dfn for="PresentationReceiver">connectionList</dfn>
          attribute MUST return the result of running the following steps:
        </p>
        <ol>
          <li>If there is already an unsettled <a>Promise</a> <var>P</var> from
          a previous call to get the <a for=
          "PresentationReceiver">connectionList</a> attribute for the same <a>
            PresentationReceiver</a> object, return <var>P</var> and abort all
            remaining steps.
          </li>
          <li>Let <var>P</var> be a new <a>Promise</a>.
          </li>
          <li>Return <var>P</var>, but continue running these steps <a>in
          parallel</a>.
          </li>
          <li>Let <var>list</var> be a new <a>PresentationConnectionList</a>.
          </li>
          <li>Resolve <var>P</var> with <var>list</var>.
          </li>
          <li>If the <a>user agent</a> is not <a>monitoring incoming
          presentation connections</a>, start <a>monitoring incoming
          presentation connections</a> from <a>controlling browsing
          contexts</a>.
          </li>
        </ol>
        <section>
          <h4>
            Creating a receiving browsing context
          </h4>
          <dl>
            <dt>
              Input
            </dt>
            <dd>
              <var>D</var>, a <a>presentation display</a> chosen by the user
            </dd>
            <dt>
              Output
            </dt>
            <dd>
              <var>R</var>, a <a>receiving browsing context</a>
            </dd>
          </dl>
          <p>
            When the <a>user agent</a> is to <dfn>create a receiving browsing
            context</dfn>, it MUST run the following steps:
          </p>
          <ol>
            <li>Create a new <a>top-level browsing context</a> <var>C</var> on
            the user agent connected to <var>D</var>.
            </li>
            <li>Set the <a>session history</a> of <var>C</var> to be the empty
            list.
            </li>
            <li>Set the <a>sandboxed auxiliary navigation browsing context
            flag</a> on <var>C</var>.
            </li>
            <li>Set the <a><code>sessionStorage</code></a> attribute for the
            <code>Window</code> object associated with <var>C</var> to a new,
            empty storage area.
            </li>
            <li>Set the <a><code>localStorage</code></a> attribute for the
            <code>Window</code> object associated with <var>C</var> to a new,
            empty storage area.
            </li>
            <li>Set the <a>cookie store</a> for <var>C</var> to an empty
            <a>cookie store</a>.
            </li>
            <li>Set the <a>permission state</a> of all <a>Permissions</a> for
            <var>C</var> to <code>"denied"</code>.
            </li>
            <li>Set the IndexedDB <a>databases</a> for <var>C</var> to an empty
            set of <a>databases</a>.
            </li>
            <li>Return <var>C</var>.
            </li>
          </ol>
          <p>
            When the <a>receiving browsing context</a> is closed, any
            associated browsing state, including <a>session history</a>,
            <a><code>sessionStorage</code></a>,
            <a><code>localStorage</code></a>, the <a>cookie store</a>, and
            <a>databases</a> MUST be discarded and not used for any other
            <a>receiving browsing context</a>.
          </p>
        </section>
      </section>
      <section>
        <h3>
          Interface <a><code>PresentationConnectionList</code></a>
        </h3>
        <pre class="idl">
          interface PresentationConnectionList : EventTarget {
            readonly attribute FrozenArray&lt;PresentationConnection&gt; connections;
            attribute EventHandler onconnectionavailable;
          };


</pre>
        <p>
          The <dfn for="PresentationConnectionList">connections</dfn> attribute
          MUST return the non-terminated set of <a>presentation connections</a>
          in the <a>set of presentation controllers</a>.
        </p>
        <section>
          <h4>
            Monitoring incoming presentation connections
          </h4>
          <p>
            When the <a>receiving user agent</a> is to start <dfn>monitoring
            incoming presentation connections</dfn> in a <a>receiving browsing
            context</a> from <a>controlling browsing contexts</a>, it MUST
            listen to and accept incoming connection requests from a
            <a>controlling browsing context</a> using an implementation
            specific mechanism. When a new connection request is received from
            a <a>controlling browsing context</a>, the <a>receiving user
            agent</a> MUST run the following steps:
          </p>
          <ol>
            <li>Let <var>I</var> be the <a>presentation identifier</a> sent by
            the <a>controlling browsing context</a> in the incoming request.
            </li>
            <li>Create a new <a>PresentationConnection</a> <var>S</var>.
            </li>
            <li>Set the <a>presentation identifier</a> of <var>S</var> to <var>
              I</var>.
            </li>
            <li>Establish the connection between the controlling and
            <a>receiving browsing contexts</a> using an implementation specific
            mechanism.
            </li>
            <li>Set the <a>presentation connection state</a> of <var>S</var> to
            <a for="PresentationConnectionState">connected</a>.
            </li>
            <li>Add <var>S</var> to the <a>set of presentation controllers</a>.
            </li>
            <li>
              <a>Queue a task</a> to <a>fire</a> a <a>trusted event</a> with
              the name <a for=
              "PresentationConnectionList">connectionavailable</a>, that uses
              the <a>PresentationConnectionAvailableEvent</a> interface, with
              the <a for="PresentationConnectionAvailableEvent">connection</a>
              attribute initialized to <var>S</var>, at the
              <a>PresentationConnectionList</a> instance associated with the
              <a>PresentationReceiver</a> object. The event must not bubble,
              must not be cancelable, and has no default action.
            </li>
          </ol>
          <p>
            The <a>receiving user agent</a> MUST fire the event as soon as it
            can create the <a><code>PresentationConnection</code></a>
            associated with the event.
          </p>
        </section>
        <section>
          <h4>
            Event Handlers
          </h4>
          <p>
            The following are the event handlers (and their corresponding event
            handler event types) that must be supported, as event handler IDL
            attributes, by objects implementing the
            <a>PresentationConnectionList</a> interface:
          </p>
          <table dfn-for="PresentationConnectionList">
            <thead>
              <tr>
                <th>
                  Event handler
                </th>
                <th>
                  Event handler event type
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <dfn><code>onconnectionavailable</code></dfn>
                </td>
                <td>
                  <code>connectionavailable</code>
                </td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section>
        <h3>
          Sandboxing and the <code>allow-presentation</code> keyword
        </h3>
        <p>
          This specification adds a new token, <code>allow-presentation</code>,
          to the set of tokens allowed in the <code>sandbox</code> attribute of
          an <code>iframe</code>. It adds a corresponding new flag to the
          <a>sandboxing flag set</a>:
        </p>
        <dl>
          <dt>
            The <dfn id=
            "sandboxed-presentation-browsing-context-flag">sandboxed
            presentation browsing context flag</dfn>
          </dt>
          <dd>
            This flag disables the Presentation API.
          </dd>
        </dl>
        <p>
          It amends the <a>parse a sandboxing directive</a> algorithm by adding
          an item to step 3:
        </p>
        <ul>
          <li>The <a>sandboxed presentation browsing context flag</a>, unless
          <var>tokens</var> contains the <dfn id=
          "attr-iframe-sandbox-allow-presentation"><code>allow-presentation</code></dfn>
          keyword.
          </li>
        </ul>
        <p>
          <dfn>Presentation is disabled</dfn> in a browsing context when the
          document object's <a>active sandboxing flag set</a> does not have the
          <a>sandboxed presentation browsing context flag</a> set.
        </p>
        <div class="note">
          A <a>nested browsing context</a> created by an <code>iframe</code>
          with its <code>sandbox</code> attribute set will act as if
          <a>presentation is disabled</a>, unless that attribute includes the
          <code>allow-presentation</code> keyword. This allows pages to embed
          potentially untrustworthy content and deny it the ability to request
          presentation from the user or query for screen availability.
        </div>
      </section>
    </section>
    <section>
      <h2>
        Security and privacy considerations
      </h2>
      <h3>
        Personally identifiable information
      </h3>
      <p>
        The <code>change</code> event fired on the
        <a>PresentationAvailability</a> object reveals one bit of information
        about the presence (or non-presence) of a <a>presentation display</a>
        typically discovered through the local area network. This could be used
        in conjunction with other information for fingerprinting the user.
        However, this information is also dependent on the user's local network
        context, so the risk is minimized.
      </p>
      <p>
        The API enables <a href=
        "#monitoring-the-list-of-available-presentation-displays">monitoring
        the list of available presentation displays</a>. How the user agent
        determines the compatibility and availability of a <a>presentation
        display</a> with a given URL is an implementation detail. If a
        <a>controlling user agent</a> matches a <a>presentation request URL</a>
        to a <a>DIAL</a> application to determine its availability, this
        feature can be used to probe information about which <a>DIAL</a>
        applications the user has installed on the <a>presentation display</a>
        without user consent.
      </p>
      <h3>
        Cross-origin access
      </h3>
      <p>
        A <a>presentation</a> is allowed to be accessed across origins; the
        presentation URL and presentation ID used to create the presentation
        are the only information needed to reconnect to a connection from any
        origin in that user agent. In other words, a presentation is not tied
        to a particular opening origin.
      </p>
      <p>
        This design allows controlling contexts from different domains to
        connect to a shared presentation resource. The security of the
        presentation ID prevents arbitrary pages from connecting to an existing
        presentation.
      </p>
      <p>
        This specification allows a user agent to publish information about its
        <a>set of controlled presentations</a>, and allows a browsing context
        on another user agent to connect to a running presentation via
        <code><a for="PresentationRequest">reconnect</a>()</code>. To connect,
        the additional browsing context must discover the presentation URL and
        presentation ID of the presentation, either provided by the user, or
        via a shared service.
      </p>
      <p>
        However, this specification makes no guarantee as to the identity of
        the connecting party. Once connected, the receiving application may
        wish to further verify the identity of the connecting party through
        application-specific means. For example, the connecting application
        could provide a token via <code><a for=
        "PresentationConnection">send</a>()</code> that the receiving
        application could verify corresponds an authorized entity.
      </p>
      <h3>
        User interface guidelines
      </h3>
      <dl>
        <dt>
          Origin display
        </dt>
        <dd>
          <p>
            When the user is asked permission to use a <a>presentation
            display</a> during the steps to <a>start a presentation</a>, the
            <a>controlling user agent</a> should make it clear what origin is
            requesting presentation <i>and</i> what origin will be presented.
          </p>
          <p>
            Display of the origin requesting presentation will help the user
            understand what content is making the request, especially when the
            request is initiated from a <a>nested browsing context</a>. For
            example, embedded content may try to convince the user to click to
            trigger a request to start an unwanted presentation.
          </p>
          <p>
            Showing the origin that will be presented will help the user know
            if that content is from an <a>potentially secure</a> (e.g.,
            <code>https:</code>) origin, and corresponds to a known or expected
            site. For example, a malicious site may attempt to convince the
            user to enter login credentials into a presentation page that
            imitates a legimitate site. Examination of the requested origin
            will help the user detect these cases.
          </p>
        </dd>
        <dt>
          Cross-device access
        </dt>
        <dd>
          <p>
            When a user <a data-lt="start a presentation">starts a
            presentation</a>, the user will begin with exclusive control of the
            presentation. However, the Presentation API allows additional
            devices (likely belonging to distinct users) to connect and thereby
            control the presentation as well. When a second device connects to
            a presentation, it is recommended that all connected <a data-lt=
            "controlling user agent">controlling user agents</a> notify their
            users via the browser chrome that the original user has lost
            exclusive access, and there are now multiple controllers for the
            presentation.
          </p>
          <p>
            In addition, it may be the case that the <a>receiving user
            agent</a> is capable of receiving user input, as well as acting as
            a <a>presentation display</a>. In this case, the <a>receiving user
            agent</a> should notify its user via browser chrome when a
            <a>receiving browsing context</a> is under the control of a remote
            party (i.e., it has one or more connected controllers).
          </p>
        </dd>
      </dl>
      <h3>
        Device Access
      </h3>
      <p>
        The presentation API abstracts away what "local" means for displays,
        meaning that it exposes network-accessible displays as though they were
        local displays. The Presentation API requires user permission for a
        page to access any display to mitigate issues that could arise, such as
        showing unwanted content on a display viewable by others.
      </p>
      <h3>
        Temporary identifiers and browser state
      </h3>
      <p>
        The presentation URL and presentation ID can be used to connect to a
        presentation from another browsing context. They can be intercepted if
        an attacker can inject content into the controlling page.
      </p>
      <h3>
        Incognito mode and clearing of browsing data
      </h3>
      <p>
        The content displayed on the presentation is different from the
        controller. In particular, if the user is logged in in both contexts,
        then logs out of the <a>controlling browsing context</a>, she will not
        be automatically logged out from the <a>receiving browsing context</a>.
        Applications that use authentication should pay extra care when
        communicating between devices.
      </p>
      <p>
        The set of presentations known to the user agent should be cleared when
        the user requests to "clear browsing data."
      </p>
      <p>
        When in private browsing mode ("incognito"), the initial <a>set of
        controlled presentations</a> in that browsing session must be empty.
        Any <a data-lt="presentation connection">presentation connections</a>
        added to it must be discarded when the session terminates.
      </p>
      <h3>
        Messaging between presentation connections
      </h3>
      <p>
        This spec will not mandate communication protocols between the
        <a>controlling browsing context</a> and the <a>receiving browsing
        context</a>, but it should set some guarantees of message
        confidentiality and authenticity between corresponding <a>presentation
        connections</a>.
      </p>
    </section>
    <section>
      <h2>
        Acknowledgments
      </h2>
      <p>
        Thanks to Wayne Carr, Louay Bassbouss, Anssi Kostiainen, éµæ´ªæ³¢ (Hongbo
        Min), Anton Vayvod, and Mark Foltz for help with editing, reviews and
        feedback to this draft.
      </p>
    </section>
  </body>
</html>

