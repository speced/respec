/*jshint
    forin: false
*/
/*global hb*/

// Module geonovum/headers
// Generate the headers material based on the provided configuration.
// CONFIGURATION
//  - specStatus: the short code for the specification's maturity level (required)
//  - specType: the short code for the specification type (required)
//  - shortName: the small name that is used after /TR/ in published reports (required)
//  - editors: an array of people editing the document (at least one is required). People
//      are defined using:
//          - name: the person's name (required)
//          - url: URI for the person's home page
//          - company: the person's company
//          - companyURL: the URI for the person's company
//          - mailto: the person's email
//          - note: a note on the person (e.g. former editor)
//  - authors: an array of people who are contributing authors of the document.
//  - subtitle: a subtitle for the specification
//  - github: a link to the github repository used for the specification
//  - publishDate: the date to use for the publication, default to document.lastModified, and
//      failing that to now. The format is YYYY-MM-DD or a Date object.
//  - previousPublishDate: the date on which the previous version was published.
//  - previousMaturity: the specStatus of the previous version
//  - logos: a list of logos to use instead of the W3C logo, each of which being defined by:
//          - src: the URI to the logo (target of <img src=>)
//          - alt: alternate text for the image (<img alt=>), defaults to "Logo" or "Logo 1", "Logo 2", ...
//            if src is not specified, this is the text of the "logo"
//          - height: optional height of the logo (<img height=>)
//          - width: optional width of the logo (<img width=>)
//          - url: the URI to the organization represented by the logo (target of <a href=>)
//          - id: optional id for the logo, permits custom CSS (wraps logo in <span id=>)
//          - each logo element must specifiy either src or alt
//  - additionalCopyrightHolders: a copyright owner in addition to W3C (or the only one if specStatus
//      is unofficial)
//  - overrideCopyright: provides markup to completely override the copyright
//  - thisVersion: the URI to the dated current version of the specification. ONLY ever use this for CG/BG
//      documents, for all others it is autogenerated.
//  - latestVersion: the URI to the latest (undated) version of the specification. ONLY ever use this for CG/BG
//      documents, for all others it is autogenerated.
//  - prevVersion: the URI to the previous (dated) version of the specification. ONLY ever use this for CG/BG
//      documents, for all others it is autogenerated.
//  - otherLinks: an array of other links that you might want in the header (e.g., link github, twitter, etc).
//         Example of usage: [{key: "foo", href:"https://b"}, {key: "bar", href:"https://"}].
//         Allowed values are:
//          - key: the key for the <dt> (e.g., "Bug Tracker"). Required.
//          - value: The value that will appear in the <dd> (e.g., "GitHub"). Optional.
//          - href: a URL for the value (e.g., "https://foo.com/issues"). Optional.
//          - class: a string representing CSS classes. Optional.

import { concatDate, joinAnd, ISODate } from "core/utils";
import hb from "handlebars.runtime";
import { pub } from "core/pubsubhub";
import tmpls from "templates";

export const name = "geonovum/headers";

const headersTmpl = tmpls["headers.html"];

const GNVMDate = new Intl.DateTimeFormat(["nl"], {
  timeZone: "UTC",
  year: "numeric",
  month: "long",
  day: "2-digit",
});

hb.registerHelper("showPeople", function(name, items) {
  // stuff to handle RDFa
  var re = "",
    rp = "",
    rm = "",
    rn = "",
    rwu = "",
    rpu = "",
    bn = "",
    editorid = "",
    propSeeAlso = "";
  if (this.doRDFa) {
    if (name === "Editor") {
      bn = "_:editor0";
      re = " property='bibo:editor' resource='" + bn + "'";
      rp = " property='rdf:first' typeof='foaf:Person'";
    } else if (name === "Author") {
      rp = " property='dc:contributor' typeof='foaf:Person'";
    }
    rn = " property='foaf:name'";
    rm = " property='foaf:mbox'";
    rwu = " property='foaf:workplaceHomepage'";
    rpu = " property='foaf:homepage'";
    propSeeAlso = " property='rdfs:seeAlso'";
  }
  var ret = "";
  for (var i = 0, n = items.length; i < n; i++) {
    var p = items[i];
    if (p.w3cid) {
      editorid = " data-editor-id='" + parseInt(p.w3cid, 10) + "'";
    }
    if (this.doRDFa) {
      ret +=
        "<dd class='p-author h-card vcard' " +
        re +
        editorid +
        "><span" +
        rp +
        ">";
      if (name === "Editor") {
        // Update to next sequence in rdf:List
        bn = i < n - 1 ? "_:editor" + (i + 1) : "rdf:nil";
        re = " resource='" + bn + "'";
      }
    } else {
      ret += "<dd class='p-author h-card vcard'" + editorid + ">";
    }
    if (p.url) {
      if (this.doRDFa) {
        ret +=
          "<meta" +
          rn +
          " content='" +
          p.name +
          "'><a class='u-url url p-name fn' " +
          rpu +
          " href='" +
          p.url +
          "'>" +
          p.name +
          "</a>";
      } else
        ret +=
          "<a class='u-url url p-name fn' href='" +
          p.url +
          "'>" +
          p.name +
          "</a>";
    } else {
      ret += "<span" + rn + " class='p-name fn'>" + p.name + "</span>";
    }
    if (p.company) {
      ret += ", ";
      if (p.companyURL)
        ret +=
          "<a" +
          rwu +
          " class='p-org org h-org h-card' href='" +
          p.companyURL +
          "'>" +
          p.company +
          "</a>";
      else ret += p.company;
    }
    if (p.mailto) {
      ret +=
        ", <span class='ed_mailto'><a class='u-email email' " +
        rm +
        " href='mailto:" +
        p.mailto +
        "'>" +
        p.mailto +
        "</a></span>";
    }
    if (p.note) ret += " (" + p.note + ")";
    if (p.extras) {
      var self = this;
      var resultHTML = p.extras
        // Remove empty names
        .filter(function(extra) {
          return extra.name && extra.name.trim();
        })
        // Convert to HTML
        .map(function(extra) {
          var span = document.createElement("span");
          var textContainer = span;
          if (extra.class) {
            span.className = extra.class;
          }
          if (extra.href) {
            var a = document.createElement("a");
            span.appendChild(a);
            a.href = extra.href;
            textContainer = a;
            if (self.doRDFa) {
              a.setAttribute("property", "rdfs:seeAlso");
            }
          }
          textContainer.innerHTML = extra.name;
          return span.outerHTML;
        })
        .join(", ");
      ret += ", " + resultHTML;
    }
    if (this.doRDFa) {
      ret += "</span>\n";
      if (name === "Editor")
        ret += "<span property='rdf:rest' resource='" + bn + "'></span>\n";
    }
    ret += "</dd>\n";
  }
  return new hb.SafeString(ret);
});

function toLogo(obj) {
  const a = document.createElement("a");
  if (!obj.alt) {
    const msg = "Found spec logo without an `alt` attribute. See dev console.";
    a.classList.addClass("respec-offending-element");
    pub("warn", msg);
    console.warn("warn", msg, a);
  }
  a.href = obj.href ? obj.href : "";
  a.classList.add("logo");
  hyperHTML.bind(a)`
  <img
    id="${obj.id}"
    alt="${obj.alt}"
    src="${obj.src}"
    width="${obj.width}"
    height="${obj.height}">
  `;
  // avoid triggering 404 requests from dynamically generated
  // hyperHTML attribute values
  a.querySelector("img").src = obj.src;
  return a;
}

hb.registerHelper("showLogos", logos => {
  const p = document.createElement("p");
  hyperHTML.bind(p)`${logos.map(toLogo)}`;
  return p.outerHTML;
});

hb.registerHelper("switch", function(value, options) {
  this._switch_value_ = value;
  this._switch_break_ = false;
  var html = options.fn(this);
  delete this._switch_break_;
  delete this._switch_value_;
  return html;
});

hb.registerHelper("case", function(value, options) {
  var args = Array.prototype.slice.call(arguments);
  var options = args.pop();
  var caseValues = args;

  if (this._switch_break_ || caseValues.indexOf(this._switch_value_) === -1) {
    return "";
  } else {
    this._switch_break_ = true;
  }
  return options.fn(this);
});

hb.registerHelper("default", function(options) {
  if (!this._switch_break_) {
    return options.fn(this);
  }
});

const status2text = {
  "GN-WV": "Werkversie",
  "GN-CV": "Consultatieversie",
  "GN-VV": "Versie ter vaststelling",
  "GN-DEF": "Vastgestelde versie",
  "GN-BASIS": "Document",
};
const type2text = {
  NO: "Norm",
  ST: "Standaard",
  IM: "Informatiemodel",
  PR: "Praktijkrichtlijn",
  HR: "Handreiking",
  WA: "Werkafspraak",
};
const noTrackStatus = ["GN-BASIS"];
const baseLogo = Object.freeze({
  id: "",
  alt: "",
  href: "",
  src: "",
  height: "67",
  width: "132",
});

export function run(conf, doc, cb) {
  // TODO: move to w3c defaults
  if (!conf.logos) {
    conf.logos = [];
  }
  conf.specStatus = conf.specStatus ? conf.specStatus.toUpperCase() : "";
  conf.specType = conf.specType ? conf.specType.toUpperCase() : "";
  conf.pubDomain = conf.pubDomain ? conf.pubDomain.toLowerCase() : "";
  conf.isRegular = conf.specStatus !== "GN-BASIS";
  conf.isNoTrack = noTrackStatus.includes(conf.specStatus);
  conf.isOfficial = conf.specStatus === "GN-DEF";
  conf.textStatus = status2text[conf.specStatus];
  conf.typeStatus = type2text[conf.specType];
  //Some errors
  if (!conf.specStatus) {
    pub("error", "Missing required configuration: specStatus");
  }
  if (conf.isRegular && !conf.specType) {
    pub("error", "Missing required configuration: specType");
  }
  if (conf.isRegular && !conf.pubDomain) {
    pub("error", "Missing required configuration: pubDomain");
    conf.pubDomain = "none";
  }
  if (conf.isRegular && !conf.shortName) {
    pub("error", "Missing required configuration: shortName");
  }
  if (!conf.isOfficial && !conf.github) {
    pub("error", "Missing required configuration: github");
  }
  if (conf.previousPublishDate && !conf.previousStatus) {
    pub("error", "Missing configuration: previousStatus");
  }
  if (!conf.previousPublishDate && conf.previousStatus) {
    pub("error", "Missing configuration: previousPublishDate");
  }
  if (!conf.editors || conf.editors.length === 0) {
    pub("error", "At least one editor is required");
  }
  //Titles
  conf.title = doc.title || "No Title";
  if (!conf.subtitle) conf.subtitle = "";
  //Publishdate
  conf.publishDate = new Date(
    ISODate.format(
      new Date(conf.publishDate ? conf.publishDate : doc.lastModified)
    )
  );
  conf.publishHumanDate = GNVMDate.format(conf.publishDate);
  //Version URLs
  if (conf.isRegular && conf.specStatus !== "GN-WV") {
    conf.thisVersion =
      "https://docs.geostandaarden.nl/" +
      conf.pubDomain +
      "/" +
      conf.specStatus.substr(3).toLowerCase() +
      "-" +
      conf.specType.toLowerCase() +
      "-" +
      conf.shortName +
      "-" +
      concatDate(conf.publishDate) +
      "/";
  } else {
    conf.thisVersion = conf.edDraftURI;
  }
  if (conf.isRegular)
    conf.latestVersion =
      "https://docs.geostandaarden.nl/" +
      conf.pubDomain +
      "/" +
      conf.shortName +
      "/";
  if (conf.previousPublishDate && conf.previousStatus) {
    conf.previousPublishDate = new Date(conf.previousPublishDate);
    var prevStatus = conf.previousStatus.substr(3).toLowerCase();
    var prevType = conf.previousType.toLowerCase();
    conf.prevVersion = "None" + conf.previousPublishDate;
    conf.prevVersion =
      "https://docs.geostandaarden.nl/" +
      conf.pubDomain +
      "/" +
      prevStatus +
      "-" +
      prevType +
      "-" +
      conf.shortName +
      "-" +
      concatDate(conf.previousPublishDate) +
      "/";
  }
  //Authors & Editors
  var peopCheck = function(it) {
    if (!it.name) pub("error", "All authors and editors must have a name.");
  };
  if (conf.editors) {
    conf.editors.forEach(peopCheck);
  }
  if (conf.authors) {
    conf.authors.forEach(peopCheck);
  }
  conf.multipleEditors = conf.editors && conf.editors.length > 1;
  conf.multipleAuthors = conf.authors && conf.authors.length > 1;
  //Alternate formats
  $.each(conf.alternateFormats || [], function(i, it) {
    if (!it.uri || !it.label)
      pub("error", "All alternate formats must have a uri and a label.");
  });
  conf.multipleAlternates =
    conf.alternateFormats && conf.alternateFormats.length > 1;
  conf.alternatesHTML = joinAnd(conf.alternateFormats, function(alt) {
    var optional =
      alt.hasOwnProperty("lang") && alt.lang
        ? " hreflang='" + alt.lang + "'"
        : "";
    optional +=
      alt.hasOwnProperty("type") && alt.type ? " type='" + alt.type + "'" : "";
    return (
      "<a rel='alternate' href='" +
      alt.uri +
      "'" +
      optional +
      ">" +
      alt.label +
      "</a>"
    );
  });
  //Annotate html element with RFDa
  if (conf.doRDFa === undefined) conf.doRDFa = true;
  if (conf.doRDFa) {
    if (conf.rdfStatus)
      $("html").attr("typeof", "bibo:Document " + conf.rdfStatus);
    else $("html").attr("typeof", "bibo:Document ");
    var prefixes =
      "bibo: http://purl.org/ontology/bibo/ w3p: http://www.w3.org/2001/02pd/rec54#";
    $("html").attr("prefix", prefixes);
    $("html>head").prepend(
      $("<meta lang='' property='dc:language' content='en'>")
    );
  }
  //headersTmpl
  var bp = headersTmpl(conf);
  $("body", doc).prepend($(bp)).addClass("h-entry");
  //SotD
  var sotd =
    document.body.querySelector("#sotd") || document.createElement("section");
  sotd.id = sotd.id || "stod";
  sotd.classList.add("introductory");
  sotd.innerHTML = populateSoTD(conf, sotd);
  function populateSoTD(conf, sotd) {
    const sotdClone = sotd.cloneNode(true);
    const additionalNodes = document.createDocumentFragment();
    const additionalContent = document.createElement("temp");
    // we collect everything until we hit a section,
    // that becomes the custom content.
    while (sotdClone.hasChildNodes()) {
      if (
        sotdClone.firstChild.nodeType !== Node.ELEMENT_NODE ||
        sotdClone.firstChild.localName !== "section"
      ) {
        additionalNodes.appendChild(sotdClone.firstChild);
        continue;
      }
      break;
    }
    additionalContent.appendChild(additionalNodes);
    conf.additionalContent = additionalContent.innerHTML;
    // Whatever sections are left, we throw at the end.
    conf.additionalSections = sotdClone.innerHTML;
    return tmpls["sotd.html"](conf);
  }
  cb();
}
