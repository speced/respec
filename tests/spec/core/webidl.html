<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'/>
    <title>WebIDL Tests</title>
    <script class="remove">
      var respecConfig = {
        specStatus: "base",
        shortName: "webidl",
        editors: [{name: "foo"}],
      };
    </script>
  </head>
  <body>
    <section>
      <h2>Section with definitions</h2>
      <p>
        <dfn>TestInterface</dfn> interface
        <dfn>TestCBInterface</dfn> interface
        <dfn>TestDictionary</dfn> dictionary
        <dfn>TestEnum</dfn> enum
        <dfn>TestMixin</dfn> mixin interface
        <dfn>TestCallBack</dfn> callback
        <dfn>TestTypedef</dfn> typedef
      </p>
    </section>
    <section id="sec-parenthesis-method" data-dfn-for="ParenthesisTest" data-link-for="ParenthesisTest">
      <h2>More linking</h2>
      <pre class="idl no-link-warnings">
      [Exposed=Window]
      interface ParenthesisTest {
          undefined basic();
          undefined noParens();
          [Something] undefined ext();
          unsigned long long ull(short s);
          unsigned long long ull(long s);
          getter float withName ();
          setter undefined named ();
          undefined dataLtOverride();
          undefined fullyQualified();
          undefined fullyQualifiedNoParens();
          undefined doTheFoo();
      };
      </pre>
      <pre class="idl" id="similar-names">
      // makes sure that types and identifiers are not confused
      [Exposed=Window]
      interface SimilarlyNamed {
        attribute TestInterface testInterface;
        attribute TestCBInterface testCBInterface;
        attribute TestDictionary testDictionary;
        attribute TestEnum testEnum;
        attribute TestTypedef testTypedef;
        readonly maplike&lt;SimilarlyNamed, SimilarlyNamed>;
      };
      TestInterface includes TestMixin;
      [Exposed=Window]
      interface TestInterface {};
      callback interface TestCBInterface {};
      typedef (TestInterface or TestCBInterface) TestTypedef;
      callback TestCallBack = TestCallBack ();
      dictionary TestDictionary {};
      enum TestEnum { "value" };
      interface mixin TestMixin {
        attribute Bar bar;
      };
      [Exposed=Window]
      interface Bar {};
      </pre>
      <section data-dfn-for="SimilarlyNamed">
        <h3><dfn>SimilarlyNamed</dfn> interface</h3>
        <p>
          <dfn>testInterface</dfn> attribute;
          <dfn>testCBInterface</dfn> attribute;
          <dfn>testDictionary</dfn> attribute;
          <dfn>testEnum</dfn> attribute;
          <dfn>testTypedef</dfn> attribute;
        </p>
      </section>
      <p data-dfn-for="TestMixin"><dfn>bar</dfn> attribute of TestMixin</p>
      <p id="meth-basic-doc" data-dfn-for="ParenthesisTest">
        <dfn>ull()</dfn> is a method. Its <dfn data-lt="ull!overload-1">overloaded form</dfn> returns a <code>SuperStar/</code>
      </p>
      <p><dfn data-lt="this also links">dataLtOverride()</dfn></p>
      <p><dfn>ParenthesisTest</dfn></p>
      <p><dfn>basic()</dfn>...</p>
      <p><dfn>ext()</dfn>...</p>
      <p><dfn>paramed()</dfn>...</p>
      <p><dfn>withName()</dfn>...</p>
      <p><dfn>named()</dfn>...</p>
      <p><dfn>dfnDoesNotLinkToAnything()</dfn>...</p>
      <p><dfn>noParens</dfn>...</p>
      <p><dfn>ParenthesisTest.fullyQualified()</dfn>...</p>
      <p><dfn>ParenthesisTest.fullyQualifiedNoParens</dfn> ...</p>
      <p>1 <a>basic</a></p>
      <p>2 <a>basic()</a></p>
      <p>3 <a data-lt="basic">basic</a></p>
      <p>4 <a data-lt="basic()">basic</a></p>
      <p><a>noParens</a></p>
      <p><a>noParens()</a></p>
      <p><a data-lt="noParens">noParens</a></p>
      <p><a data-lt="noParens()">noParens</a></p>
      <p><a>noParens()</a></p>
      <p><a data-lt="this also links">this also links</a></p>
    </section>
    <p><a data-lt="ParenthesisTest.basic">test qualified</a></p>
    <p><a id="fullyQualifiedNoParens-1">ParenthesisTest.fullyQualifiedNoParens</a></p>
    <p><a id="fullyQualifiedNoParens-2">ParenthesisTest.fullyQualifiedNoParens()</a></p>
    <p><a id="fullyQualifiedNoParens-3" data-link-for="ParenthesisTest">fullyQualifiedNoParens()</a></p>
    <p><a id="fullyQualifiedNoParens-4" data-link-for="ParenthesisTest">fullyQualifiedNoParens</a></p>
    <section>
      <h2><dfn>Bar</dfn> interface</h2>
    </section>
    <section>
      <h2>Unsupported</h2>
      <p>
        The following aspects of WebIDL are not currently supported and are not yet tested for:
      </p>
      <ul>
        <li>
          Names that begin with <code>_</code> in the IDL must drop the leading <code>_</code> for
          their real name.
        </li>
        <li>
          Static, inherit, stringifier attributes.
        </li>
        <li>Static operations</li>
        <li>Default arguments</li>
        <li>IDL wrapping</li>
        <li>Special operations</li>
        <li>Union types</li>
        <li>partial dictionaries</li>
      </ul>
      <p>
        Support for these features will likely be added later.
      </p>
      <p>
        The following features are supposedly supported but actually buggy:
      </p>
      <ul>
        <li><em>list currently empty</em></li>
      </ul>
      <p>
        Things that still need to be done:
      </p>
      <ul>
        <li>Check that sequence, Promise, ?, and other such bothersome types are tested everywhere</li>
      </ul>
    </section>
    <section>
      <h2>Interfaces</h2>
      <p>
        Basic interface.
      </p>
      <pre id='if-basic' class='idl'>
        [Something, Exposed=Window]
        interface SuperStar {
          constructor();
        };
      </pre>
      <p>
        Interface with extended attribute.
      </p>
      <pre id='if-extended-attribute' class='idl'>
        [Something, Exposed=Window]
        interface SuperStar {
          constructor();
        };
      </pre>
      <p>
        Interface with extended attribute and RHS identifier list.
      </p>
      <pre id='if-identifier-list' class='idl'>
        [Global=Window, Exposed=(Window,Worker)] interface SuperStar {};
      </pre>
      <p>
        Interface with inheritance.
      </p>
      <pre id='if-inheritance' class='idl'>
        [Exposed=Window] interface SuperStar : HyperStar {};
      </pre>
      <p>
        Partial interface .
      </p>
      <pre id='if-partial' class='idl'>
        partial interface SuperStar {};
      </pre>
      <p>
        Callback interface .
      </p>
      <pre id='if-callback' class='idl'>
        callback interface SuperStar {};
      </pre>
      <p>
        Interface mixin .
      </p>
      <pre id='if-mixin' class='idl'>
        interface mixin SuperStar {};
      </pre>
      <pre id='if-partial-mixin' class='idl'>
        partial interface mixin SuperStar {};
      </pre>
      <pre id='if-doc' class='idl'>
        [Exposed=Window]
        interface DocInterface {};
        [Exposed=Window]
        interface DocIsNotCaseSensitive {};
        [Exposed=Window]
        interface UndocInterface {};
        [Exposed=Window]
        namespace Afterglow {};
      </pre>
      <p id='if-doc-p'>
        <dfn>DocInterface</dfn> is an interface and so is <dfn>DoCiSnOtCaSeSeNsItIvE</dfn>.
        <dfn>Afterglow</dfn> is a namespace.
      </p>
    </section>
    <section>
      <h2>Constructors</h2>
      <p>
        Constructors on interfaces
      </p>
      <pre id='ctor-basic' class='idl'>
        [NoSomething, Exposed=Window]
        interface SuperStar {
          constructor();
          constructor(boolean bar, sequence&lt;double> foo);
        };
      </pre>
      <pre id='ctor-noea' class='idl'>
        [Exposed=Window]
        interface SuperStar {
          constructor();
        };
      </pre>
    </section>
    <section>
      <h2>Constants</h2>
      <p>
        All constants and some type testing
      </p>
      <pre id='const-basic' class='idl'>
        [Exposed=Window]
        interface ConstTest {
          // 1
          const boolean test = true;
          // 2
          const byte bite = 8;
          // 3
          const octet eight = 7;
          // 4
          const short small = 42;
          // 5
          const unsigned short shortish = 250;
          // 6
          const long notSoLong = 99999;
          // 7
          const unsigned long somewhatLong = 9999999;
          // 8
          const long long veryLong = 9999999999999;
          // 9
          const unsigned long long soLong = 99999999999999999;
          // 10
          const float ationDevice = 4.2;
          // 11
          const unrestricted float buoy = 4.2222222222;
          // 12
          const double twice = 4.222222222;
          // 13
          const unrestricted double rambaldi = 47.0;
          // 14
          const short inf = Infinity;
          // 15
          const short mininf = -Infinity;
          // 16
          const short cheese = NaN;
          // 17
          [Something] const short extAttr = NaN;
        };
      </pre>
      <p id="const-basic-doc">
        <dfn data-dfn-for="ConstTest">rambaldi</dfn> is a constant and so are <dfn data-dfn-for="ConstTest">bite</dfn> and <dfn data-dfn-for="ConstTest" data-lt="inf">this other thing</dfn>.
      </p>
    </section>
    <section>
      <h2>Attributes</h2>
      <p>
        Basic attributes testing.
      </p>
      <p>
        The <dfn>Performance</dfn> interface.
      </p>
      <p data-dfn-for="AttrBasic">
        The <dfn>performance</dfn> attribute.
      </p>
      <pre id='attr-basic' class='idl'>
        [Exposed=Window]
        interface AttrBasic {
          // 1
          attribute DOMString regular;
          // 2
          readonly attribute DOMString ro;
          // 2.2
          readonly attribute DOMString _readonly;
          // 2.5
          inherit attribute DOMString in;
          // 2.7
          stringifier attribute DOMString st;
          // 3
          [Something] readonly attribute DOMString ext;
          // 3.10.31
          attribute FrozenArray&lt;DOMString&gt; alist;
          // 4.0
          attribute Promise&lt;DOMString&gt; operation;
          // 5.0
          readonly attribute Performance performance;<!--
          // 3
           static attribute DOMString unmovable;
          // 4
          stringifier attribute DOMString asString;
          // 5
          inherit attribute DOMString css;
          // 6
          static inherit readonly attribute DOMString everything;
          // 7
          stringifier inherit readonly attribute DOMString all;-->
        };
      </pre>
      <p id="attr-basic-doc" data-dfn-for="AttrBasic"><dfn>readonly</dfn> and <dfn>regular</dfn> are attributes.</p>
    </section>
    <section>
      <h2>Operations</h2>
      <p>
        Basic operations testing.
      </p>
      <!--
      getter, setter, creator, deleter, stringifier, serilizer
      static
      specials don't necessarily have an indentifier
       -->
       <pre class="idl" id="stringifiertest">
        [Exposed=Window]
        interface StringifierTest {
          stringifier StringPass ();
          stringifier StringNamedPass named ();
        };
      </pre>
      <pre class="idl" id="gettertest">
        [Exposed=Window]
        interface GetterTest {
          getter GetterPass ();
          getter GetterNamedPass named ();
        };
      </pre>
      <pre class="idl" id="settertest">
        [Exposed=Window]
        interface SetterTest {
          setter SetterPass ();
          setter SetterNamedPass named ();
        };
      </pre>
      <p data-dfn-for="MethBasic">
        <dfn>performance()</dfn> method.
      </p>
      <pre id='meth-basic' class='idl'>
        [Exposed=Window]
        interface MethBasic {
          // 1
          undefined basic();
          // 2
          [Something] undefined ext();
          // 3
          unsigned long long ull(short s, short n);
          // 3.5
          SuperStar? ull();
          // 5
          getter float ();
          // 6
          getter float withName ();
          // 7
          setter undefined ();
          // 8
          setter undefined named ();
          // 9
          static Promise&lt;RTCCertificate>  generateCertificate(AlgorithmIdentifier keygenAlgorithm);
          // 10
          stringifier DOMString identifier();
          // 11
          stringifier DOMString ();
          // 12
          stringifier;
          Promise&lt;undefined> complete(optional PaymentComplete result = "unknown");
          Promise&lt;undefined> another(optional  /*trivia*/  PaymentComplete result = "unknown");
          Performance performance();
        };
      </pre>
      <p id="meth-basic-doc" data-dfn-for="MethBasic">
        <dfn>ull</dfn> is a method. Its <dfn data-lt="ull!overload-1">overloaded form</dfn> returns a <code>SuperStar/</code>
      </p>
    </section>
    <section>
      <h2>iterable/maplike/setlike declarations</h2>
      <pre id='iterable-like' class='idl'>
        [Exposed=Window]
        interface Yukina {
          iterable&lt;DOMString&gt;;
        };
        [Exposed=Window]
        interface Sayo {
          iterable&lt;DOMString, DOMString&gt;;
        };
        [Exposed=Window]
        interface Kasumi {
          maplike&lt;DOMString, DOMString&gt;;
        };
        [Exposed=Window]
        interface Arisa {
          setlike&lt;DOMString&gt;;
        };
      </pre>
      <pre class="idl" id='map-set-readonly'>
        [Exposed=Window]
        interface MapLikeInterface {
          maplike&lt;MapLikeInterface, MapLikeInterface&gt;;
        };
        [Exposed=Window]
        interface ReadOnlyMapLike {
          readonly maplike&lt;ReadOnlyMapLike, ReadOnlyMapLike&gt;;
        };
        [Exposed=Window]
        interface SetLikeInterface {
          setlike&lt;SetLikeInterface&gt;;
        };
        [Exposed=Window]
        interface ReadOnlySetLike {
          readonly setlike&lt;ReadOnlySetLike&gt;;
        };
      </pre>
      <p>
        <dfn>Yukina</dfn> interface
        <dfn>Sayo</dfn> interface
        <dfn>Kasumi</dfn> interface
        <dfn>Arisa</dfn> interface
        <dfn>MapLikeInterface</dfn> interface
        <dfn>ReadOnlyMapLike</dfn> interface
        <dfn>SetLikeInterface</dfn> interface
        <dfn>ReadOnlySetLike</dfn> interface
      </p>
    </section>
    <section>
      <h2>Dictionaries</h2>
      <p>
        Basic dictionary.
      </p>
      <pre id='dict-basic' class='idl'>
        dictionary SuperStar {};
      </pre>
      <p>
        Inheriting dictionary.
      </p>
      <pre id='dict-inherit' class='idl'>
        dictionary SuperStar : HyperStar {};
      </pre>
      <p>
        Data in  dictionary.
      </p>
      <pre id='dict-fields' class='idl'>
        dictionary SuperStar {
          // 1
          DOMString value;
          // 2
          DOMString? nullable;
          // 3
          [Something]float ext;
          // 4
          unsigned long long longLong;

          // 5
          boolean test = true;
          // 6
          byte little = 2;
          // 7
          byte big = Infinity;
          // 8
          byte cheese = NaN;
          // 9
          DOMString blah = "blah blah";
        };
      </pre>
      <pre id='dict-required-fields' class='idl'>
        dictionary SuperStar {
          required DOMString value;
          DOMString optValue;
        };
      </pre>
      <pre id='dict-doc' class='idl'>
        dictionary DictDocTest {
          DOMString dictDocField;
          DOMString? otherField;
          long undocField;
        };
      </pre>
      <pre class="idl" id="multiple-dictionaries">
        dictionary OneThing {
          int x;
        };


        partial dictionary AnotherThing {
          int y;
        };
      </pre>
      <p id='dict-doc-p'><dfn>DictDocTest</dfn> contains <dfn data-dfn-for="DictDocTest">dictDocField</dfn> and <dfn data-dfn-for="DictDocTest">otherField</dfn></p>
    </section>
    <section id="enumerations">
      <h2>Enumerations</h2>
      <p>
        Basic enumeration.
      </p>
      <pre id='enum-basic' class='idl'>
        enum EnumBasic {
          // 1
          "one",
          // 2
          "two"
          // 3
          , "three",

          // 4
          "white space"
        };
      </pre>
      <p id="enum-basic-doc"><dfn>EnumBasic</dfn></p>
      <p data-dfn-for="EnumBasic"><dfn>one</dfn> is first.</p>
      <p data-link-for="EnumBasic"><a>one</a> is referenced with a <code>[link-for]</code> attribute.</p>
      <p id="enum-ref-without-link-for"><a>EnumBasic.one</a> may also be referenced with fully-qualified name.</p>
      <p><dfn data-dfn-for="EnumBasic">white space</dfn></p>
      <section id="enum-empty-sec" data-dfn-for="EmptyEnum">
        <h2>Enumeration with an empty string</h2>
        <pre class="idl no-link-warnings">
        enum EmptyEnum {
          "",
          "not empty"
        };
        </pre>
        <p><dfn>EmptyEnum</dfn></p>
        <p><dfn>""</dfn></p>...
        <p><dfn>not empty</dfn>...</p>
      </section>
    </section>
    <section id="multipleEnums" data-dfn-for="Test2">
      <h2>Multiple unique enums</h2>
      <pre class="idl">
        enum Test1 { "enum" };
        enum Test2 { "enum" };
      </pre>
      <p>
        <!-- Test1's enum -->
        <dfn data-dfn-for="Test1">enum</dfn>
        <!-- Test2's enum -->
        <dfn>enum</dfn>
      </p>
    </section>
    <section>
      <h2>Callbacks</h2>
      <p>
        Basic callback.
      </p>
      <pre id='cb-basic' class='idl'>
        callback SuperStar = undefined();
      </pre>
      <p>
        Less basic callback.
      </p>
      <pre id='cb-less-basic' class='idl'>
        callback CbLessBasic = unsigned long long?(optional any value);
      </pre>
      <p>
        Callback with multiple arguments.
      </p>
      <pre id='cb-mult-args' class='idl'>
        callback SortCallback = undefined (any a, any b);
      </pre>
      <p id="cb-less-basic-doc"><dfn>CbLessBasic</dfn></p>
      <!--
        XXX extattr?
       -->
    </section>
    <section>
      <h2>Typedefs</h2>
      <p>
        Basic typedef.
      </p>
      <pre id='td-basic' class='idl'>
        typedef DOMString string;
      </pre>
      <p>
        Less basic typedef.
      </p>
      <pre id='td-less-basic' class='idl'>
        typedef unsigned long long? tdLessBasic;
      </pre>
      <p id='td-less-basic-doc'><dfn>tdLessBasic</dfn></p>
      <p>
        Typedef with an extended attribute.
      </p>
      <pre id='td-extended-attribute' class='idl'>
        typedef ([Clamp] unsigned long or ConstrainULongRange) ConstrainULong;
      </pre>
      <p>
        Typedef with an extended attribute on union type.
      </p>
      <pre id='td-union-extended-attribute' class='idl'>
        typedef [Clamp] (unsigned long or ConstrainULongRange) ConstrainULong2;
      </pre>
      <pre id='td-trivia' class='idl'>
        /* test1 */ typedef /* test2 */ [Clamp] /* test3 */ (/* test4 */ unsigned long /* test5 */ or /* test6 */ ConstrainULongRange /* test7 */ ) /* test8 */ ConstrainULong3 /* test9 */;
      </pre>
    </section>
    <section>
      <h2>Includes</h2>
      <p>
        Basic includes.
      </p>
      <pre id='incl-basic' class='idl'>
        Window includes Document;
      </pre>
      <p>
        Less basic includes.
      </p>
      <pre id='incl-less-basic' class='idl'>
        [Something]Window includes Document;
      </pre>
    </section>
    <section id="documentation">
      <h2>Documentation</h2>
      <pre id='doc-iface' class='idl'>
        [Exposed=Window]
        interface Documented {
          attribute DOMString docString;
          attribute DOMString notDefined;
          attribute DOMString definedElsewhere;
        };
      </pre>
      <p class='note' data-dfn-for="Documented">
        <dfn>docString</dfn> is defined in a note.
      </p>
      <p data-link-for="Documented">
        Testing <code>[link-for]</code>:
        <dfn>Some generic term</dfn> isn't IDL.
        <a>Some generic term</a> also isn't part of <a>Documented</a>.
        <a>docString</a> is.
        <a>notDefined</a> is too, but isn't defined elsewhere.
      </p>
      <p>
        <dfn>Documented.definedElsewhere</dfn> is defined by writing its fully-qualified name.
        <a>Documented.docString</a> is linked by writing its fully-qualified name.
      </p>
      <p id="without-link-for">
        We had a bug where <a>Documented</a> got a [dfn-for] attribute,
        which broke links to it without [link-for].
      </p>
    </section>
    <section>
      <h2>IDL block with arbitrary CSS classes</h2>
      <pre id='retain-css-classes' class='idl a b c overlarge'>
        [Exposed=Window]
        interface NotTested {};
      </pre>
    </section>
    <section>
      <h2>Autolink to WebIDL spec for toJSON</h2>
      <pre id="AutoLinkToIDLSpec" class="idl">
        [Exposed=Window]
        interface AutoLinkToIDLSpec {
          [Default] object toJSON();
        };
      </pre>
    </section>
    <section data-link-for="AutoLinkToIDLSpecLinkFor">
      <h2>Autolink to WebIDL spec for toJSON with data-link-for</h2>
      <pre id="AutoLinkToIDLSpecLinkFor" class="idl">
        [Exposed=Window]
        interface AutoLinkToIDLSpecLinkFor {
          [Default] object toJSON();
        };
      </pre>
    </section>
    <section id="DefinedToJson" data-dfn-for="DefinedToJson" data-link-for="DefinedToJson">
      <h2>We can define our own toJSON()</h2>
      <pre class="idl">
        [Exposed=Window]
        interface DefinedToJson {
          readonly attribute DOMString country;
          [Default] object toJSON();
          undefined toWhatever();
        };
      </pre>
      <section>
      <h2><dfn>toJSON()</dfn> method</h2>
      <p>When <a>toJSON()</a> is called, run [[WEBIDL]]'s <a data-cite="WEBIDL#default-tojson-steps">default toJSON steps</a>.</p>
      </section>
    </section>
    <section>
      <h2>Optionals and trivia</h2>
      <pre class="idl" id="optional-trivia">
        [Exposed=Window]
        interface Foo {
          constructor(X x, optional Y y, /*trivia*/ Z y);
          undefined foo(X x, optional Y y, /*trivia*/ optional Z z);
        };
        callback CallBack = Z? (X x, optional Y y, /*trivia*/ optional Z z);
      </pre>
    </section>
    <section data-dfn-for="CodedThings">
        <h2><dfn>CodedThings</dfn> interface</h2>
        <pre class="idl">
        [Exposed=Window]
        interface CodedThings {
          attribute DOMString definedElsewhere;
          attribute Bar barBar;
          undefined doTheFoo();
        };
        </pre>
        <dfn>doTheFoo()</dfn>
        <dfn>barBar</dfn>
      </section>
      <section data-link-for="CodedThings">
        <h2>All these things surrounded by code elements</h2>
        <ol id="coded-things">
          <li><dfn>CodedThings.definedElsewhere</dfn>
          <li><a>CodedThings.barBar</a>
          <li><a>barBar</a>
          <li><a>CodedThings.doTheFoo()</a>
          <li><a>CodedThings.doTheFoo</a>
          <li><a>doTheFoo()</a>
          <li><a>doTheFoo</a>
        </ol>
      </section>
      <section id="idl-dfn-types">
        <h2>It gives definitions the right idl type</h2>
        <pre class="idl">
          [Exposed=Window]
          interface InterfaceType {
            readonly attribute DOMString attributeType;
            undefined operationType();
          };
          dictionary DictionaryType {
            DOMString fieldType;
          };
          enum EnumType {
            "enumValueType"
          };
        </pre>
        <p>
          <dfn>InterfaceType</dfn>
          <dfn data-dfn-for="InterfaceType">attributeType</dfn>
          <dfn data-dfn-for="InterfaceType">operationType</dfn>
          <dfn>DictionaryType</dfn>
          <dfn data-dfn-for="DictionaryType">fieldType</dfn>
          <dfn>EnumType</dfn>
          <dfn data-dfn-for="EnumType">enumValueType</dfn>
        </p>
      </section>
  </body>
</html>
